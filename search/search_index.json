{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Free Pascal Cookbook","text":"<p>Welcome to my Free Pascal Cookbook!</p> <p>Inside, you'll discover a collection of handy snippets and study notes for Object Pascal using the Free Pascal programming language with Lazarus IDE. Discover time-saving recipes and streamline your work in Free Pascal!</p> <p>If you're seeking tutorials and in-depth technical discussions, don't miss Resources.</p>"},{"location":"#official-free-pascal-docs","title":"Official Free Pascal docs","text":"<p>Note</p> <p>I do not own these docs. The FPC devs prepared these handly information in both PDF and HTML formats.</p> PDF HTML Document PDF HTML User's guide PDF HTML Programmer's guide PDF HTML Language reference guide PDF HTML Run-Time Library (RTL) units reference manual PDF HTML Free Component Library (FCL) units reference manual PDF HTML Free Component Library (FCL) Resource units reference manual PDF HTML fpdoc documentation tool reference manual PDF NA Reference chart with all compiler options and switches (PDF only)"},{"location":"#code-repos","title":"Code Repos","text":"<p>The repo of the Free Pascal Compiler: FPC - Gitlab</p> <p>The repo of the Lazarus IDE: Lazarus IDE - Gitlab</p> <p>The repo of the snippets: https://github.com/ikelaiah/free-pascal-snippets.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>The FPC devs for sharing the joy of Object Pascal.</li> <li>The Lazarus IDE devs for making such an amazing IDE.</li> <li>The dedicated people behind various units/modules in OPM.</li> <li> <p>The kind and helpful individuals on various online platforms such as;</p> <ul> <li>Unofficial Free Pascal discord server.</li> <li>Free Pascal &amp; Lazarus forum.</li> <li>Tweaking4All Delphi, Lazarus, Free Pascal forum.</li> <li>Laz Planet - Blogspot / Laz Planet - GitLab.</li> <li>Delphi Basics.</li> </ul> </li> </ul> <p>Note</p> <p>Code snippets on this site work with <code>FPC 3.2.2</code> and <code>Lazarus 3.4</code> on Win 11.</p> <p>Warning</p> <p>This document is a work in progress. </p> <p>Contents are still being revised and added.</p>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright \u00a9 2024 ikelaiah</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/","title":"About This Site","text":""},{"location":"about/#why-this-site","title":"Why This Site?","text":"<ol> <li>When I started to learn Object Pascal with Free Pascal, I found the wikis informative, but difficult for me to follow due to my knowledge gap and English as second language.</li> <li>I found gems on Free Pascal (and Lazarus) out there and would like to put them all in one bucket for quick retrieval.</li> <li>Documenting stuff is theraputic.</li> </ol> <p>Hence, this site.</p> <p>I'm compiling my own snippets and others, also related resources for studying Free Pascal. I'm hoping others would find these collections useful too.</p> <p>I've taken care to acknowledge the original location of information &amp; authors whenever possible. If I overlooked anyone, please inform me.</p> <p>Thanks for reading.</p>"},{"location":"community/","title":"Community","text":"<p>Here are chats, mailing lists, conferences and events that relate to Free Pascal, Lazarus and other Object Pascal dialects that transferrable to Free Pascal.</p>"},{"location":"community/#chats","title":"Chats","text":""},{"location":"community/#forums","title":"Forums","text":"<ul> <li>Free Pascal and Lazarus</li> <li>Begin End - A blog aggregator site for all things Object Pascal; Delphi, Lazarus + Free Pascal.</li> </ul>"},{"location":"community/#discord-servers","title":"Discord Servers","text":"<ul> <li>Unofficial Free Pascal</li> <li>Delphi Community</li> </ul>"},{"location":"community/#email-lists","title":"Email Lists","text":"<ul> <li>Free Pascal Mailing Lists<ul> <li>FPC-Pascal: Use the Free Pascal mailing list for questions, updates, and assistance in current and future developments.</li> <li>FPC-Devel: Join the development mailing list for bug reports or technical questions. It's also used to announce new snapshots and small patches for compiler bugs.</li> <li>FPC-Announce: Important announcements (e.g., new releases) will be posted here.</li> <li><code>pas2js</code>: For questions and discussions on the <code>pas2js</code> (Pascal-to-JavaScript) compiler.</li> <li>FPC-Other: For all other topics not covered in the above categories.</li> <li>MacPascal: This is the place for discussions about using FPC on the Mac and for iOS devices, although it's not FPC-specific.</li> </ul> </li> <li>Lazarus Mailing Lists</li> </ul>"},{"location":"community/#devsrepos","title":"Devs/Repos","text":"<ul> <li>FPC - Gitlab</li> <li>Lazarus IDE - Gitlab</li> </ul>"},{"location":"community/#twitter-channels","title":"Twitter Channels","text":"<ul> <li>Lazarus Dev</li> <li>Free Pascal Dev</li> <li>Pascal Congress</li> </ul>"},{"location":"community/#conferences-and-events","title":"Conferences and Events","text":"<ul> <li>Conferences and Events from Free pascal wiki site</li> <li>International Pascal Congress</li> </ul>"},{"location":"docs/advanced/conditional-compilation/","title":"Conditional Compilation","text":""},{"location":"docs/advanced/conditional-compilation/#how-can-i-compile-conditionally","title":"How can I compile conditionally?","text":""},{"location":"docs/advanced/conditional-compilation/#use-ifdef","title":"Use <code>{$IFDEF}</code>","text":"<p>You can use <code>$DEFINE</code> to define a symbol to compile your program conditionally.</p> <p>For example.</p> <pre><code>{$DEFINE name}\n</code></pre> <p>Then, use <code>$IFDEF name</code> to start the conditional compilation. Use <code>$ENDIF some ignored comments</code> to end the conditonal compilation.</p> <pre><code> {$IFDEF name}\n\n // More code ...\n\n {$ENDIF name}\n</code></pre> <p>You can combine multiple <code>{$IFDEF}</code>s too. See the following example (taken from [https://wiki.freepascal.org/\\(IF](https://wiki.freepascal.org/\\)IF)).</p> <pre><code>//Before you need write these conditions to check some conditions:\n{$DEFINE SOMETHING}\n{$DEFINE SOMETHINGELSE}\n{$IFDEF SOMETHING} //Combine $IFDEF to check multiple conditions\n  {$IFDEF SOMETHINGELSE}\n    {$ModeSwitch advancedrecords}\n  {$ENDIF}\n{$ENDIF}\n</code></pre>"},{"location":"docs/advanced/conditional-compilation/#use-if","title":"Use <code>{$IF}</code>","text":"<p><code>{$IF}</code> allows you to write complex conditions that cannot be done using <code>{$ifdef aname}</code>.</p> <p>See the following example from https://wiki.freepascal.org/$IF. You can see two local directives (<code>$DEFINE</code> and <code>$UNDEF</code>) along with <code>and</code> and <code>or</code> logic operators in it.</p> <pre><code>{$IF defined(SOMETHING) and defined(SOMETHINGELSE)}//simple and readabl instead of union {$IFDef}`s\n  {$ModeSwitch advancedrecords}\n{$ENDIF} \n\n{$IF defined(somthing) or defined(somethingelse)}\n  //Whatever you need!\n{$ENDIF}\n\n{$IF undefined(what) and defined(somethingelse)}\n  //Just for note, Another usage!\n{$ENDIF}\n</code></pre> <p>References</p> <ul> <li>Lazarus - Easy trick on how to use {$IFDEF DEBUG} for simple debugging by Hans Luijten on Tweaking4All.</li> <li>Conditional Compilation <code>{$IFDEF}</code> - Free Pascal Wiki</li> <li>Conditional Compilation with <code>{$IF}</code> - Free Pascal Wiki</li> </ul>"},{"location":"docs/advanced/conditional-compilation/#useful-symbols-for-conditional-compilation","title":"Useful symbols for conditional compilation","text":"<p>Here is an example contributed by \ud835\udcda\ud835\udcf8\ud835\udced\ud835\udcee\ud835\udce9\ud835\udd00\ud835\udcee\ud835\udcfb\ud835\udcf0 \ud83c\udde9\ud83c\uddea (Unofficial Free Pascal Discord).</p> <pre><code>{$IF Defined(DCC) or Defined(VER210) or Defined(VER200) or Defined(VER190) or Defined(VER185) or Defined(VER180) or Defined(VER170) or Defined(VER160) or Defined(VER150) or Defined(VER140) or Defined(VER130) or Defined(VER120) or Defined(VER100) or Defined(VER90) or Defined(VER80)}\n  {$DEFINE Delphi} { Delphi }\n{$IFEND}\n\n{$IF Defined(DELPHI) and Declared(CompilerVersion) and (CompilerVersion &gt;= 25)}\n  {$LEGACYIFEND ON}\n{$IFEND}\n\n{$IF Defined(FPC)}\n  {$DEFINE Lazarus} { Lazarus and Free Pascal }\n{$IFEND}\n\n{$IF Defined(DELPHI) and Declared(CompilerVersion) and (CompilerVersion &gt;= 23)}\n  {$DEFINE NameSpace} { Delphis NameSpace feature (eg Winapi.Windows instead of Windows) }\n{$IFEND}\n\n{$IF Defined(DELPHI) and Declared(CompilerVersion) and (CompilerVersion &gt;= 20)}\n  {$DEFINE UniCode} { Delphis UniCode support }\n{$IFEND}\n\n{$IF Defined(WIN32) or Defined(WIN64) or Defined(MSWindows)}\n  {$DEFINE Windows} { We are on Windows }\n{$IFEND Windows}\n\n{$IF Defined(FPC) and Declared(FPC_VERSION) and (FPC_VERSION &gt;= 3)}\n  {$DEFINE UniCode} { FreePascal UniCode support }\n{$IFEND}\n</code></pre> <p>And here's an example of how you might use these symbols.</p> <pre><code>begin\n{$IFDEF Delphi}\n    // Specific code for Delphi mode\n{$ENDIF}\n\n{$IFDEF Lazarus}\n    // Specific code for Lazarus and Free Pascal\n{$ENDIF}\n\n{$IFDEF Namespace}\n    // Specific code for Delphi's namespace\n{$ENDIF}\n\n{$IFDEF Windows}\n    // Specific code for Windows\n{$ENDIF}\n\n{$IFDEF UniCode}\n    // Code relies on Unicode\n{$ENDIF}\nend.\n</code></pre>"},{"location":"docs/advanced/debugging/","title":"Debugging","text":"<p>Important</p> <p>The official docs by Micha\u00ebl Van Canneyt and Florian Kl\u00e4mpfl on debugging; Debugging your Program.</p>"},{"location":"docs/advanced/debugging/#setup-debug-and-release-build-profiles","title":"Setup Debug and Release build profiles","text":""},{"location":"docs/advanced/debugging/#using-the-default-configuration","title":"Using the default configuration","text":"<ol> <li>Open a new project in Lazarus IDE</li> <li>Go to Project | Options | Compiler Options</li> <li>In the Build modes (by default says default) click the <code>...</code> button.</li> <li>In the Build Mode window, click Create Debug and Release modes button.</li> </ol> <p>Once you've done that, you will see two new profiles; <code>Debug</code> and <code>Release</code>.</p> <p>Important</p> <p>Use the <code>Debug</code> profile for debugging and detecting heap memory leaks.</p> <p>Use <code>Release</code> for production.</p>"},{"location":"docs/advanced/debugging/#create-additional-build-profiles","title":"Create additional build profiles","text":"<p>See this page; https://wiki.lazarus.freepascal.org/IDE_Window:__Compiler_Options#Build_modes</p>"},{"location":"docs/advanced/debugging/#where-are-the-debug-switches","title":"Where are the debug switches?","text":"<ol> <li>Press Ctrl+Shift+F11 to open Project Options window.</li> <li>Choosing Debugging from the left hand side menu will reveal more switches as shown below.</li> </ol>"},{"location":"docs/advanced/debugging/#what-if-i-run-without-setting-up-debug-and-release-build-profiles","title":"What if I run without setting up Debug and Release build profiles?","text":"<p>When you run a code first time using the default build mode, you will see the following dialogue box.</p> <p></p> <p>Hit the Ok button for now, but remember to setup your build profiles later.</p>"},{"location":"docs/advanced/ezthreads/","title":"ezthreads","text":"<p>A simple and safe way to work with threads.</p> <p>-Highball</p> <p>Code repo: https://github.com/mr-highball/ezthreads.</p>"},{"location":"docs/advanced/ezthreads/#features","title":"Features","text":"<ul> <li>argument capturing by using the <code>.AddArg()</code> method</li> <li>reference counted threads ensuring memory is cleaned up</li> <li><code>Await()</code> support method (similar to c#) can wait for threads, groups, all threads, pools to complete</li> <li>ez thread pool for fixed worker size and easy to use fluent methods</li> <li>works with nested, callbacks, object methods (or all at the same time)</li> <li>events for start, stop, error, success, etc... for flexibility</li> </ul>"},{"location":"docs/advanced/ezthreads/#setup","title":"Setup","text":"<ol> <li>Make sure you have FPC and/or Lazarus installed.</li> <li> <p>Get the library. You have two choices here.</p> <ul> <li>Download the source code and unzip on your local drive, or </li> <li><code>git clone</code> the repo on your local drive.</li> </ul> </li> <li> <p>Include the library's <code>src/</code> in your project path.</p> </li> <li>(Optional but highly recommended) Thank the author of ezthreads.</li> </ol>"},{"location":"docs/advanced/ezthreads/#examples","title":"Examples","text":"<p>Info</p> <p>Prior running ezthreads snippets on this page, make sure two important things.</p> <ol> <li>You've downloaded the source code from https://github.com/mr-highball/ezthreads</li> <li>Your Free Pascal/Lazarus project includes <code>src/*.pas</code> files of the ezthreads.</li> </ol>"},{"location":"docs/advanced/ezthreads/#tasks-on-threads","title":"Tasks on Threads","text":"<pre><code>program ezthreadsSimple;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads, // Include units for threading support on UNIX systems\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  ezthreads;\n\n  // Method to be executed by Thread A\n  procedure MethodA(const AThread: IEZThread);\n  begin\n    // Simulate some important work in Thread A\n    WriteLn('TestThread::ThreadA starting');\n    Sleep(1000); // Simulate work with a 1-seconds delay\n    WriteLn('TestThread::ThreadA finished');\n  end;\n\n  // Method to be executed by Thread B\n  procedure MethodB(const AThread: IEZThread);\n  begin\n    // Simulate some important work in Thread B\n    WriteLn('TestThread::ThreadB starting');\n    Sleep(1000); // Simulate work with a 1-second delay\n    WriteLn('TestThread::ThreadB finished');\n  end;\n\nvar\n  LThreadA, LThreadB: IEZThread; // Declare thread variables\n\n  // Main block\nbegin\n  // Initialize both threads\n  LThreadA := NewEZThread;\n  LThreadB := NewEZThread;\n\n  // Setup and start Thread A\n  LThreadA\n    .Setup(@MethodA) // Assign MethodA to Thread A\n    .Start;          // Start Thread A\n\n  // Setup Thread B to wait for Thread A to finish before starting its task\n  LThreadB\n    .Setup(@MethodB) // Assign MethodB to Thread B\n    .Start;          // Start Thread B\n\n  // Wait for all threads to complete\n  Await;\n\n  // Wait for user input to keep the console window open\n  WriteLn('Press Enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/ezthreads/#thread-dependency","title":"Thread Dependency","text":"<pre><code>program ezthreadsDependency;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch nestedprocvars}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads, // Include units for threading support on UNIX systems\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  ezthreads;\n\n{\n  This example demonstrates a scenario where one thread (B) depends\n  on another thread (A) to finish before it can proceed. The main thread\n  waits for both threads (A) and (B) to complete using the await mechanism.\n}\n  procedure TestThreadDependency;\n  var\n    LThreadA, LThreadB: IEZThread; // Declare thread variables\n\n  // Method to be executed by Thread A\n    procedure MethodA(const AThread: IEZThread);\n    begin\n      // Simulate some important work in Thread A\n      WriteLn('TestThreadDependency::ThreadA starting');\n      Sleep(1000); // Simulate work with a 1-second delay\n      WriteLn('TestThreadDependency::ThreadA finished');\n    end;\n\n    // Method to be executed by Thread B\n    procedure MethodB(const AThread: IEZThread);\n    var\n      LID: string;\n    begin\n      LID := AThread['id']; // Retrieve the ID of Thread A\n\n      // Indicate that Thread B is starting\n      WriteLn('TestThreadDependency::ThreadB starting');\n\n      // Wait until Thread A has completed its execution\n      Await(LID);\n\n      // Indicate that Thread B has finished\n      WriteLn('TestThreadDependency::ThreadB finished');\n    end;\n\n  begin\n    // Initialize both threads\n    LThreadA := NewEZThread;\n    LThreadB := NewEZThread;\n\n    // Setup and start Thread A\n    LThreadA\n      .Setup(@MethodA) // Assign MethodA to Thread A\n      .Start;          // Start Thread A\n\n    // Setup Thread B to wait for Thread A to finish before starting its task\n    LThreadB\n      .AddArg('id', LThreadA.Settings.Await.GroupID) // Pass the GroupID of Thread A to Thread B\n      .Setup(@MethodB) // Assign MethodB to Thread B\n      .Start;          // Start Thread B\n\n    // Wait for all threads to complete\n    Await;\n  end;\n\n  // Main block\nbegin\n  // Execute the thread dependency test\n  TestThreadDependency;\n  // Wait for user input to keep the console window open\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/ezthreads/#thread-pool","title":"Thread Pool","text":"<pre><code>program ezthreadsPool;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch nestedprocvars}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads, // Include units for threading support on UNIX systems\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  ezthreads, ezthreads.pool; // Include units for thread pool support\n\n// A procedure to test two tasks running in parallel using a thread pool\nprocedure TestTwoTasks;\nvar\n  LPool: IEZThreadPool;\n  LJobOneFinished, LJobTwoFinished: boolean; // Flags to indicate if the jobs are finished\n\n  // A simple parallel job (JobOne)\n  procedure JobOne(const AThread: IEZThread);\n  begin\n    // Simulate some work with a sleep of 100 ms\n    Sleep(100);\n    // Mark the job as finished\n    LJobOneFinished := True;\n  end;\n\n  // Another simple parallel job (JobTwo)\n  procedure JobTwo(const AThread: IEZThread);\n  begin\n    // Simulate some work with a sleep of 100 ms\n    Sleep(100);\n    // Mark the job as finished\n    LJobTwoFinished := True;\n  end;\n\nbegin\n  // Initialise flags for checking if both jobs finished\n  LJobOneFinished := False;\n  LJobTwoFinished := False;\n\n  // Initialise a pool with two worker threads\n  LPool := NewEZThreadPool(2);\n\n  // Queue two jobs to the pool\n  LPool\n    .Queue(@JobOne, nil, nil) // Queue JobOne to the pool\n    .Queue(@JobTwo, nil, nil) // Queue JobTwo to the pool\n    .Start; // Start the pool, which begins executing the jobs\n\n  // Wait until both jobs finish\n  Await(LPool);\n\n  // Write the status to the console\n  WriteLn(Format('TestTwoTasks::[success]:%s',\n                 [BoolToStr(LJobOneFinished and LJobTwoFinished, True)]));\nend;\n\n// Main block\nbegin\n  // Run the demo procedure that tests two tasks in parallel\n  TestTwoTasks;\n\n  // Wait for user input to keep the console window open\n  WriteLn('Press Enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/find-heap-memory-leaks/","title":"Finding heap memory leaks","text":"<p>Consider using the pre-defined Debug mode from Create Debug and Release profiles in Lazarus before customising your own debugging environment.</p> <p>Official docs on Heaptrc</p> <ul> <li>HeapTrc Usage</li> <li>RTL - <code>heaptrc</code></li> <li>RTL - <code>SetHeapTraceOutput</code></li> <li>Controlling HeapTrc with environment variables</li> <li>Wiki - Using Heaptrc in FPC</li> <li>Wiki - Using LeakView in Lazarus</li> </ul>"},{"location":"docs/advanced/find-heap-memory-leaks/#1-enable-the-default-debug-mode","title":"1. Enable the default Debug mode","text":"<p>Once you've created the default Debug and Release profiles in Lazarus, switch to Debug Mode to see heap memopry leaks.</p> <p>Steps:</p> <ul> <li>Press Ctrl+Shift+F11 to open the Project Options window.</li> <li>Go to Compilation and Linking.</li> <li>Set Build modes to Debug.</li> <li>Re-compile your program.</li> </ul>"},{"location":"docs/advanced/find-heap-memory-leaks/#2-or-manually-enable-heaptrc","title":"2. Or manually enable <code>HeapTrc</code>.","text":"<p>First, go to <code>Project | Project Options ...</code> </p> <p>In the Options window find <code>Compiler Options | Debugging</code>, then enable the following switches.</p> <ul> <li>[Mandatory] <code>Use Heaptrc unit (check for mem-leaks) (-gh)</code></li> <li>[Optional] <code>Display line numbers in run-time errors backtraces (-gl)</code></li> </ul> <p>Click the image below to expand the view.</p> <p></p>"},{"location":"docs/advanced/find-heap-memory-leaks/#3-optional-save-leaks-report-to-a-file","title":"3. (Optional) Save leaks report to a file","text":"<p>Use <code>SetHeapTraceOutput</code> to redirect heap trace report to a file.</p>"},{"location":"docs/advanced/find-heap-memory-leaks/#4-example-redirect-leaks-report-to-a-file","title":"4. Example - Redirect leaks report to a file","text":"<ol> <li>Enable Debug mode for compilation.</li> <li> <p>Define a <code>DEBUG</code> symbol. We contain the heap trace report only for debug builds. Line 7.</p> <ul> <li>FYI, the <code>{$DEFINE}</code> directive has a command-line equivalent, <code>-d</code>.  For example, <code>-dNAME</code></li> </ul> </li> <li> <p>Create a conditional compilation block for <code>DEBUG</code> builds, <code>{$IFDEF DEBUG}...{$ENDIF DEBUG}</code>, for redirecting heap trace to a file. Line 23-31.</p> <ul> <li>Remove existing heap trace file. Line 28, 29.</li> <li>Set a file for reporting heap memory leaks. Line 30.</li> </ul> </li> </ol> <pre><code>program HeapMemoryLeakLazarus;\n\n{$mode objfpc}{$H+}{$J-}\n\n// Define a symbol name DEBUG.\n// With this compiler directives we can compile parts of code associated with this symbol.\n{$DEFINE DEBUG}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  stringList: TStringList;\n  i: integer;\n\n  // MAIN block\nbegin\n\n  {$IFDEF DEBUG}\n  // This block assumes your build mode sets -dDEBUG in `Project Options` or other means when defining -gh.\n  // For production build, remove -dDEBUG in `Project Options` or other means and disable -gh.\n\n  // Setup Heaptrc output for the Leak and Traces window in Lazarus.\n  if FileExists('heap.trc') then\n    DeleteFile('heap.trc');\n  SetHeapTraceOutput('heap.trc');\n  {$ENDIF DEBUG}\n\n  // Create a string list\n  stringList := TStringList.Create;\n\n  try\n    // Adding items\n    WriteLn('Adding items');\n    WriteLn('--------------------');\n    for i := 0 to 4 do\n      stringList.Add('Counting ' + IntToStr(i));\n\n    // Printing contents\n    for i:=0 to stringList.Count - 1 do\n      WriteLn(stringList[i]);\n\n  finally\n    // If you don't free, the -gh will give report of memory leaks\n    // If Leak and Traces window is set to a heap trace file, this will appear in the Leak and Traces windoww.\n    // Otherwise, Heaptrc will print heap memory reports on CLI.\n    // stringList.Free;\n  end;\n\n  // Pause Console\n  WriteLn('Press Enter key to quit.');\n  ReadLn;\nend.\n</code></pre> <p>The program prints the following on the screen.</p> <pre><code>$ ./HeapMemoryLeak.exe\nAdding items\n--------------------\nCounting 0\nCounting 1\nCounting 2\nCounting 3\n$\n</code></pre> <p>You will get a heap trace report file containing a report similar to the one below; showing 6 unfreed memory blocks - 348 bytes. </p> <pre><code>$ cat heap.trc\n/a-long-path/HeapMemoryLeak.exe\nHeap dump by heaptrc unit of /a-long-path/HeapMemoryLeak.exe\n134 memory blocks allocated : 5089/5480\n128 memory blocks freed     : 4741/5112\n6 unfreed memory blocks : 348\nTrue heap size : 229376 (192 used in System startup)\nTrue free heap : 227520\nShould be : 227664\nCall trace for block $00000000000B12C0 size 35\n  $000000010000BA32\n  $00000001000051C3\n  $00000001000060AB\n  $00000001000055ED\n  $000000010000197F  $main,  line 41 of HeapMemoryLeak.lpr\n  $0000000100001B16  $main,  line 53 of HeapMemoryLeak.lpr\n  $00000001000111C0\n  $00000001000017A0\n  $00007FFA4CC0257D\n  $00007FFA4DF6AF28\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\nCall trace for block $00000000000B11C0 size 35\n  $000000010000BA32\n  $00000001000051C3\n  $00000001000060AB\n  $00000001000055ED\n  $000000010000197F  $main,  line 41 of HeapMemoryLeak.lpr\n  $0000000100001B16  $main,  line 53 of HeapMemoryLeak.lpr\n  $00000001000111C0\n  $00000001000017A0\n  $00007FFA4CC0257D\n  $00007FFA4DF6AF28\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\nCall trace for block $00000000000B10C0 size 35\n  $000000010000BA32\n  $00000001000051C3\n  $00000001000060AB\n  $00000001000055ED\n  $000000010000197F  $main,  line 41 of HeapMemoryLeak.lpr\n  $0000000100001B16  $main,  line 53 of HeapMemoryLeak.lpr\n  $00000001000111C0\n  $00000001000017A0\n  $00007FFA4CC0257D\n  $00007FFA4DF6AF28\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\nCall trace for block $00000000000B5BB0 size 64\n  $000000010000BA32\n  $000000010001C18E\n  $000000010001BBEC\n  $000000010001BEC4\n  $000000010001BE84\n  $000000010001C456\n  $00000001000019BA\n  $0000000100001B16  $main,  line 53 of HeapMemoryLeak.lpr\n  $00000001000111C0\n  $00000001000017A0\n  $00007FFA4CC0257D\n  $00007FFA4DF6AF28\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\nCall trace for block $00000000000B0FC0 size 35\n  $000000010000BA32\n  $00000001000051C3\n  $00000001000060AB\n  $00000001000055ED\n  $000000010000197F  $main,  line 41 of HeapMemoryLeak.lpr\n  $0000000100001B16  $main,  line 53 of HeapMemoryLeak.lpr\n  $00000001000111C0\n  $00000001000017A0\n  $00007FFA4CC0257D\n  $00007FFA4DF6AF28\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\nCall trace for block $00000000000D5910 size 144\n  $000000010000BA32\n  $00000001000090BA\n  $000000010001C2F5\n  $000000010000188D\n  $0000000100001B16  $main,  line 53 of HeapMemoryLeak.lpr\n  $00000001000111C0\n  $00000001000017A0\n  $00007FFA4CC0257D\n  $00007FFA4DF6AF28\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n  $BAADF00DBAADF00D\n</code></pre>"},{"location":"docs/advanced/find-heap-memory-leaks/#5-optional-view-leaks-traces-in-lazarus-ide","title":"5. (Optional) View Leaks &amp; Traces in Lazarus IDE","text":"<ol> <li>Click <code>View</code> form the top menu bar of Lazarus IDE.</li> <li>Select <code>Leaks and Traces</code></li> <li>Set the <code>.trc</code> file to read by pressing the <code>...</code> (elipsis) button.</li> <li>Click the Update button to reload latest changes to the <code>.trc</code> file.</li> </ol> <p>Click the image below to expand the view.</p> <p></p> <p>Now, whenever you run the program in DEBUG mode from Lazarus IDE, simply press the Update button on the Leaks and Traces window to see the latest heap memory report.</p> <p>If there is any leaks in the program, pressing the Update button will show leaking memory size, leaking blocks counts and the details of leaking blocks.</p> <p>Click the image below to expand the view.</p> <p></p>"},{"location":"docs/advanced/fpc-switches/","title":"FPC Switches","text":""},{"location":"docs/advanced/fpc-switches/#fpc-switches","title":"FPC Switches","text":"<p>The following Markdoien table was converted from the official Reference chart with all compiler options and switches.</p>"},{"location":"docs/advanced/fpc-switches/#local-compiler-switches","title":"Local compiler switches","text":"Cmd Short Long Explanation $A $ALIGN Align Data. A $ASMMODE Select assembler mode. $B $BOOLEVAL Use complete boolean evaluation. Sa $C $ASSERTIONS Enable assertion support. $CALLING Set default calling convention d $DEFINE Define a symbol. $ELSE Switch conditional compilation. $ENDIF End conditional compilation. $ERROR Generate error message. $F Use far or near functions. $FATAL Generate fatal error message. Sg $GOTO SupportGoto andLabel. $H $LONGSTRINGS Use AnsiStrings. $HINT Generate hint message. vh $HINTS Emit hints $IF Start conditional compilation. $IFDEF Start conditional compilation. $IFNDEF Start conditional compilation. $IFOPT Start conditional compilation. $INFO Generate info message. Si $INLINE Enable inline code support. Ci $I $IOCHECKS Include Input/Output checking. $I $INCLUDE Include file. $I $INCLUDE Include compiler info. $L $LINK Link object file. $LINKLIB Link to a library. $M $TYPEINFO Generate Run-Time type information. Sm $MACRO Enable macro support. $MAXFPUREGISTER set maximum number of FPU registers $MESSAGE Generate info message. $MMX Enable Intel MMX support. $NOTE Generate note message. vn $NOTES Emit notes. A $OUTPUTFORMAT Select compiler output format. $P $OPENSTRINGS Use open strings. $PACKENUM Specify minimum enumeration type size. $PACKRECORDS Specify Alignment of record elements. Co $Q $OVERFLOWCHECKS Use overflow checking. Cr $R $RANGECHECKS Use range checking. $SATURATION Enable saturation operations. XX $SMARTLINK Use smartlinking. St $STATIC Enable use ofStatic keyword. $STOP Generate fatal error message. $T $TYPEDADDRESS Enable typed address operator. u $UNDEF Undefine a symbol. $V $VARSTRINGCHECKS Use strict var-string checking. $WAIT Wait for enter key press. $WARNING Generate warning message. $WARNINGS Emit warnings. $X $EXTENDEDSYNTAX Enable use of extended syntax."},{"location":"docs/advanced/fpc-switches/#global-compiler-switches","title":"Global compiler switches","text":"Cmd Short Long Explanation $APPID Set application ID (PalmOS) $APPNAME Set application name (PalmOS) $APPTYPE Specify type of application (Windows only) g $D $DEBUGINFO Include debugging symbols. $DESCRIPTION Not supported. $E Enable emulation of coprocessor. $G Generate 80286 code. Fi $INCLUDEPATH Specify include file search path. $L $LOCALSYMBOLS Enable local symbol information. Fl $LIBRARYPATH Specify library search path. $M $MEMORY Specify memory sizes. M $MODE Specify compiler compatibility mode. $N Enable numeric processing. $O Enable overlay code generation. Fo $OBJECTPATH Specify object file search path. Ct $S Use stack checking Fu $UNITPATH Specify unit file search path. $VERSION Set DLL version (Windows) $W $STACKFRAMES Generate stackframes. b $Y $REFERENCEINFO Insert browser information."},{"location":"docs/advanced/lmath/","title":"Math with LMath","text":"<p>Credit</p> <p>Huge thanks to Jean Debord for the work in Dmath and also to Viatcheslav Nesterov (Glorfin) for the contributions to the LMath, both invaluable resources for Free Pascal and Lazarus users.</p> <p>Info</p> <p>The content of this page is adapted from the official document of LMath on Sourceforge.</p>"},{"location":"docs/advanced/lmath/#introduction","title":"Introduction","text":"<p>LMath, further development of DMath library from Jean Debord, is a general purpose mathematical library for FreePascal (FPC) and Lazarus. LMath provides routines and demo programs for numerical analysis, including mathematical functions, probabilities, matrices, optimization, linear and nonlinear equations, integration, Fast Fourier Transform, random numbers, curve fitting, statistics and graphics. It is organized as a set of lazarus packages. Such organization makes it easily extensible and helps to include only really needed features in your project. </p> <p>DMath stands for Delphi Math, and is a continuation of an earlier work which was named TPMath, for Turbo Pascal Math. Continuing this tradition, this this library is called LMath: Lazarus Math.</p> <p>Source: LMath 0.6 Official Doc.</p> <p>Check the official document for what is new in LMath compared to DMath.</p> <p>License: LGPL 3.0</p>"},{"location":"docs/advanced/lmath/#what-does-it-offer","title":"What does it offer?","text":"<p>LMath has 13 relatively small packages:</p> <ol> <li><code>lmGenMath</code>. This package defines several important data structures, used later in the whole library, some utility functions, basic math functions and special functions. All other packages of the library depend on <code>lmGenMath</code>.</li> <li><code>lmMathUtil</code>. Various function for manipulations with arrays, sorting and formatting. Depends on <code>lmGenMath</code>.</li> <li><code>lmLinearAlgebra</code>. Operations over vectors and matrices. Depends on <code>lmMathUtil</code> and <code>lmGenMath</code>.</li> <li><code>lmPolynoms</code>. Evaluation of polynomials, polynomial roots finding, polynomial critical points finding. Depends on <code>lmGenMath</code> and <code>lmLinearAlgebra</code>.</li> <li><code>lmIntegrals</code>. Numeric integrating and solving differential equations. Depends on <code>lmGenMath</code>.</li> <li><code>lmRandoms</code>. Generation of random numbers. Depends on <code>lmGenMath</code>.</li> <li><code>lmMathStat</code> Descriptive statistics, hypothesis testing, collection of various distributions. Depends on <code>lmGenMath</code> and <code>lmLinearAlgebra</code>.</li> <li><code>lmOptimum</code>. Algorithms of function minimization. Somewhat artificially, unit <code>uEval</code> for evaluation of an expression, is included into this package. Depends on <code>lmGenMath</code>, <code>lmLinearAlgebra</code>, <code>lmRandoms</code>, <code>lmMathStat</code>.</li> <li><code>lmNonLinEq</code>. Finding of roots of non-linear equations. Depends on <code>lmGenMath</code>, <code>lmLinearAlgebra</code>, <code>lmOptimum</code>.</li> <li><code>lmDSP</code>. Functions for digital signal processing. Collection of filters and Fourier Transform procedures.</li> <li><code>lmRegression</code>. Functions for linear and non-linear regression, curve fitting. Collection of common models. Unit <code>uFFT</code> for fast Fourier Transform is located also here. Depends on <code>lmLinearAlgebra</code>, <code>lmPolynoms</code>, <code>lmOptimum</code>, <code>lmMathUtil</code>.</li> <li><code>lmSpecRegress</code>. Collection of field-specific models for data fitting. Depends on <code>lmGenMath</code> and <code>lmRegression</code>.</li> <li><code>lmPlotter</code>. Routines for data and functions plotting. Depends on <code>lmGenMath</code>, <code>lmMathUtil</code> and <code>LCL</code>.</li> </ol>"},{"location":"docs/advanced/lmath/#installation-compilation-and-use-of-the-library","title":"Installation, Compilation and use of the library","text":""},{"location":"docs/advanced/lmath/#option-1-download-unpack-and-compile","title":"Option #1: Download, unpack and compile","text":"<ol> <li>Download and unpack file <code>LMath and Components06.zip</code>. </li> <li>Open and compile packages in this order; <code>lmGenMath</code>, <code>lmMathUtil</code>, <code>lmLinearAlgebra</code>, <code>lmPolynoms</code>, <code>lmIntegrals</code>, <code>lmRandoms</code>, <code>lmMathStat</code>, <code>lmOptimum</code>, <code>lmNonLinEq</code>, <code>lmRegression</code>, <code>lmSpecRegress</code>, <code>lmDSP</code>, <code>lmPlotter</code>. </li> <li>After it you may compile <code>LMath.pkg</code>, which simply depends on all these packages. Therefore, if you add dependency on LMath to your project, it is not necessary to add every single package.</li> </ol>"},{"location":"docs/advanced/lmath/#option-2-download-use-the-project-group-package","title":"Option #2: Download, use the Project Group package","text":"<p>Alternatively, if you have <code>Project Groups</code> package installed in your Lazarus IDE, you can open and compile LMath project group, select LMath target and compile it.</p>"},{"location":"docs/advanced/lmath/#lmcomponents","title":"LMComponents","text":"<p>If you are going to use <code>LMComponents</code>, open <code>LMComponents</code> package, compile and install it.</p> <p><code>LMComponents</code> is an object-oriented extension of <code>LMath</code>. It contains <code>TCoordSys</code> component which serves for graphical representation of functions or data, several dialogs and input controls, as well as DSP filters implemented as components.</p>"},{"location":"docs/advanced/lmath/#note-on-compilation","title":"Note on Compilation","text":"<p>For the sake of maximally broad compatibility, rather conservative optimization options are selected in LMath packages (optimization level 2, no options for modern processors selected). Depending on your system, you may want to increase this level and use options for modern processors. </p> <p>For example, you may want to define the following to effectively use AVX2 registers.</p> <pre><code>-CfAVX2\n-CpCOREAVX2\n-OoFASTMATH\n-OoLOOPUNROLL\n</code></pre> <p>Do not generate debug information is selected by default in the options of LMath packages. If you want to step into LMath procedures debugging your programs, change it. If you find a bug in LMath, please, report it at the official site at Sourseforge.</p>"},{"location":"docs/advanced/lmath/#examples","title":"Examples","text":"<p>Coming soon.</p>"},{"location":"docs/advanced/multi-threading-basics/","title":"Multi-threading - Do you need it?","text":""},{"location":"docs/advanced/multi-threading-basics/#what-is-it","title":"What is it?","text":"<p>Info</p> <p>The information in this section is adapted from the following URL; Multithreaded Application Tutorial, excluding the tutorial.</p> <p>A multi-threaded application can run multiple tasks simultaneously by creating separate threads. The Main Thread manages user interactions, while other threads handle background tasks.</p> <p>This setup improves application responsiveness during intensive operations. Multi-threading is beneficial for running tasks in the background, maintaining user interface responsiveness, and managing multiple client requests in server applications.</p>"},{"location":"docs/advanced/multi-threading-basics/#do-you-need-multi-threading","title":"Do you need multi-threading?","text":"<p>Multi-threading is good for:</p> <ul> <li>Managing blocking handles like network tasks.</li> <li>Using multiple processors at once to process a large dataset.</li> <li>Using multiple processors to process different parts of an image simultaneously, improving efficiency and speed.</li> <li>Etc.</li> </ul> <p>Before using multi-threading to speed up tasks using many processors, make sure of the following items. </p> <ol> <li>Your program is already using all resources well on one CPU core. </li> <li>Check if your program is optimized at the highest level (level 3) for the best performance, as higher optimization can make your program faster.</li> </ol>"},{"location":"docs/advanced/multi-threading-basics/#multi-threaded-apps-are-complex-and-harder-to-debug","title":"Multi-threaded apps are complex and harder to debug","text":"<p>For simpler tasks, one thread may be enough. </p> <p>Instead of many threads, you can split long tasks into smaller parts or use <code>Application.ProcessMessages</code> to handle user actions during long tasks.</p> <p>Info</p> <p>What is <code>Application.ProcessMessages</code>?</p> <p><code>Application.ProcessMessages</code> signals that the app can execute events from its event queue. Let's say that you have 2 buttons on a form with to <code>onclick</code> procedures assigned. The first procedure is a lengthly process (eg. <code>repeat..until true</code>). The second button has only <code>ShowMessage('haha')</code>.</p> <p>Now, without <code>Appllication.ProcessMessages</code> inserted in the first procedure in the repeat statement, if you press the first button then you will not be able to press the seccond button (or anything else) until the repeat statement finishes. So the user interface is frozen.</p> <p>With the <code>application.processmessages</code> inserted as follows</p> <pre><code>repeat\n  Application.ProcessMessages;\n  ...\nuntil true;\n</code></pre> <p>If you press the first button and then the second button the <code>ShowMessage</code> will happen! So, it is a way to fake a multithread app :-))</p> <p>Source: Lazarus: The effect of Application.ProcessMessages</p>"},{"location":"docs/advanced/multi-threading-basics/#units-needed-for-a-multi-threaded-application","title":"Units needed for a multi-threaded application","text":""},{"location":"docs/advanced/multi-threading-basics/#windows","title":"Windows","text":"<p>You don\u00b4t need any special unit for this to work with Windows. </p>"},{"location":"docs/advanced/multi-threading-basics/#linux-macos-freebsd","title":"Linux macOS FreeBSD","text":"<p>With Linux, macOS and FreeBSD, you need the <code>cthreads</code> unit and it must be the first used unit of the project (the program source, usually the <code>.lpr</code> file)! </p> <p>In cases where you need  units like <code>cmem</code>, <code>cthreads</code>, and <code>cwstrings</code>; </p> <ol> <li>Place them first in the <code>uses</code> section, </li> <li>Due to how these units work, a sensible order is <code>cmem</code>, <code>cthreads</code> and <code>cwstrings</code>.</li> </ol> <p>So, your FPC/Lazarus application code should begin as the following snippet.</p> <pre><code>program AMultiThreadedProgram;\n\n{$mode objfpc}{$H+}{$J-}\nuses\n{$ifdef unix}\n  cmem, // the c memory manager is faster for multi-threading\n        // on some systems\n  cthreads,\n{$endif}\n  { you can add units here };\n\n  // ... the rest of your code\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/","title":"Multi-threading with <code>TThread</code> Part I","text":""},{"location":"docs/advanced/multi-threading-tthread-i-intro/#tthread-class","title":"<code>TThread</code> Class","text":"<p>Creating a multi-threaded application is easier using the <code>TThread</code> class. This class lets you add another thread (in addition to the main thread) easily. Usually, you only need to override two methods: the <code>constructor Create()</code> and the <code>Execute</code> method.</p> <p>By using <code>TThread</code>, you can create and manage multiple threads in your application, making it more efficient and responsive.</p>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li> <p>Declare a descendant of the <code>TThread</code> object. </p> </li> <li> <p>Override the <code>constructor Create();</code></p> <ul> <li>This is where you set up the thread.</li> <li>Initialise variables or properties you need.</li> <li>The constructor has a parameter called <code>CreateSuspended</code>:<ul> <li>If <code>CreateSuspended</code> is set to <code>True</code>, the thread won't start immediately.</li> <li>If <code>CreateSuspended</code> is set to <code>False</code>, the thread will start running right after it's created.</li> <li>If you create the thread with <code>CreateSuspended := True</code>, you need to call the <code>Start</code> method later to run it.</li> </ul> </li> </ul> </li> <li> <p>Override <code>Execute;</code></p> <ul> <li>This is where you write the code that will run in the thread.</li> <li>You can add a loop here to perform repeated actions.</li> </ul> </li> </ol>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#important-features-of-tthread","title":"Important features of TThread","text":""},{"location":"docs/advanced/multi-threading-tthread-i-intro/#property-processorcount-longword","title":"<code>property ProcessorCount: LongWord;</code>","text":"<ul> <li>Returns the number of cores in the system.</li> </ul>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#procedure-terminate","title":"<code>procedure Terminate;</code>","text":"<ul> <li>The <code>Terminate</code> method simply changes the <code>Terminated</code> property to <code>True</code>.</li> <li>It does not in any way attempt to terminate the thread in any other way, this just signals the thread that it should stop executing at the earliest possible moment.</li> </ul> <p>Important</p> <p>When the thread contains a loop (which is common), the loop should end when <code>Terminated</code> becomes <code>True</code> (by default, it is <code>False</code>). During each iteration, check the value of <code>Terminated</code>, and if it is <code>True</code>, exit the loop promptly after any required cleanup.</p>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#property-freeonterminate-boolean","title":"<code>property FreeOnTerminate: Boolean;</code>","text":"<ul> <li>If <code>FreeOnTerminate</code> is <code>True</code>, the thread object is automatically freed when the <code>Execute</code> method finishes. This is useful for avoiding memory leaks and simplifying memory management in certain scenarios.</li> <li>If <code>FreeOnTerminate</code> is <code>False</code>, you need to free the thread object manually.</li> <li>Use the OnTerminate property to get a notification of when the thread has terminated and will be freed.</li> </ul> <p>Tip</p> <p>When setting <code>FreeOnTerminate</code> property to <code>True</code>, in general you may not read or write any property of the <code>TThread</code> instance from a different thread, because there is no guarantee that the thread instance still exists in memory. </p> <p>This implies 2 things:</p> <ol> <li>The <code>OnTerminate</code> event handler should be set before setting <code>FreeOnTerminate</code> to <code>True</code></li> <li>The properties can still be read and set in the <code>OnTerminate</code> event handler, as the thread instance is then still guaranteed to exist.</li> </ol> <p>Tip</p> <p>If <code>FreeOnTerminate</code> is set to <code>False</code>, to stop and delete a running thread from another thread, the following sample code can be used:</p> <pre><code>aThread.Terminate;\naThread.WaitFor;\nFreeAndNil(aThread); // or aThread.Free;\n</code></pre> <p>Source: https://www.freepascal.org/daily/doc/rtl/classes/tthread.freeonterminate.html</p>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#function-waitfor","title":"<code>function WaitFor;</code>","text":"<ul> <li><code>WaitFor</code> blocks the calling thread until the thread it is called on has finished executing. This is useful for synchronizing the completion of a thread before proceeding with further operations.</li> </ul> <p>Warning</p> <p>The potential conflict arises because if a thread is set to <code>FreeOnTerminate</code>, it will free itself immediately upon completion. If <code>WaitFor</code> is called after the thread has terminated, it will attempt to access a freed (and thus invalid) thread object, leading to undefined behavior or program crashes.</p> <p>Safe Usage Scenarios</p> <ol> <li> <p>Single Thread with <code>FreeOnTerminate</code> and <code>WaitFor</code>:</p> <ul> <li>You can safely use <code>WaitFor</code> with a thread that has <code>FreeOnTerminate</code> set to <code>True</code> if you ensure <code>WaitFor</code> is called before the thread completes and frees itself.</li> </ul> </li> <li> <p>For multiple threads, it's safer to avoid combining <code>FreeOnTerminate</code> set to <code>True</code> with <code>WaitFor</code>. Instead, manage the thread lifecycle manually:</p> <ul> <li>Set <code>FreeOnTerminate</code> to <code>False</code>.</li> <li>Call <code>WaitFor</code> on each thread to ensure it completes.</li> <li>Manually <code>Free</code> the thread objects.</li> </ul> </li> </ol> <p>Contribution</p> <p>Gustavo 'Gus' Carreno \ud83c\uddf5\ud83c\uddf9 \ud83c\uddec\ud83c\udde7 \u2014 2024-05-27 at 15:53</p> <p>You should never use the <code>Terminate</code> property of a <code>TThread</code> outside the thread itself.</p> <p>You should always use <code>WaitFor</code> [to wait for the thread to terminate]!! </p> <pre><code>begin\n  // ...\n  MyThread.Terminate;\n  MyThread.WaitFor;\n  //...\nend;\n</code></pre> <p>Usually, you use <code>Terminated</code> extensively in the <code>Execute</code> method.</p> <p>You kinda have to check it religiously inside <code>Execute</code>, especially if you have a long running and/or blocking thread.</p> <p>But, if I'm not mistaken, the <code>Terminated</code> property is privacy level protected. Hence, you should not use it outside <code>Execute</code>.</p> <p>To terminate a thread you call <code>Terminate</code>. Then if you need to make sure it's done and has cleaned up, you use <code>WaitFor</code>.</p>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#procedure-synchronize","title":"<code>procedure Synchronize();</code>","text":"<ul> <li>Threads should not directly update visible components (like UI elements), so you must use  <code>Synchronize</code> to safely update UI elements from the thread.</li> <li><code>Synchronize</code> ... <ul> <li>pauses the thread, </li> <li>runs a method (like updating a label) in the main thread, </li> <li>and then resumes the thread.</li> </ul> </li> </ul>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#example-run-a-task-on-a-thread-with-a-variable","title":"Example: Run a task on a thread with a variable","text":"<ol> <li>Create a class, for example <code>TMyThread</code>, based on <code>TThread</code>. Line 14-25.</li> <li>Create a constructor. Line 27-40.<ul> <li>call constructor of <code>TThread</code>,</li> <li>set free on terminate and</li> <li>Start thread.</li> </ul> </li> <li>Override <code>Execute</code>. Line 42-52.<ul> <li>This procedure contains your task to perform.</li> </ul> </li> <li>Create a thread in the main block. Line 67.</li> <li>Wait for the thread to finish and return to the main thread. Line 71.</li> <li>Free the thread manually. Line 74.</li> </ol> <pre><code>program EX1SingleThread;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes { you can add units after this };\n\ntype\n  // The TThread class encapsulates the native thread support of the OS.\n  // To create a thread, (1) declare a child of the TThread object, ...\n  TMyThread = class(TThread)\n    // (with a data to work with)\n  private\n    aString: string;\n  protected\n    // (2) override the Execute method, and ...\n    procedure Execute; override;\n  public\n    // (3) lastly, you may include a constructor to setup variables\n    // for executing this thread.\n    constructor Create(isSuspended: boolean; message: string);\n  end;\n\n  constructor TMyThread.Create(isSuspended: boolean; message: string);\n  begin\n\n    // Call parent's constructor\n    // If user pass True, thread won't start automatically\n    inherited Create(isSuspended);\n\n    // Assign a data to work with.\n    self.aString:=message;\n\n    // Won't free the thread when finished.\n    // The thread will be freed manually on the main block.\n    FreeOnTerminate:=False;\n  end;\n\n  procedure TMyThread.Execute;\n  begin\n    // Execute thread, and DO SOMETHING in this thread.\n\n    // Example: if the thread has a data to work with,\n    //          use it to achieve a goal.\n    WriteLn('Thread ID ', ThreadID, ' is printing ', self.aString);\n\n    // Example: simulate a long running process.\n    Sleep(1000);\n  end;\n\nvar\n  mythread:TMyThread;\n\n// Main block --------------------------------------------------\nbegin\n\n// Create a thread, suspended\nmyThread:=TMyThread.Create(True, 'Hello, World!');\n\n// Debug line\nWriteLn('We are in the main thread');\n\n// Start the thread\nmyThread.Start;\n\n// Wait until the thread is done before going back to\n// the main thread.\nmyThread.WaitFor;\n\n// Free threads manually.\nmyThread.Free;\n\n// Debug line.\nWriteLn('We are in the main thread again');\n\n// Pause console.\nWriteLn('Press enter key to quit');\nReadLn;\n\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-i-intro/#example-run-same-tasks-on-multiple-threads","title":"Example: Run same tasks on multiple threads","text":"<p>Contribution</p> <p>2024-02-08 - paweld \ud83c\uddf5\ud83c\uddf1 caught a memory leak in the original code and fixed it.</p> <p>Thank you!</p> <ol> <li>Create a class, for example <code>TTaskThread</code>, based on <code>TThread</code>. Line 40-47.</li> <li>Override <code>Execute</code>. Line 50-57.<ul> <li>This procedure contains your task to perform.</li> </ul> </li> <li>Create a constructor. Line 60-68.<ul> <li>call constructor of <code>TThread</code>,</li> <li>set free on terminate and</li> <li>Start thread.</li> </ul> </li> <li>Create all threads in the main block. Line 56, 57.</li> <li>Wait for all threads to finish and return to the caller or main thread. Line 88, 89.</li> <li>Free threads manually. Line 92, 93.</li> </ol> <pre><code>program EX2MultiThread;\n\n{\n  # EX2MultiThread\n\n  A simple demo of multi-threading.\n\n  ## Example of an output\n\n  ---------------------\n  Started TThread demo\n  ---------------------\n  Starting a task from the main thread\n  Started a task on thread ID 22848\n  Started a task on thread ID 24428\n  Completed the task from the main thread\n  Completed task on thread ID: 22848\n  Completed task on thread ID: 24428\n  ---------------------\n  Finished TThread demo\n  Press Enter to quit\n  ---------------------\n}\n\n\n{$mode objfpc}{$H+}{$J-}\n\n// 2024-02-08 - paweld \ud83c\uddf5\ud83c\uddf1 fixed a memory leak issue on the original code.\n\nuses\n  {$ifdef unix}\n  cmem, cthreads,\n  {$endif}\n  Classes,\n  SysUtils;\n\ntype\n  // Create a class based on TThread\n  // TTaskThread\n  TTaskThread = class(TThread)\n  protected\n    // Override the Execute procedure of TThread\n    procedure Execute; override;\n  public\n    // Thread constructor with free on terminate\n    constructor Create;\n  end;\n\n  // The Execute procedure, simulating a task\n  procedure TTaskThread.Execute;\n  begin\n    WriteLn('Started a task on thread ID ', ThreadID);\n\n    Sleep(2000); // Simulating a long-running task.\n\n    WriteLn('Completed task on thread ID: ', ThreadID);\n  end;\n\n  // Constructor of TTaskThread\n  constructor TTaskThread.Create;\n  begin\n    // Create as suspended.\n    inherited Create(True);\n    // Set Free on Terminate to false, so it won't free itself when completed.\n    FreeOnTerminate := False;\n    // Run thread.\n    Start;\n  end;\n\nvar\n  task1, task2: TThread;\n\nbegin\n  WriteLn('---------------------');\n  WriteLn('Started TThread demo');\n  WriteLn('---------------------');\n\n  // Create all threads\n  task1 := TTaskThread.Create;\n  task2 := TTaskThread.Create;\n\n  // Start a task on the main thread\n  Writeln('Starting a task from the main thread');\n  Sleep(2000); // simulate a task\n  Writeln('Completed the task from the main thread');\n\n  // Wait for threads to finish before going back to the main thread.\n  task1.WaitFor;\n  task2.WaitFor;\n\n  // Free the threads manually\n  task1.Free;\n  task2.Free;\n\n  WriteLn('---------------------');\n  WriteLn('Finished TThread demo');\n  WriteLn('Press Enter to quit');\n  WriteLn('---------------------');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-ii-cs/","title":"Multi-threading with <code>TThread</code> - Part II. Critical Section","text":""},{"location":"docs/advanced/multi-threading-tthread-ii-cs/#why-we-need-critical-sections","title":"Why We Need Critical Sections","text":"<p>Imagine you and your friends are working on a group project, and you all need to update a shared document. If everyone tries to edit the document at the same time, changes might get lost or mixed up. To prevent this, you take turns updating the document. This is similar to what happens in a program when multiple parts (threads) need to access and modify shared data.</p>"},{"location":"docs/advanced/multi-threading-tthread-ii-cs/#the-problem-with-concurrent-access","title":"The Problem with Concurrent Access","text":"<p>In a program, you might have multiple threads running at the same time, each trying to read or write to the same piece of data. If this access isn\u2019t controlled, it can lead to:</p> <ul> <li>Data Corruption: Two threads might try to update the data simultaneously, leading to incorrect results.</li> <li>Inconsistent State: The shared data might end up in an unpredictable state, causing bugs that are hard to find and fix.</li> </ul>"},{"location":"docs/advanced/multi-threading-tthread-ii-cs/#what-is-a-critical-section","title":"What is a Critical Section?","text":"<p>A critical section is a part of your code that you want to protect so that only one thread can execute it at a time. It\u2019s like setting up a rule where only one person can edit the document at a time to ensure that changes are made safely and correctly.</p>"},{"location":"docs/advanced/multi-threading-tthread-ii-cs/#how-it-works-in-free-pascal","title":"How it Works in Free Pascal","text":"<p>In Free Pascal, you use critical sections to control access to shared data.</p> <p>Critical Section as a Lock: Think of a critical section as a lock that you put around the shared document. When someone wants to edit the document, they have to take the lock, do their changes, and then give the lock back. This ensures that only one person can edit at a time.</p> <p>How to Use Critical Sections</p> <ul> <li> <p><code>EnterCriticalSection</code>: Before running the code you want to protect, call <code>EnterCriticalSection</code>. This ensures that the current thread is the only one running the protected code. This call may make the thread wait until it's safe to proceed.</p> </li> <li> <p><code>LeaveCriticalSection</code>: After the protected code has finished, call <code>LeaveCriticalSection</code>. This allows other threads to run the protected code.</p> </li> </ul> <p>Tip</p> <p>To minimise waiting time for threads, keep the protected code block as small as possible.</p> <p>Setup and Cleanup</p> <ul> <li><code>InitCriticalSection</code>: Initializss the critical section. Must be called before using <code>EnterCriticalSection</code> or <code>LeaveCriticalSection</code>.</li> <li><code>DoneCriticalSection</code>: Cleans up the critical section. Must be called when you're done with the critical section.</li> </ul> <p>Here is an example of using Critical Section to increment a counter variable.</p> <pre><code>program CriticalSectionIncrementCounter;\n\n{\n\n  An example adapted from \\lazarus\\examples\\multithreading\\multithread_critical\n  for CLI.\n  This is a simple example using 4 threads to increase a counter (shared\n  variable).\n\n  To enable critical sections, set isCriticalSectionEnabled to True.\n  To disable critical sections, set isCriticalSectionEnabled to False.\n\n  With critical sections you will always get 4,000,000.\n  Without you will see different results on each run.\n\n  Important: In most Unix like systems, the cthread unit must be added\n             to the uses section of the .lpr file. Further, cmem is likely to\n             be significently faster so add it as well. Due to how the units\n             work a sensible order is cmem, cthreads and then perhaps cwstrings.\n             But note that heaptrc does not work with cmem so comment it out\n             while testing/debugging.\n}\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\ntype\n  TCustomThread = class(TTHread)\n  private\n    finishedState: boolean;\n  public\n    procedure Execute; override;\n    property isFinished: boolean read finishedState write finishedState;\n  end;\n\nconst\n  // Use Critical Section or not?\n  isCriticalSectionEnabled: boolean = True;\n\nvar\n  criticalSection: TRTLCriticalSection;\n  mainCounter: integer;\n\n  procedure TCustomThread.Execute;\n  var\n    i: integer;\n    currentCounter: longint;\n  begin\n    // Set the finished state to false.\n    finishedState := False;\n\n    // Increment the mainCounter.\n    // Because the other threads are doing the same, it will frequently happen\n    // that 2 (or more) threads read the same number, increment it by one and\n    // write the result back, overwriting the result of the other threads.\n    for i := 1 to 1000000 do\n    begin\n\n      if isCriticalSectionEnabled then\n        // 2. Begins the lock.\n        //    When this call returns, the calling thread is the only thread\n        //    running the code between the EnterCriticalSection call and the\n        //    following LeaveCriticalsection call.\n        EnterCriticalSection(criticalSection);\n      try\n        // Read the current mainCounter\n        currentCounter := mainCounter;\n        // Increment mainCounter by one\n        Inc(currentCounter);\n        // Write the result back the mainCounter variable\n        mainCounter := currentCounter;\n      finally\n        if isCriticalSectionEnabled then\n          // 3. Releases the lock.\n          //    Signals that the protected code can be executed by other threads.\n          LeaveCriticalSection(criticalSection);\n      end;\n    end;\n\n    // Once the task for this thread is done, set the finished state to True.\n    finishedState := True;\n  end;\n\n  {\n   This is the routine that increment a counter\n  }\n  procedure IncrementCounter;\n  var\n    index: integer;\n    threadList: array[1..4] of TCustomThread;\n    isAllThreadsFinished:boolean;\n  begin\n    mainCounter := 0;\n\n    // 1. Initialises a critical section.\n    //    This call must be made before either EnterCrititicalSection or\n    //    LeaveCriticalSection is used.\n    InitCriticalSection(criticalSection);\n\n    // Start the threadList\n    for index := Low(threadList) to High(threadList) do\n      threadList[index] := TCustomThread.Create(False);\n\n    WriteLn('All threads created ...');\n\n    // Wait till all threadList finished\n    repeat\n      isAllThreadsFinished := True;\n      for index := Low(threadList) to High(threadList) do\n        if not threadList[index].isFinished then isAllThreadsFinished := False;\n    until isAllThreadsFinished;\n\n    WriteLn('All threads completed ...');\n\n    // Free the threadList\n    for index := Low(threadList) to High(threadList) do\n      threadList[index].Free;\n\n    WriteLn('All threads are freed ...');\n\n    // 4. Frees the resources associated with a critical section.\n    //    After this call neither EnterCrititicalSection nor LeaveCriticalSection\n    //    may be used.\n    DoneCriticalSection(criticalSection);\n\n    // Show the mainCounter\n    WriteLn('Printing the value of shared variable ...');\n    WriteLn('Counter = ' + IntToStr(mainCounter));\n  end;\n\n// Main block ------------------------------------------------------------------\nbegin\n  // Print status of Critical Section\n  if isCriticalSectionEnabled then\n    WriteLn('Critical Section: Enabled')\n  else\n    WriteLn('Critical Section: Disabled');\n\n  // Callt he routine to increment a counter using multi-threading\n  IncrementCounter;\n\n  // Pause console\n  WriteLn('Press Enter key to exit.');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-ii-cs/#explanation-of-the-code","title":"Explanation of the Code","text":"<ol> <li> <p>Declare and Initialise:</p> <ul> <li><code>criticalSection</code> is declared as a variable of type <code>TRTLCriticalSection</code>. Line 47.</li> <li><code>InitCriticalSection(criticalSection)</code> initialises the critical section (lock). Line 104.</li> </ul> </li> <li> <p>Enter and Leave Critical Section:</p> <ul> <li><code>EnterCriticalSection(criticalSection)</code> is like taking the lock. Only one thread can do this at a time. Line 70.</li> <li><code>LeaveCriticalSection(criticalSection)</code> releases the lock, allowing another thread to take it. Line 82.</li> </ul> </li> <li> <p>Protecting Shared Data:</p> <ul> <li>The <code>IncrementCounter</code> procedure increments the counter safely because the code inside the critical section can only be executed by one thread at a time. Line 146.</li> </ul> </li> <li> <p>Cleanup:</p> <ul> <li><code>DoneCriticalSection(criticalSection)</code> cleans up the critical section when it's no longer needed. Line 130.</li> </ul> </li> </ol>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/","title":"Multi-threading with <code>TThread</code> Part III - Snippets","text":"<p>Here are collections of snippets solving various tasks using multi-threading.</p>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#run-a-task-on-a-thread-with-a-variable","title":"Run a task on a thread with a variable","text":"<pre><code>program EX1SingleThread;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes { you can add units after this };\n\ntype\n  // The TThread class encapsulates the native thread support of the OS.\n  // To create a thread, (1) declare a child of the TThread object, ...\n  TMyThread = class(TThread)\n    // (with a data to work with)\n  private\n    aString: string;\n  protected\n    // (2) override the Execute method, and ...\n    procedure Execute; override;\n  public\n    // (3) lastly, you may include a constructor to setup variables\n    // for executing this thread.\n    constructor Create(isSuspended: boolean; message: string);\n  end;\n\n  constructor TMyThread.Create(isSuspended: boolean; message: string);\n  begin\n\n    // Call parent's constructor\n    // If user pass True, thread won't start automatically\n    inherited Create(isSuspended);\n\n    // Assign a data to work with.\n    self.aString:=message;\n\n    // Won't free the thread when finished.\n    // The thread will be freed manually on the main block.\n    FreeOnTerminate:=False;\n  end;\n\n  procedure TMyThread.Execute;\n  begin\n    // Execute thread, and DO SOMETHING in this thread.\n\n    // Example: if the thread has a data to work with,\n    //          use it to achieve a goal.\n    WriteLn('Thread ID ', ThreadID, ' is printing ', self.aString);\n\n    // Example: simulate a long running process.\n    Sleep(1000);\n  end;\n\nvar\n  mythread:TMyThread;\n\n// Main block --------------------------------------------------\nbegin\n\n// Create a thread, suspended\nmyThread:=TMyThread.Create(True, 'Hello, World!');\n\n// Debug line\nWriteLn('We are in the main thread');\n\n// Start the thread\nmyThread.Start;\n\n// Wait until the thread is done before going back to\n// the main thread.\nmyThread.WaitFor;\n\n// Free threads manually.\nmyThread.Free;\n\n// Debug line.\nWriteLn('We are in the main thread again');\n\n// Pause console.\nWriteLn('Press enter key to quit');\nReadLn;\n\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#run-same-tasks-on-multiple-threads","title":"Run same tasks on multiple threads","text":"<pre><code>program EX2MultiThread;\n\n{\n  # EX2MultiThread\n\n  A simple demo of multi-threading.\n\n  ## Example of an output\n\n  ---------------------\n  Started TThread demo\n  ---------------------\n  Starting a task from the main thread\n  Started a task on thread ID 22848\n  Started a task on thread ID 24428\n  Completed the task from the main thread\n  Completed task on thread ID: 22848\n  Completed task on thread ID: 24428\n  ---------------------\n  Finished TThread demo\n  Press Enter to quit\n  ---------------------\n}\n\n\n{$mode objfpc}{$H+}{$J-}\n\n// 2024-02-08 - paweld \ud83c\uddf5\ud83c\uddf1 fixed a memory leak issue on the original code.\n\nuses\n  {$ifdef unix}\n  cmem, cthreads,\n  {$endif}\n  Classes,\n  SysUtils;\n\ntype\n  // Create a class based on TThread\n  // TTaskThread\n  TTaskThread = class(TThread)\n  protected\n    // Override the Execute procedure of TThread\n    procedure Execute; override;\n  public\n    // Thread constructor with free on terminate\n    constructor Create;\n  end;\n\n  // The Execute procedure, simulating a task\n  procedure TTaskThread.Execute;\n  begin\n    WriteLn('Started a task on thread ID ', ThreadID);\n\n    Sleep(2000); // Simulating a long-running task.\n\n    WriteLn('Completed task on thread ID: ', ThreadID);\n  end;\n\n  // Constructor of TTaskThread\n  constructor TTaskThread.Create;\n  begin\n    // Create as suspended.\n    inherited Create(True);\n    // Set Free on Terminate to false, so it won't free itself when completed.\n    FreeOnTerminate := False;\n    // Run thread.\n    Start;\n  end;\n\nvar\n  task1, task2: TThread;\n\nbegin\n  WriteLn('---------------------');\n  WriteLn('Started TThread demo');\n  WriteLn('---------------------');\n\n  // Create all threads\n  task1 := TTaskThread.Create;\n  task2 := TTaskThread.Create;\n\n  // Start a task on the main thread\n  Writeln('Starting a task from the main thread');\n  Sleep(2000); // simulate a task\n  Writeln('Completed the task from the main thread');\n\n  // Wait for threads to finish before going back to the main thread.\n  task1.WaitFor;\n  task2.WaitFor;\n\n  // Free the threads manually\n  task1.Free;\n  task2.Free;\n\n  WriteLn('---------------------');\n  WriteLn('Finished TThread demo');\n  WriteLn('Press Enter to quit');\n  WriteLn('---------------------');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#sum-numbers-in-an-array","title":"Sum numbers in an array","text":"<p>Important features of this example.</p> <ol> <li>Use of <code>TIntegerDynArray</code>, which is a dynamic array of integers.</li> <li>Thread Class <code>TMyThread</code> inherits from <code>TThread</code>. This class encapsulates the logic for summing a segment of the array within each thread.</li> <li>The constructor <code>TMyThread.Create</code> initialises the thread with the input array, start index, and end index. This setup ensures each thread works on a specific portion of the array.</li> <li>The <code>Execute</code> method in <code>TMyThread</code> performs the actual summing of numbers within the assigned segment of the array.</li> <li>Main program<ul> <li>Calculates the segment size for each thread using <code>Math.Ceil((Length(inputArray) + MAX_THREADS - 1) / MAX_THREADS)</code>, ensuring that each thread gets an equal or almost equal portion of the array to process.</li> <li>Creates and starts each thread, passing in the relevant segment of the array.</li> <li>After all threads complete their work, collect the partial sums from each thread and calculate the total sum.</li> </ul> </li> <li>Manual memory cleanup by setting <code>FreeOnTerminate := False</code> and manually freeing the threads after collecting their results.</li> <li>Lastly, the program displays information about each thread's segment and its partial sum.</li> </ol> <pre><code>program EX3MultiThread;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  Types,\n  Generics.Collections,\n  Math { you can add units after this };\n\n  // --- Custom thread type --------------------------------------\ntype\n  // The TThread class encapsulates the native thread support of the OS.\n  // To create a thread, (1) declare a child of the TThread object, ...\n  TMyThread = class(TThread)\n    // (with a data to work with)\n  private\n    // Variables to store the input array for this thread to sum, along with\n    // start index and end index\n    anArray: TIntegerDynArray;\n    startIdx: integer;\n    endIdx: integer;\n    // The sum of array in the thread\n    partialSum: integer;\n  protected\n    // (2) override the Execute method, and ...\n    procedure Execute; override;\n  public\n    // (3) lastly, you may include a constructor to setup variables\n    // for executing this thread.\n    constructor Create(const isSuspended: boolean;\n                       var   inputArray: TIntegerDynArray;\n                       const startIndex: integer;\n                       const endIndex: integer);\n  end;\n\n  constructor TMyThread.Create(const isSuspended: boolean;\n                               var   inputArray: TIntegerDynArray;\n                               const startIndex: integer;\n                               const endIndex: integer);\n  begin\n    // Call parent's constructor\n    // If user pass True, thread won't start automatically\n    inherited Create(isSuspended);\n\n    // Assign a data to work with.\n    self.anArray := inputArray;\n    self.startIdx := startIndex;\n    self.endIdx := endIndex;\n\n    // DO NOT Free thread when finished here.\n    // The main thread will ...\n    //   1. collect the results from n threads,\n    //   2. free n threads from the main thread.\n    FreeOnTerminate := False;\n  end;\n\n  procedure TMyThread.Execute;\n  var\n    index: integer;\n  begin\n    // Execute thread, and DO SOMETHING in this thread.\n\n    // Initialise partialSum to 0 to start with\n    self.partialSum := 0;\n\n    // partialSum the numbers in the assigned array using for..do loop.\n    for index := self.startIdx to self.endIdx do\n      self.partialSum := self.partialSum + self.anArray[index];\n\n    // Display user feedback from this thread\n    WriteLn('Thread ', ThreadID, ' summed up ', self.partialSum);\n  end;\n\n// const and var for the main block ----------------------------\nconst\n  // Specify max number of threads to use.\n  MAX_THREADS = 4;\n  // The length of an input array may come from a file.\n  INPUT_ARRAY_LENGTH = 10000;\n\nvar\n  // Input array containg numbers to sum.\n  inputArray: TIntegerDynArray;\n  // Setting an array for the threads.\n  myThreads: array of TMyThread;\n  // Size of a segment for each thread\n  segmentSize: integer;\n  // total sum -- will collect values from each thread\n  totalSum: integer;\n  // Indexes\n  index, startIndex, endIndex: integer;\n\n\n  // Main block ------------------------------------------------\nbegin\n\n  // Populate input array. This may come from a file.\n  SetLength(inputArray, INPUT_ARRAY_LENGTH);\n  for index := 0 to INPUT_ARRAY_LENGTH - 1 do\n    inputArray[index] := index + 1;\n\n\n  // Calculate segment size for each thread\n  segmentSize := Math.Ceil((Length(inputArray) + MAX_THREADS - 1) / MAX_THREADS);\n\n  // Create and start the threads.\n  SetLength(myThreads, MAX_THREADS);\n  for index := 0 to MAX_THREADS - 1 do\n  begin\n    // Start index for a thread is i * segmentSize.\n    startIndex := index * SegmentSize;\n    // Ensure that each thread processes the correct portion of the array\n    // without going out of bounds on last iteration.\n    endIndex := Min((index + 1) * SegmentSize - 1, Length(inputArray) - 1);\n\n    // Show user info.\n    WriteLn('startIndex: ', startIndex, ' ', ' endIndex:', endIndex);\n\n    // Create a thread.\n    myThreads[index] := TMyThread.Create(False, inputArray, StartIndex, EndIndex);\n    // Start this new thread.\n    myThreads[index].Start;\n  end;\n\n  // Wait until a thread is done, sum up and free it.\n  totalSum := 0;\n  for index := 0 to MAX_THREADS - 1 do\n  begin\n    // Wait until thread index n finishes\n    myThreads[index].WaitFor;\n    // Get the partial sum from thread index n\n    totalSum := totalSum + myThreads[index].partialSum;\n    // Lastly, free thread index n\n    myThreads[index].Free;\n  end;\n\n  // Display results\n  WriteLn('Total sum of array is: ', totalSum);\n\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#increment-a-counter-multi-threading","title":"Increment a counter multi-threading","text":"<p>This snippet features:</p> <ul> <li>Use of <code>TRTLCriticalSection</code> to ensure only one thread can increment a counter variable</li> </ul> <pre><code>program CriticalSectionIncrementCounter;\n\n{\n\n  An example adapted from \\lazarus\\examples\\multithreading\\multithread_critical\n  for CLI.\n  This is a simple example using 4 threads to increase a counter (shared\n  variable).\n\n  To enable critical sections, set isCriticalSectionEnabled to True.\n  To disable critical sections, set isCriticalSectionEnabled to False.\n\n  With critical sections you will always get 4,000,000.\n  Without you will see different results on each run.\n\n  Important: In most Unix like systems, the cthread unit must be added\n             to the uses section of the .lpr file. Further, cmem is likely to\n             be significently faster so add it as well. Due to how the units\n             work a sensible order is cmem, cthreads and then perhaps cwstrings.\n             But note that heaptrc does not work with cmem so comment it out\n             while testing/debugging.\n}\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\ntype\n  TCustomThread = class(TTHread)\n  private\n    finishedState: boolean;\n  public\n    procedure Execute; override;\n    property isFinished: boolean read finishedState write finishedState;\n  end;\n\nconst\n  // Use Critical Section or not?\n  isCriticalSectionEnabled: boolean = True;\n\nvar\n  criticalSection: TRTLCriticalSection;\n  mainCounter: integer;\n\n  procedure TCustomThread.Execute;\n  var\n    i: integer;\n    currentCounter: longint;\n  begin\n    // Set the finished state to false.\n    finishedState := False;\n\n    // Increment the mainCounter.\n    // Because the other threads are doing the same, it will frequently happen\n    // that 2 (or more) threads read the same number, increment it by one and\n    // write the result back, overwriting the result of the other threads.\n    for i := 1 to 1000000 do\n    begin\n\n      if isCriticalSectionEnabled then\n        // 2. Begins the lock.\n        //    When this call returns, the calling thread is the only thread\n        //    running the code between the EnterCriticalSection call and the\n        //    following LeaveCriticalsection call.\n        EnterCriticalSection(criticalSection);\n      try\n        // Read the current mainCounter\n        currentCounter := mainCounter;\n        // Increment mainCounter by one\n        Inc(currentCounter);\n        // Write the result back the mainCounter variable\n        mainCounter := currentCounter;\n      finally\n        if isCriticalSectionEnabled then\n          // 3. Releases the lock.\n          //    Signals that the protected code can be executed by other threads.\n          LeaveCriticalSection(criticalSection);\n      end;\n    end;\n\n    // Once the task for this thread is done, set the finished state to True.\n    finishedState := True;\n  end;\n\n  {\n   This is the routine that increment a counter\n  }\n  procedure IncrementCounter;\n  var\n    index: integer;\n    threadList: array[1..4] of TCustomThread;\n    isAllThreadsFinished:boolean;\n  begin\n    mainCounter := 0;\n\n    // 1. Initialises a critical section.\n    //    This call must be made before either EnterCrititicalSection or\n    //    LeaveCriticalSection is used.\n    InitCriticalSection(criticalSection);\n\n    // Start the threadList\n    for index := Low(threadList) to High(threadList) do\n      threadList[index] := TCustomThread.Create(False);\n\n    WriteLn('All threads created ...');\n\n    // Wait till all threadList finished\n    repeat\n      isAllThreadsFinished := True;\n      for index := Low(threadList) to High(threadList) do\n        if not threadList[index].isFinished then isAllThreadsFinished := False;\n    until isAllThreadsFinished;\n\n    WriteLn('All threads completed ...');\n\n    // Free the threadList\n    for index := Low(threadList) to High(threadList) do\n      threadList[index].Free;\n\n    WriteLn('All threads are freed ...');\n\n    // 4. Frees the resources associated with a critical section.\n    //    After this call neither EnterCrititicalSection nor LeaveCriticalSection\n    //    may be used.\n    DoneCriticalSection(criticalSection);\n\n    // Show the mainCounter\n    WriteLn('Printing the value of shared variable ...');\n    WriteLn('Counter = ' + IntToStr(mainCounter));\n  end;\n\n// Main block ------------------------------------------------------------------\nbegin\n  // Print status of Critical Section\n  if isCriticalSectionEnabled then\n    WriteLn('Critical Section: Enabled')\n  else\n    WriteLn('Critical Section: Disabled');\n\n  // Callt he routine to increment a counter using multi-threading\n  IncrementCounter;\n\n  // Pause console\n  WriteLn('Press Enter key to exit.');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#assigns-student-ids-to-student-names","title":"Assigns student IDs to student names","text":"<p>This program assigns an ID to each student name from a text file and sorts them by student ID.</p> <p>This snippet features:</p> <ul> <li><code>TFileStream</code> and <code>TStreamReader</code> for reading lines from a text file</li> <li>Use of four threads to complete the task</li> <li>Use of rounding-up division to split the workload between threads</li> <li>Use of <code>TRTLCriticalSection</code> to ensure only one thread can write to the output list</li> </ul>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#the-commonpas-of-assigning-ids-to-names","title":"The <code>common.pas</code> of assigning IDs to names","text":"<p>This file holds the common type and variable declarations.</p> <p>There are two important common variables here:</p> <ol> <li><code>startStudentID: int64 = 200000;</code> - This variable specifies the starting index for student IDs. All threads will read from this variable and increment it by one for other threads to read from. Therefore, reading and incrementing this variable MUST be done within a critical section to avoid race conditions.</li> <li><code>finalStudentList: TStudentList;</code> - A list of TStudent records containing names and student IDs. All threads will write their output here, so writing to this variable MUST also be done within a critical section.</li> </ol> <pre><code>unit Common;\n\n{$mode ObjFPC}{$H+}\n\ninterface\n\nuses\n  Classes, SysUtils, Generics.Defaults, Generics.Collections, Math;\n\n\ntype\n  // A record to hold student information.\n  TStudent = record\n    Name: string;\n    id: integer;\n  end;\n\ntype\n  // A list to hold student records, along with a comparer for\n  // sorting the list afterwards.\n  TStudentList = specialize TList&lt;TStudent&gt;;\n  TStudentListComparer = specialize TComparer&lt;TStudent&gt;;\n\ntype\n  // A type of string list.\n  TStrList = specialize TList&lt;string&gt;;\n\nconst\n  // Number of maximum threads to use.\n  maxThreads: int64 = 4;\n\nvar\n  // This variable specifies the lowest index for student ID.\n  // All threads will be reading from this variable and increase by one\n  // for other threads to read from.\n  // Hence, reading and increment of this variable MUST be done\n  // from within a critical section to avoid race.\n  startStudentID: int64 = 200000;\n\n  // A list of TStudent records. All threads will write student names and\n  // student IDs into this variable.\n  // Hence, writing to this variable MUST be done from within\n  // a critical section too.\n  finalStudentList: TStudentList;\n\n// Custom comparison function for sorting by name - ascending\nfunction CompareID(const LeftItem, RightItem: TStudent): integer;\n\nimplementation\n\n// Custom comparison function for sorting by student id - ascending\nfunction CompareID(const LeftItem, RightItem: TStudent): integer;\nbegin\n  Result := CompareValue(LeftItem.id, RightItem.id);\nend;\n\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#the-customthreadpas-of-assigning-ids-to-names","title":"The <code>customthread.pas</code> of assigning IDs to names","text":"<p>This file defines the implementation of a custom thread based on <code>TThread</code>.</p> <p>There are important things to note here:</p> <ol> <li>The implementation includes a <code>destructor</code> to clean up the list used by the threads for the task (lines 30, 63-69).</li> <li>The thread receives an array but only processes a portion of it based on the rounding-up division algorithm defined in the main block.</li> <li><code>FreeOnTerminate := False</code> as the main thread is responsible for managing the freeing of all threads (line 47).</li> <li>The <code>Execute</code> method updates shared variables within a critical section (lines 79-91).</li> </ol> <pre><code>unit CustomThread;\n\n{$mode ObjFPC}{$H+}{$J-}\n\ninterface\n\nuses\n  Classes, SysUtils, Common;\n\n  // Create a thread class deriving from TThread.\ntype\n  // The TThread class encapsulates the native thread support of the OS.\n  // To create a thread, (1) declare a child of the TThread object, ...\n  TCustomThread = class(TThread)\n    // (with a data to work with)\n  private\n    // A TStrList to store the input array for this thread, along with\n    // a variable to store an instance of critical section.\n    list: TStrList;\n    cs:TRTLCriticalSection;\n  protected\n    // (2) override the Execute method, and ...\n    procedure Execute; override;\n  public\n    // (3) include a constructor to setup variables for executing this thread.\n    constructor Create(const criticalSection: TRTLCriticalSection;\n                       const listToProcess: TStrList;\n                       const startIndex, finishIndex: int64);\n    // (4) lastly, include  destructor to free the TStrList of this thread.\n    destructor Destroy; override;\n  end;\n\nimplementation\n\n// Create the Custom Thread with an input list to process.\nconstructor TCustomThread.Create(const criticalSection: TRTLCriticalSection;\n                                 const listToProcess: TStrList;\n                                 const startIndex, finishIndex: int64);\nvar\n  index: int64;\nbegin\n  // Call parent's constructor\n  // If user pass True, thread won't start automatically\n  inherited Create(True);\n\n  // Not free threads on terminate.\n  // Threads will be freed from the main thread.\n  FreeOnTerminate := False;\n\n  // Assign critical section\n  self.cs := criticalSection;\n\n  // Populate the internal list for the Execute procedure\n  self.list := TStrList.Create;\n  for index := startIndex to finishIndex do\n  begin\n    self.list.Add(listToProcess[index]);\n  end;\n\n  // User feedback\n  WriteLn('Thread created with id: ', ThreadID);\nend;\n\ndestructor TCustomThread.Destroy;\nbegin\n  // Free the TStrList.\n  self.list.Free;\n  // Call parents' Destroy.\n  inherited Destroy;\nend;\n\n// Enter and leave Critical Section here.\nprocedure TCustomThread.Execute;\nvar\n  index: int64;\n  student: TStudent;\nbegin\n  for index := 0 to self.list.Count - 1 do\n  begin\n    EnterCriticalSection(cs); // --------------------------------- enter cs\n    try\n      // Add student - ID pair as TStudent, then add into TStudentList\n      //   1. Get the name from the list with allocated index\n      student.Name := list[index];\n      //   2. Get the starting student ID from\n      student.id := startStudentID;\n      //   3. Add TStudent into TStudentList (the main block does the init)\n      finalStudentList.Add(student);\n      // After a student - ID pair is added, increment the current student ID by 1\n      startStudentID := startStudentID + 1\n    finally\n      LeaveCriticalSection(cs); // ------------------------------- leave cs\n    end;\n  end;\nend;\n\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#the-main-program-of-assigning-ids-to-names","title":"The main program of assigning IDs to names","text":"<p>Key features of the main snippet:</p> <ol> <li>The text file is read into <code>strList</code>.</li> <li>Threads are created and assigned specific subarrays to process.</li> <li>Critical sections ensure safe access to shared variables.</li> <li>After the threads finish, the results are sorted and printed.</li> </ol> <pre><code>program AssignStudentIDs;\n\n{\n This program assigns student ID to each name from a text file by\n using N number of threads.\n\n Pre-requisite\n\n    - TThread for managing the threads.\n    - TRTLCriticalSection for ensuring only one thread can modify a shared\n      variable at one time.\n    - Input text file containing a list of names. For example;\n\n    Alyssa Morgan\n    Declan Hayes\n    Nora Patel\n    Miles Thompson\n    Sienna Larson\n    Kellan Rivera\n    Camille Chang\n    Jensen Park\n    Amara Singh\n    Holden Myers\n    Elise Howard\n    Luca Griffin\n    Reagan Patel\n    Kian Gallagher\n    Mara Nguyen\n    ...\n    ...\n\n Algorithm\n\n    - Read the text file into an array.\n      - All threads will read from the same array, but at differing start and\n        finish indexes. This depends on the number of max threads.\n    - Assign workloads to each thread.\n      - Specify the start and finish indexes to each thread.\n      - Will use the rounding up division method to ensure near-equal division\n        of workload for each thread.\n    - Wait for the threads to finish and then free them.\n    - Sort the final student list\n    - Print results on screen.\n\n Sample Output\n\n   $ ./AssignStudentIDs.exe student-names.txt\n   No of students         : 200\n   Max threads            : 4\n   subArray size round up : 51\n   ---------------------------------\n   Thread created 25040\n   Thread created 26324\n   Thread created 11972\n   Thread created 26028\n   Starting threads ...\n   Waiting for threads to finish ...\n   All threads are done ...\n   Printing results ...\n   Alyssa Morgan, 200000\n   Declan Hayes, 200001\n   Nora Patel, 200002\n   Miles Thompson, 200003\n   Sienna Larson, 200004\n   Kellan Rivera, 200005\n   Camille Chang, 200006\n   Jensen Park, 200007\n   Amara Singh, 200008\n   Holden Myers, 200009\n   Elise Howard, 200010\n   Luca Griffin, 200011\n   Reagan Patel, 200012\n   ...\n   ...\n\n}\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem\n  , cthreads\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  Math,\n  streamex,\n  Common,\n  CustomThread;\n\n  // All the variables and procedures to get the job done.\nvar\n  // Critical Section preventing threads accessing a variable at the same time.\n  customCriticalSection: TRTLCriticalSection;\n\n  // TStreams for reading files\n  fileStream: TFileStream;\n  streamReader: TStreamReader;\n\n  // A temporary list to hold student names from a text file\n  strList: TStrList;\n\n  // An array of threads\n  myThreads: array of TThread;\n\n  // Variables for calculating subarray size for each thread\n  subArraySize, index: int64;\n\n  // Main block ////////////////////////////////////////////////////////////////\nbegin\n  try\n    // 1. Read input text file and populate input array from a text file\n    if not FileExists(ParamStr(1)) then\n    begin\n      WriteLn(Format('%s does not exist.', [ParamStr(1)]));\n      Exit;\n    end;\n\n    strList := TStrList.Create;\n    finalStudentList := TStudentList.Create;\n    try\n      fileStream := TFileStream.Create(ParamStr(1), fmOpenRead);\n      try\n        streamReader := TStreamReader.Create(fileStream, 65536, False);\n        try\n          while not streamReader.EOF do\n          begin\n            // Add each line into a list\n            strList.Add(streamReader.ReadLine);\n          end;\n        finally\n          streamReader.Free;\n        end;\n      finally\n        fileStream.Free\n      end;\n\n      // 2. Init Critical Section as we have threads writing to a shared variable\n      InitCriticalSection(customCriticalSection);\n\n      // 3a. set the number of threads in array of TThread\n      SetLength(myThreads, maxThreads);\n      try\n        {\n          3b. Now we add threads &amp; assign workloads, using rounding up division --\n              Ceil((totalElements + N - 1) div N).\n              - When we divide totalElements by N, we get the quotient of the\n                division. However, if totalElements is not evenly divisible by N,\n                there might be a remainder.\n              - In the context of splitting an array into subarrays, we want\n                each subarray to have approximately the same number of elements.\n                Therefore, we want to ensure that any remaining elements after\n                dividing totalElements by N are included in the last subarray to\n                avoid losing data.\n              - The expression Ceil((totalElements + N - 1) div N); effectively\n                rounds up the division by adding N - 1 to totalElements before\n                performing the division. **This ensures that any remainder is\n                accounted for in the last subarray**.\n        }\n        subArraySize := Math.Ceil((strList.Count + maxThreads - 1) / maxThreads);\n\n        // Show user feedback\n        WriteLn('No of students         : ', IntToStr(strList.Count));\n        WriteLn('Max threads            : ', IntToStr(maxThreads));\n        WriteLn('subArray size round up : ', IntToStr(subArraySize));\n        WriteLn('---------------------------------');\n\n        {\n         3c. Assign workload to each thread by using the following info;\n             - source list\n             - start index and\n             - finish index for a thread\n        }\n        for index := 1 to maxThreads do\n        begin\n          myThreads[index - 1] := TCustomThread.Create(customCriticalSection,\n                                                       strList,\n                                                       ((index - 1) * subArraySize),\n                                                       Math.Min(index * subArraySize - 1, strList.Count - 1));\n        end;\n\n        // 4. Start all threads\n        WriteLn('Starting threads ...');\n        for index := 0 to High(myThreads) do\n          myThreads[index].Start;\n\n        // 5. Wait for both threads to finish and free\n        WriteLn('Waiting for threads to finish ...');\n        for index := 0 to High(myThreads) do\n          begin\n            myThreads[index].WaitFor;\n            myThreads[index].Free;\n          end;\n        WriteLn('All threads are done ...');\n\n        // 6. Sort by student ID\n        finalStudentList.Sort(TStudentListComparer.construct(@CompareID));\n\n        // 7. Show results\n        WriteLn('Printing results ...');\n        for index := 0 to finalStudentList.Count - 1 do\n          WriteLn(finalStudentList[index].Name, ', ', finalStudentList[index].id);\n\n        // 8. Show user feedback\n        WriteLn('---------------------------------');\n        WriteLn(Format('Output list contains %d items', [finalStudentList.Count]));\n        WriteLn('---------------------------------');\n      finally\n        // 7. Free Critical Section\n        DoneCriticalSection(customCriticalSection);\n      end;\n    finally\n      finalStudentList.Free;\n      strList.Free;\n    end;\n\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end;\nend.\n</code></pre>"},{"location":"docs/advanced/multi-threading-tthread-iii-snippets/#a-large-text-file-parser","title":"A Large Text File Parser","text":"<p>This example demonstrates how to parse a text file using multi-threading. The code reads the text file, divides it into chunks, and assigns each chunk to a different thread. Each thread then prints the number of bytes it processed and the first line of its chunk.</p> <pre><code>program LargeTextFileParser;\n\n{\n Description\n\n This program is a simple example of parsing of a text file using N threads.\n The code reads and divides the text file into chunks and assigns these chunks\n to different threads, ensuring that no chunk splits a paragraph or sentence.\n\n Workflow\n\n 1. File Reading      - Read the file in 12MB chunks.\n 2. Data Integrity    - Ensure chunks do not split paragraphs or sentences by\n                        adjusting the file pointer based on the last newline\n                        character.\n 3. Thread Management - Use up to N threads to process chunks in parallel.\n 4. Display Output    - Print the size of each chunk and the first line of each chunk.\n}\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Classes,\n  SysUtils,\n  Math;\n\nconst\n  MAX_THREADS = 8; // Max threads to use\n  CHUNK_SIZE = 12 * 1024 * 1024; // Size of chunk for each thread to process (12MB)\n\ntype\n  // The TThread class encapsulates the native thread support of the OS.\n  TFileChunkProcessor = class(TThread)\n  private\n    FData: array of char; // Chunk of data to work with\n    FDataSize: integer;   // Length of data to the nearest new line\n  protected\n    procedure Execute; override;\n  public\n    constructor Create(const AData: array of char; ADataSize: integer);\n  end;\n\n  constructor TFileChunkProcessor.Create(const AData: array of char; ADataSize: integer);\n  begin\n    // Call parent's constructor and don't start thread automatically\n    inherited Create(True);\n\n    // Assign a AData size to work with\n    FDataSize := ADataSize;\n\n    // Allocate memory for AData and copy it\n    // Since Char in Free Pascal can be 1 or 2 bytes (depending on whether\n    // it's an ANSI or Unicode character), using SizeOf(Char) ensures\n    // the correct number of bytes are moved\n    SetLength(FData, FDataSize);\n    Move(AData[0], FData[0], FDataSize * SizeOf(char));\n\n    // Do not free thread automatically when finished.\n    FreeOnTerminate := False;\n  end;\n\n  procedure TFileChunkProcessor.Execute;\n  var\n    line: string;\n    index: integer;\n  begin\n    // Example processing: print the chunk size and the first line\n    line := '';\n    for index := 0 to FDataSize - 1 do\n    begin\n      if FData[index] = #10 then\n      begin\n        Writeln('Processed chunk of size: ', FDataSize, ' bytes');\n        Writeln('First line: ', line);\n        Break;\n      end\n      else if FData[index] &lt;&gt; #13 then\n      begin\n        line := line + FData[index];\n      end;\n    end;\n  end;\n\n  {\n   This routine reads a text file in chunks and processes each chunk using\n   separate threads. It ensures each thread processes a chunk up to the\n   nearest newline, without breaking a paragraph or sentence.\n  }\n  procedure ReadFileInChunks(const AFileName: string);\n  var\n    fStream: TFileStream;\n    buffer: array of char;\n    bufferSize: integer;\n    index, lastNewLine: integer;\n    threadList: array of TFileChunkProcessor;\n    activeThreads: integer;\n  begin\n    fStream := TFileStream.Create(AFileName, fmOpenRead);\n    try\n\n      // Initialise variables for buffer, threads and threads counter.\n      SetLength(buffer, CHUNK_SIZE);\n      SetLength(threadList, MAX_THREADS);\n      activeThreads := 0;\n\n      // Read the file until the file pointer reaches the end of the file\n      while fStream.Position &lt; fStream.Size do\n      begin\n        // Determine the buffer size to read and ensuring that the buffer size\n        // for reading does not exceed the size of the remaining data in the file.\n        bufferSize := Min(CHUNK_SIZE, (fStream.Size - fStream.Position) div SizeOf(char));\n\n        // Read data into buffer\n        fStream.Read(buffer[0], bufferSize);\n\n         // Find the index of the last newline character in the buffer\n        lastNewLine := -1;\n        for index := bufferSize - 1 downto 0 do\n        begin\n          if buffer[index] = #10 then\n          begin\n            lastNewLine := index;\n            Break;\n          end;\n        end;\n\n        if lastNewLine = -1 then\n          lastNewLine := bufferSize - 1;\n\n        // Create a thread to process the chunk and its size (index of \\n + 1)\n        threadList[activeThreads] := TFileChunkProcessor.Create(buffer, lastNewLine + 1);\n        threadList[activeThreads].Start;\n\n        {\n          Next, adjust file position to the character after the last newline.\n\n          ---\n          Explanation\n          ---\n\n          Let's say we have a buffer size of 1000 characters, and the last\n          newline character is found at index 950.\n          The buffer contains 50 characters after the last newline.\n\n          bufferSize  = 1000\n          lastNewLine = 950\n          bufferSize - lastNewLine - 1 = 1000 - 950 - 1 = 49\n          Assuming SizeOf(Char) = 1 (for simplicity),\n\n          ```pascal\n          fStream.Position := fStream.Position - 49 * SizeOf(Char);\n          ```\n\n          This means the file position is moved back by 49 bytes, so the next\n          read operation will start at the 951st character in the buffer,\n          which is the character immediately following the last newline.\n          This ensures that no line is split between two chunks and maintains\n          the integrity of the data being processed.\n        }\n        fStream.Position := fStream.Position - (bufferSize - lastNewLine - 1) * SizeOf(char);\n\n        // Increment active thread counter\n        Inc(activeThreads);\n\n        // If max threads are active, wait for them to finish\n        if activeThreads = MAX_THREADS then\n        begin\n          for index := 0 to MAX_THREADS - 1 do\n          begin\n            threadList[index].WaitFor;\n          end;\n          activeThreads := 0;\n        end;\n      end; // -- End of the `while fStream.Position &lt; fStream.Size do` loop.\n\n      // Wait for any remaining threads to complete\n      for index := 0 to activeThreads - 1 do\n      begin\n        threadList[index].WaitFor;\n      end;\n\n    finally\n      fStream.Free; // Clean up the file stream\n    end;\n  end;\n\n  // MAIN block ----------------------------------------------------------------\nbegin\n\n  // Check if the input file exists\n  if not FileExists(ParamStr(1)) then\n  begin\n    WriteLn('File not found. Does ', ParamStr(1), ' exist?');\n    Exit;\n  end;\n\n  // Parse the text file using multi-threading\n  try\n    ReadFileInChunks(ParamStr(1));\n  except\n    on E: Exception do\n      Writeln(E.ClassName, ': ', E.Message);\n  end;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib-summary/","title":"Numerical with NumLib | Summary","text":"<p>The notes on this page is based on the Free Pascal NumLib official doc.</p> <p>Credits</p> <p>Thanks to Kees van Ginneken, Wil Kortsmit and Loek van Reij of the Computational centre of the Eindhoven University of Technology for making it available for the Free Pascal project.</p> <p>Thanks to Marco van de Voort (marco@freepascal.org) and Michael van Canneyt (michael@freepascal.org) for porting to FPC and documenting NumLib.</p> <p>Routines in NumLib</p> <ul> <li>Basic operations with matrices and vectors - unit <code>omv</code></li> <li>Calculation of determinants - unit <code>det</code></li> <li>Matrix inversion - unit <code>inv</code></li> <li>Solution of systems of linear equations - unit <code>sle</code></li> <li>Calculation of eigenvalues - unit <code>eig</code></li> <li>Finding roots of equations - unit <code>roo</code></li> <li>Calculates integrals - unit <code>int</code></li> <li>Oridnary differential equations - unit <code>ode</code></li> <li>Fitting routines - unit <code>ipf</code></li> <li>Calculation of special functions - unit <code>spe</code></li> </ul>"},{"location":"docs/advanced/numlib-summary/#unit-omv","title":"Unit <code>omv</code>","text":"Operation and Routine Notes Dot product  <code>function omvinp(var a, b: ArbFloat; n: ArbInt): ArbFloat;</code> \\(\\begin{align}\\mathbf{a} \\cdot \\mathbf{b} &amp;= \\sum_{i=1}^n a_i b_i \\\\ &amp;= a_1 b_1 + a_2 b_2 + \\dots + a_n b_n\\end{align}\\) Product of two matrices  <code>procedure omvmmm(var a: ArbFloat; m, n, rwa: ArbInt; var b: ArbFloat; p, rwb: ArbInt; var c: ArbFloat; rwc: ArbInt);</code> \\(C_{ij} = \\sum_{k=0}^n A_{ik} B_{kj}\\) Product of a matrix and a vector  <code>procedure omvmmv(var a: ArbFloat; m, n, rwidth: ArbInt; var b, c: ArbFloat);</code> \\(\\begin{align}\\mathbf{c} &amp;= A\\ \\mathbf{b} \\\\ &amp;= \\left[ \\begin{array}{cccc} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\ldots &amp; a_{1n} \\\\ a_{21} &amp; a_{22} &amp; a_{23} &amp; \\ldots &amp; a_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; \\ldots &amp; a_{mn} \\end{array} \\right] \\left[ \\begin{array}{c} b_1 \\\\ b_2 \\\\ b_3 \\\\ \\vdots \\\\ b_n \\end{array} \\right] \\\\ &amp;= \\left[ \\begin{array}{c} a_{11}b_1 + a_{12}b_2 + a_{13}b_3 + \\cdots + a_{1n}b_n \\\\ a_{21}b_1 + a_{22}b_2 + a_{23}b_3 + \\cdots + a_{2n}b_n \\\\ \\vdots \\\\ a_{m1}b_1 + a_{m2}b_2 + a_{m3}b_3 + \\cdots + a_{mn}b_n \\end{array} \\right]\\end{align}\\) Transpose matrix  <code>procedure omvtrm(var a: ArbFloat; m, n, rwa: ArbInt; var c: ArbFloat; rwc: ArbInt);</code> \\(\\begin{align}A &amp;= \\left[ \\begin{array}{cccc} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\ldots &amp; a_{1n} \\\\ a_{21} &amp; a_{22} &amp; a_{23} &amp; \\ldots &amp; a_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; \\ldots &amp; a_{mn} \\end{array} \\right] \\quad \\\\ A^T &amp;= \\left[ \\begin{array}{cccc} a_{11} &amp; a_{21} &amp; \\ldots &amp; a_{m1} \\\\ a_{12} &amp; a_{22} &amp; \\ldots &amp; a_{m2} \\\\ a_{13} &amp; a_{23} &amp; \\ldots &amp; a_{m3} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{1n} &amp; a_{2n} &amp; \\ldots &amp; a_{mn} \\end{array} \\right]\\end{align}\\) 1-norm of a vector  <code>function omvn1v(var a: ArbFloat; n: ArbInt): ArbFloat;</code> \\(\\|a\\|_1 = \\sum_{i=1}^n |{a_i}|\\) 2-norm of a vector  <code>function omvn2v(var a: ArbFloat; n: ArbInt): ArbFloat;</code> \\(\\|a\\|_2 = \\sqrt{\\sum_{i=1}^n {a_i}^2}\\) Maximum infinite norm of a vector  <code>function omvnmv(var a: ArbFloat; n: ArbInt): ArbFloat;</code> 1-norm of a matrix  <code>function omvn1m(var a: ArbFloat; m, n, rwidth: ArbInt): ArbFloat;</code> \\(\\|M\\|_1 = \\max_{1 \\le j \\le {n}} \\sum_{i=1}^m|M_{ij}|\\) Maximum infinite norm of a matrix  <code>function omvnmm(var a: ArbFloat; m, n, rwidth: ArbInt): ArbFloat;</code> \\(\\|M\\|_\\infty = \\max_{1 \\le i \\le\\ m} \\sum_{j=1}^n |M_{ij}|\\) Frobenius norm of a matrix  <code>function omvnfm(Var a: ArbFloat; m, n, rwidth: ArbInt): ArbFloat;</code> \\(\\|M\\|_F = \\sqrt{\\sum_{i=1}^m \\sum_{j=1}^n {M_{ij}}^2}\\)"},{"location":"docs/advanced/numlib-summary/#unit-det","title":"Unit <code>det</code>","text":"Operation and Routine Notes Determinant of a standard matrix.   <code>procedure detgen(n, rwidth: ArbInt; var a, f: ArbFloat; var k, term: ArbInt);</code> <code>procedure detgsy(n, rwidth: ArbInt; var a, f: ArbFloat; var k, term: ArbInt);</code> <code>procedure detgpd(n, rwidth: ArbInt; var a, f: ArbFloat; var k, term: ArbInt);</code> For example:  \\(\\begin{align}\\det(A) &amp;= \\begin{vmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{vmatrix} \\\\ &amp;= a \\begin{vmatrix} e &amp; f \\\\ h &amp; i \\end{vmatrix} - b \\begin{vmatrix} d &amp; f \\\\ g &amp; i \\end{vmatrix} + c \\begin{vmatrix} d &amp; e \\\\ g &amp; h \\end{vmatrix} \\\\ &amp;= a(ei - fh) - b(di - fg) + c(de - dh)\\end{align}\\) <code>detgen</code> - generic matrix  <code>detgsy</code> - symmetric matrix  <code>detgpd</code> - symmetric positive definite matrix Determinant of a band matrix.   <code>procedure detgba(n, l, r: ArbInt; var a, f: ArbFloat; var k, term:ArbInt);</code> Determinant of a symmetric positive definite band matrix.   <code>procedure detgpb(n, w: ArbInt; var a, f: ArbFloat; var k, term:ArbInt);</code> Determinant of a tridiagonal matrix.   <code>procedure detgtr(n: ArbInt; var l, d, u, f: ArbFloat; var k, term:ArbInt);</code>"},{"location":"docs/advanced/numlib-summary/#unit-inv","title":"Unit <code>inv</code>","text":"Operation and Routine Notes Inverse of a matrix.  <code>procedure invgen(n, rwidth: ArbInt; var ai: ArbFloat; var term: ArbInt);</code> <code>procedure invgsy(n, rwidth: ArbInt; var ai: ArbFloat; var term: ArbInt);</code> <code>procedure invgpd(n, rwidth: ArbInt; var ai: ArbFloat; var term: ArbInt);</code> Suppose a square matrix \\(A\\). The matrix \\(A^{-1}\\) is the inverse of \\(A\\) if the product \\(A^{-1} A\\) is the identity matrix \\(I\\).  \\(\\displaystyle{  A^{-1} A = I =  \\begin{bmatrix} 1  &amp;    &amp; 0 \\\\ &amp; \\ddots  &amp;   \\\\  0  &amp;     &amp; 1 \\end{bmatrix} }\\)"},{"location":"docs/advanced/numlib-summary/#unit-sle","title":"Unit <code>sle</code>","text":"<p>This unit has routines for solving linear equations with various conditions.</p> Operation and Routine Notes Square matrices  <code>ArbFloat; var term: ArbInt);</code> <code>procedure slegsy(n, rwidth: ArbInt; var a, b, x, ca: ArbFloat; var term: ArbInt);</code> <code>procedure slegpd(n, rwidth: ArbInt; var a, b, x, ca: ArbFloat; var term: ArbInt);</code> Band matrix  <code>procedure slegba(n, l, r: ArbInt; var a, b, x, ca: ArbFloat; var term:ArbInt);</code> An optimised routine for solving band matrices. Symmetric positive definite band matrix.  <code>procedure slegpb(n, w: ArbInt; var a, b, x, ca: ArbFloat; var term: ArbInt);</code> Optimised approach for a symmetric positive band matrix. Tridiagonal matrix.  <code>procedure sledtr(n: ArbInt; var l, d, u, b, x: ArbFloat; var term: ArbInt);</code> <code>procedure slegtr(n: ArbInt; var l, d, u, b, x, ca: ArbFloat; var term: ArbInt);</code> These are optimised procedures for solving system of linear equations based on tridiagonal matrices. Least squares.  <code>procedure slegls(var a: ArbFloat; m, n, rwidtha: ArbInt; var b, x: ArbFloat; var term: ArbInt);</code> Solves linear systems of a rectangular matrix (has more equations than unknowns)."},{"location":"docs/advanced/numlib-summary/#unit-eig","title":"Unit <code>eig</code>","text":"Operation and Routine Notes Calculates eigenvectors and eigenvalues of generic matrix.   <code>procedure eigge1(var a: ArbFloat; n, rwidth: ArbInt; var lam: complex; var term: ArbInt);</code> <code>procedure eigge3(var a: ArbFloat; n, rwidtha: ArbInt; var lam, x: complex; rwidthx: ArbInt; var term: ArbInt);</code> <code>eigge1</code> calculates all eigenvalues.  <code>eigg3</code> calculates all eigenvalues and eigenvectors. Calculates eigenvectors and eigenvalues of generic symmetric matrix.  <code>procedure eiggs1(var a: ArbFloat; n, rwidth: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eiggs2(var a: ArbFloat; n, rwidth, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eiggs3(var a: ArbFloat; n, rwidtha: ArbInt; var lam, x: ArbFloat; var term: ArbInt);</code> <code>procedure eiggs4(var a: ArbFloat; n, rwidtha, k1, k2: ArbInt; var lam, x: ArbFloat; var term: ArbInt);</code> <code>eiggs1</code> finds all eigenvalues  <code>eiggs2</code> finds some eigenvalues (index k1..k2)  <code>eiggs3</code> finds all eigenvalues and eigenvectors  <code>eiggs4</code> finds some eigenvalues and eigenvectors (index k1..k2). Calculates eigenvectors and eigenvalues of generic symmetric positive definite matrix.  <code>procedure eiggg1(var a: ArbFloat; n, rwidth: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eiggg2(var a: ArbFloat; n, rwidth, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eiggg3(var a: ArbFloat; n, rwidtha: ArbInt; var lam, x: ArbFloat; var term: ArbInt);</code> <code>procedure eiggg4(var a: ArbFloat; n, rwidtha, k1, k2: ArbInt; var lam, x: ArbFloat; var term: ArbInt);</code> <code>eiggg1</code> finds all eigenvalues  <code>eiggg2</code> finds some eigenvalues (index k1..k2)  <code>eiggg3</code> finds all eigenvalues and eigenvectors  <code>eiggg4</code> finds some eigenvalues and eigenvectors (index k1..k2). Calculates eigenvectors and eigenvalues of symmetric band matrices.   <code>procedure eigbs1(var a: ArbFloat; n, w: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eigbs2(var a: ArbFloat; n, w, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eigbs3(var a: ArbFloat; n, w: ArbInt; var lam, x: ArbFloat; rwidthx: ArbInt; var term: ArbInt);</code> <code>procedure eigbs4(var a: ArbFloat; n, w, k1, k2: ArbInt; var lam, x: ArbFloat; rwidthx: ArbInt; var m2, term: ArbInt);</code> <code>eigbs1</code> finds all eigenvalues  <code>eigbs2</code> finds some eigenvalues (index k1..k2)  <code>eigbs3</code> finds all eigenvalues and eigenvectors  <code>eigbs4</code> finds some eigenvalues and eigenvectors (index k1..k2). Calculates eigenvectors and eigenvalues of symmetric tridiagonal matrices   <code>procedure eigts1(var d, cd: ArbFloat; n: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eigts2(var d, cd: ArbFloat; n, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);</code> <code>procedure eigts3(var d, cd: ArbFloat; n: ArbInt; var lam, x: ArbFloat; rwidth: ArbInt; var term: ArbInt);</code> <code>procedure eigts4(var d, cd: ArbFloat; n, k1, k2: ArbInt; var lam, x: ArbFloat; rwidth: ArbInt; var m2, term: ArbInt);</code> <code>eigts1</code> finds all eigenvalues  <code>eigts2</code> finds some eigenvalues (index k1..k2)  <code>eigts3</code> finds all eigenvalues and eigenvectors  <code>eigts4</code> finds some eigenvalues and eigenvectors (index k1..k2)."},{"location":"docs/advanced/numlib-summary/#unit-roo","title":"Unit <code>roo</code>","text":"Operation and Routine Notes Polynomial of degree \\(n\\).  <code>procedure roopol(var a: ArbFloat; n: ArbInt; var z: complex; var k, term: ArbInt);</code> A polynomial of degree n  \\(\\displaystyle{  z^n + a_1 z^{n-1} + a_2 z^{n-2} + ... + a_{n-1} z + a_n = 0 }\\)  always has \\(n\\), not necessarily distinct, complex solutions. Special polynomal of degree 2.  <code>procedure rooqua(p, q: ArbFloat; var z1, z2: complex);</code> The quadratic equation  \\(\\displaystyle{ {z}^2 + {p} {z} + {q} = 0}\\)   is a special polynomal of degree 2. It always has two, not necessarily different, complex roots. Solves polynomial that has exactly two terms.  <code>procedure roobin(n: ArbInt; a: complex; var z: complex; var term: ArbInt);</code> \\(\\displaystyle{ z^n = a }\\) has \\(n\\) complex solutions. Bisection method for finding the root of a function.  <code>procedure roof1r(f: rfunc1r; a, b, ae, re: ArbFloat; var x: ArbFloat; var term: ArbInt);</code> Finds root of a non-linear equations.  <code>procedure roofnr(f: roofnrfunc; n: ArbInt; var x, residu: ArbFloat; ra: ArbFloat; var term: ArbInt);</code> Finds the roots of a system of (nonlinear) equations: \\(\\displaystyle{  f_{i}(x_1,x_2,\\ldots,x_n)=0, \\; i=1,2,\\ldots,n }\\)"},{"location":"docs/advanced/numlib-summary/#unit-int","title":"Unit <code>int</code>","text":"Operation and Routine Notes Calculates the integral of a function between \\(a\\) and \\(b\\) with an absolute accuracy \\(ae\\).  <code>procedure int1fr(f: rfunc1r; a, b, ae: ArbFloat; var integral, err: ArbFloat; var term: ArbInt);</code> The function <code>f</code> must take one real number (<code>ArbFloat</code>) as an input and return a real number (<code>ArbFloat</code>).  See the type <code>rfunc1r</code> declared in unit <code>typ</code>."},{"location":"docs/advanced/numlib-summary/#unit-ode","title":"Unit <code>ode</code>","text":"Operation and Routine Notes Solves a single first-order differential equation.  <code>procedure odeiv2(f: oderk1n; a: ArbFloat; var ya, b, yb: ArbFloat; n: ArbInt; ae: ArbFloat; var term: ArbInt);</code> The adaptive algorithm uses a fifth-order explicit Runge-Kutta method, but it's unsuitable for stiff differential equations.  Accuracy is not guaranteed in all cases, and for unstable problems, small changes in \\(y(a)\\) can lead to large errors in \\(y(b)\\). To assess this, try different values of \\(ae\\).  For solving initial value problems over multiple points (e.g., from \\(x=0\\) to \\(x=1\\) with step size 0.1), avoid restarting at \\(x=0\\) with each step; instead, integrate continuously. Solves a system of first-order differential equations.  <code>procedure odeiv2(f: oderk1n; a: ArbFloat; var ya, b, yb: ArbFloat; n: ArbInt; ae: ArbFloat; var term: ArbInt);</code> The algorithm is based on an explicit one-step Runge-Kutta method of order five with variable step size."},{"location":"docs/advanced/numlib-summary/#unit-ipf","title":"Unit <code>ipf</code>","text":"Operation and Routine Notes Fits a set of data points with a polynomial.  <code>procedure ipfpol(m, n: ArbInt; var x, y, b: ArbFloat; var term: ArbInt);</code> Use <code>ipfisn</code> to calculate the parameters of a spline. Then use the <code>ipfspn</code> procedure to find the value of the spline at any point.  <code>procedure ipfisn(n: ArbInt; var x, y, d2s: ArbFloat; var term: ArbInt);</code> <code>function  ipfspn(n: ArbInt; var x, y, d2s: ArbFloat; t: ArbFloat; var term: ArbInt): ArbFloat;</code>"},{"location":"docs/advanced/numlib-summary/#unit-spe","title":"Unit <code>spe</code>","text":"Operation and Routine Notes An efficient method for evaluating a polynomial at a specific x value using Horner's scheme.  <code>function spepol(x: ArbFloat; var a: ArbFloat; n: ArbInt): ArbFloat;</code> \\(\\displaystyle{  \\begin{align}\\operatorname{p}(x) &amp;= a_0 + a_1 x + a_2 x^2 + ... + a_n x^n \\\\ \\operatorname{p}(x) &amp;= a_0 + x (a_1 + x (a_2 + \\dots + x (a_{n-1} + x a_n))) \\end{align}}\\) Calculates error function \\(erf(x)\\) and its complementary error function \\(erfc(x)\\). <code>function speerf(x: ArbFloat): ArbFloat;</code> <code>function speefc(x: ArbFloat): ArbFloat;</code> \\(erf(x)\\) and \\(erfc(x)\\) represent the lower and upper parts of the area under the Gaussian curve, adding up to 1 (100%). Normal and inverse normal distribution. <code>function normaldist(x: ArbFloat): ArbFloat;</code> <code>function invnormaldist(y: ArbFloat): ArbFloat;</code> \\(\\displaystyle{  \\operatorname{N}(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} \\operatorname{exp}(\\frac{t^2}{2}) dt = \\frac{1}{2}[1 + \\operatorname{erf} (\\frac{x}{\\sqrt{2}})]  }\\) Factorials to non-integer (and even complex) numbers. <code>function spegam(x: ArbFloat): ArbFloat;</code> <code>function spelga(x: ArbFloat): ArbFloat;</code> \\(\\displaystyle{ \\Gamma({x}) = \\int_0^{\\infty}t^{x-1} e^{-t} dt }\\) <code>spemgam</code> - direct calculation  <code>spelga</code> - computes the natural logarithm of the Gamma function. Incomplete gamma function. <code>function gammap(s, x: ArbFloat): ArbFloat;</code> <code>function gammaq(s, x: ArbFloat): ArbFloat;</code> \\(\\displaystyle{ \\begin{align} \\operatorname{P}({s},{x}) &amp;= \\frac{1}{\\Gamma({s})} \\int_0^{x}t^{s-1} e^{-t} dt \\\\ \\operatorname{Q}({s},{x}) &amp;= \\frac{1}{\\Gamma({s})} \\int_{x}^{\\infty}t^{s-1} e^{-t} dt = 1 - \\operatorname{P}({s}, {x}) \\end{align}}\\) Beta function. <code>function beta(a, b: ArbFloat): ArbFloat;</code> \\(\\displaystyle{ \\operatorname{B}(a, b) = \\frac{{\\Gamma(a)}{\\Gamma(b)}}{\\Gamma(a+b)} = \\int_0^1{t^{x-1} (1-t)^{y-1} dt} }\\) Incomplete beta function (and the inverse). <code>function betai(a, b, x: ArbFloat): ArbFloat;</code> <code>function invbetai(a, b, y: ArbFloat): ArbFloat;</code> \\(\\displaystyle{ \\operatorname{I}_x(a,b) = \\frac {1}{\\operatorname{B}(ab)} \\int_0^x{t^{x-1} (1-t)^{y-1} dt} }\\) Bessel functions of the first kind (\\(J_\\alpha\\)), of the second kind (\\(Y_\\alpha\\)), and modified first (\\(I_\\alpha\\)) and second kind (\\(K_\\alpha\\)).   NumLib implements only the solutions for the parameters \\(\u03b1 = 0\\) and \\(\u03b1 = 1\\). <code>function spebj0(x: ArbFloat): ArbFloat;</code> <code>function spebj1(x: ArbFloat): ArbFloat;</code> <code>function speby0(x: ArbFloat): ArbFloat;</code> <code>function speby1(x: ArbFloat): ArbFloat;</code> <code>function spebi0(x: ArbFloat): ArbFloat;</code> <code>function spebi1(x: ArbFloat): ArbFloat;</code> <code>function spebk0(x: ArbFloat): ArbFloat;</code> <code>function spebk1(x: ArbFloat): ArbFloat;</code> The Bessel functions are solutions of the Bessel differential equation:  \\(\\displaystyle{ {x}^2 y'' + x y' + ({x}^2 - \\alpha^2) {y} = 0 }\\) <code>spebj0</code> - Bessel function \\(J_0\\) (\u03b1 = 0).  <code>spebj1</code> - Bessel function \\(J_1\\) (\u03b1 = 1).  <code>speby0</code> - Bessel function \\(Y_0\\) (\u03b1 = 0).  <code>speby1</code> - Bessel function \\(Y_1\\) (\u03b1 = 1).  <code>spebi0</code> - modified Bessel function \\(I_0\\) (\u03b1 = 0).  <code>spebi1</code> - modified Bessel function \\(I_1\\) (\u03b1 = 1).  <code>spebk0</code> - modified Bessel function \\(K_0\\) (\u03b1= 0).  <code>spebk1</code> - modified Bessel function \\(K_1\\) (\u03b1 = 1)."},{"location":"docs/advanced/numlib-summary/#unit-spe-others","title":"Unit <code>spe</code> - Others","text":"Function Equivalent function in math Description <code>function speent(x: ArbFloat): LongInt;</code> <code>floor(x)</code> Entier function, calculates first integer smaller than or equal to x <code>function spemax(a, b: Arbfloat): ArbFloat;</code> <code>max(a, b)</code> Maximum of two floating point values <code>function spepow(a, b: ArbFloat): ArbFloat;</code> <code>power(a, b)</code> Calculates \\(a^b\\) <code>function spesgn(x: ArbFloat): ArbInt;</code> <code>sign(x)</code> Returns the sign of x (-1 for x &lt; 0, 0 for x = 0, +1 for x &gt; 0) <code>function spears(x: ArbFloat): ArbFloat;</code> <code>arcsin(x)</code> Inverse function of sin(x) <code>function spearc(x: ArbFloat): ArbFloat;</code> <code>arccos(x)</code> Inverse function of cos(x) <code>function spesih(x: ArbFloat): ArbFloat;</code> <code>sinh(x)</code> Hyperbolic sine <code>function specoh(x: ArbFloat): ArbFloat;</code> <code>cosh(x)</code> Hyperbolic cosine <code>function spetah(x: ArbFloat): ArbFloat;</code> <code>tanh(x)</code> Hyperbolic tangent <code>function speash(x: ArbFloat): ArbFloat;</code> <code>arcsinh(x)</code> Inverse of the hyperbolic sine <code>function speach(x: ArbFloat): ArbFloat;</code> <code>arccosh(x)</code> Inverse of the hyperbolic cosine <code>function speath(x: ArbFloat): ArbFloat;</code> <code>arctanh(x)</code> Inverse of the hyperbolic tangent"},{"location":"docs/advanced/numlib/","title":"Numerical with NumLib | Examples","text":"<p>The notes and examples on this page are based on the Free Pascal NumLib official doc.</p> <p>Credits</p> <p>Thanks to Kees van Ginneken, Wil Kortsmit and Loek van Reij of the Computational centre of the Eindhoven University of Technology for making it available for the Free Pascal project.</p> <p>Thanks to Marco van de Voort (marco@freepascal.org) and Michael van Canneyt (michael@freepascal.org) for porting to FPC and documenting NumLib.</p> <p>Note</p> <p>The code snippets are not exactly the same as the ones in the Free Pascal NumLib official doc. I modified them for my learning.</p> <p>Routines in NumLib</p> <ul> <li>Basic operations with matrices and vectors - unit <code>omv</code></li> <li>Calculation of determinants - unit <code>det</code></li> <li>Matrix inversion - unit <code>inv</code></li> <li>Solution of systems of linear equations - unit <code>sle</code></li> <li>Calculation of eigenvalues - unit <code>eig</code></li> <li>Finding roots of equations - unit <code>roo</code></li> <li>Calculates integrals - unit <code>int</code></li> <li>Oridnary differential equations - unit <code>ode</code></li> <li>Fitting routines - unit <code>ipf</code></li> <li>Calculation of special functions - unit <code>spe</code></li> </ul>"},{"location":"docs/advanced/numlib/#unit-omv-operations-with-matrices-and-vectors","title":"Unit <code>omv</code> - Operations with Matrices and Vectors","text":""},{"location":"docs/advanced/numlib/#inner-product-of-two-vectors","title":"Inner Product of Two Vectors","text":"\\[ \\mathbf{a} \\cdot \\mathbf{b} = \\sum_{i=1}^n a_i b_i = a_1 b_1 + a_2 b_2 + \\dots + a_n b_n \\] <p>NumLib provides the function <code>omvinp</code> for calculation of the inner product:</p> <pre><code>function omvinp(var a, b: ArbFloat; n: ArbInt): ArbFloat;\n</code></pre> <p>Parameters</p> <ul> <li><code>a</code> and <code>b</code> are the first elements of 1-dimensional arrays representing the vectors \\(a\\) and \\(b\\), respectively.</li> <li><code>n</code> defines the dimension of the vectors (count of array elements). Both vectors must have the same number of elements.</li> </ul> <p>Example</p> <p>Calculate the dot product of these vectors.</p> \\[ a = \\begin{pmatrix} 0 \\\\ 1  \\\\ 2  \\\\ 2 \\\\ -1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 3 \\\\ -1 \\\\ -2 \\\\ 2 \\\\ -1 \\end{pmatrix} \\] <pre><code>program omvinp_demo;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  typ,\n  omv;\n\nvar\n  vector_a: array[1..5] of ArbFloat = (0, 1, 2, 2, -1);\n  vector_b: array[1..5] of Arbfloat = (3, -1, -2, 2, -1);\n  product_ab: ArbFloat;\n  i: integer;\n\nbegin\n\n  // Perform dot product\n  product_ab := omvinp(vector_a[1], vector_b[1], high(vector_a));\n\n  // Print vector vector_a\n  Write('Vector a = [');\n  for i := Low(vector_a) to High(vector_a) do\n    Write(vector_a[i]: 4: 0);\n  WriteLn('  ]');\n\n  // Print vector vector_b\n  Write('Vector b = [');\n  for i := Low(vector_b) to High(vector_b) do\n    Write(vector_b[i]: 4: 0);\n  WriteLn('  ]');\n\n  // Print vector_a . b\n  Write('Dot product a . b = ');\n  WriteLn(product_ab: 4: 0);\n\n  WriteLn;\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#product-of-a-matrix-with-a-vector","title":"Product of a Matrix with a Vector","text":"<p>Example</p> <p>Calculate the product of the following.</p> \\[ \\displaystyle{ \\begin{align*}   \\mathbf{c} = A\\ \\mathbf{b}=   \\left[     \\begin{array}{cccc}       3 &amp; 5 &amp; 4 &amp; 1 &amp; -4\\\\       -2 &amp; 3 &amp; 4 &amp; 1 &amp; 0\\\\       0 &amp; 1 &amp; -1 &amp; -2 &amp; 5     \\end{array}   \\right]   \\ \\    \\left[     \\begin{array}{c}       3\\\\       0\\\\       -1\\\\       -2\\\\       1     \\end{array}   \\right] \\end{align*} } \\] <pre><code>program omvmmv_demo;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ,\n  omv;\n\nvar\n  matrix_A: array[1..3, 1..5] of ArbFloat = (\n    (3, 5, 4, 1, -4),\n    (-2, 3, 4, 1, 0),\n    (0, 1, -1, -2, 5));\n  vector_b: array[1..5] of ArbFloat = (3, 0, -1, -2, 1);\n  vector_c: array[1..5] of ArbFloat;\n  m_row, n_column, i, j: integer;\n\nbegin\n\n  m_row := High(matrix_A) - Low(matrix_A) + 1;\n  n_column := High(matrix_A[1]) - Low(matrix_A[1]) + 1;\n\n  // Calculate product vector_c = matrix_A vector_b\n  omvmmv(\n    matrix_A[1, 1], m_row, n_column, n_column,\n    vector_b[1],\n    vector_c[1]\n    );\n\n  // Print matrix_A\n  WriteLn('A = ');\n  for i := 1 to m_row do\n  begin\n    for j := 1 to n_column do\n      Write(matrix_A[i, j]: 4: 0);\n    WriteLn;\n  end;\n  WriteLn;\n\n  // Print vector vector_b\n  WriteLn('b = ');\n  for i := 1 to n_column do\n    WriteLn(vector_b[i]: 4: 0);\n  WriteLn;\n  WriteLn;\n\n  // Print result vector vector_c\n  WriteLn('c = A b');\n  WriteLn('c = ');\n  for i := 1 to m_row do\n    WriteLn(vector_c[i]: 4: 0);\n  WriteLn;\n\n  // Pause console\n  WriteLn('Press enter key to exit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#transpose-matrix","title":"Transpose Matrix","text":"<p>The transpose matrix \\(A^{T}\\) of matrix \\(A\\) is obtained by flipping rows and columns:</p> \\[ \\displaystyle{ \\begin{align*}   {A} = \\left[     \\begin{array}{cccc}       a_{11} &amp; a_{12} &amp; a_{13} &amp; \\ldots &amp; a_{1n}\\\\       a_{21} &amp; a_{22} &amp; a_{23} &amp; \\ldots &amp; a_{2n}\\\\       \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\       a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; \\ldots &amp; a_{mn}     \\end{array}   \\right]   \\ \\ \\   {A^T} =    \\left[     \\begin{array}{cccc}       a_{11} &amp; a_{21} &amp; \\ldots &amp; a_{m1}\\\\       a_{12} &amp; a_{22} &amp; \\ldots &amp; a_{m2}\\\\       a_{13} &amp; a_{23} &amp; \\ldots &amp; a_{m3} \\\\       \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\       a_{1n} &amp; a_{2n} &amp; \\ldots &amp; a{mn}     \\end{array}   \\right] \\end{align*} } \\] <p>Use the procedure omvtrm to perform this operation with NumLib:</p> <pre><code>procedure omvtrm(\n  var a: ArbFloat; m, n, rwa: ArbInt; \n  var c: ArbFloat; rwc: ArbInt\n);\n</code></pre> <p>Parameters</p> <ul> <li><code>a</code> is the first element of the input matrix \\(A\\). The elements of this array are not changed by the procedure.</li> <li><code>m</code> is the number of rows of matrix \\(A\\).</li> <li><code>n</code> is the number of columns of matrix \\(A\\).</li> <li><code>rwa</code> is the number of allocated columns of \\(A\\). This way the array of \\(A\\) can be larger than acutally needed.</li> <li><code>c</code> is the first element of the transposed matrix \\(A^{T}\\). It has \\(n\\) rows and \\(m\\) columns.</li> <li><code>rwc</code> is the number of allocated columns for the transposed matrix.</li> </ul> <p>Example</p> <p>Transpose the following 2 x 4 matrix.</p> \\[ \\displaystyle{ {A} = \\left[     \\begin{array}{cccc}       1  &amp; 2  &amp; 3  &amp; 4 \\\\       11 &amp; 22 &amp; 33 &amp; 44     \\end{array}   \\right]  } \\] <pre><code>program omvtrm_demo;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes, \n  typ,\n  omv;\n\nvar\n  matrix_A: array[1..2, 1..4] of ArbFloat = (\n    ( 1,  2,  3,  4),\n    (11, 22, 33, 44));\n  transposed_A: array[1..4, 1..2] of ArbFloat;\n  m_row_matrix_A, n_col_matrix_A, i, j: integer;\n\nbegin\n\n  m_row_matrix_A := High(matrix_A) - Low(matrix_A) + 1;\n  n_col_matrix_A := High(matrix_A[1]) - Low(matrix_A[1]) + 1;\n\n  // Transpose matrix_A\n  omvtrm(\n    matrix_A[1,1], m_row_matrix_A, n_col_matrix_A, n_col_matrix_A,\n    transposed_A[1,1], m_row_matrix_A\n  );\n\n  // Print matrix_A\n  WriteLn('A = ');\n  for i:= 1 to m_row_matrix_A do begin\n    for j := 1 to n_col_matrix_A do\n      Write(matrix_A[i, j]:8:0);\n    WriteLn;\n  end;\n  WriteLn;\n\n  // Print transposed_A\n  WriteLn('A\u1d40 = ');\n  for i:= 1 to n_col_matrix_A do begin\n    for j := 1 to m_row_matrix_A do\n      Write(transposed_A[i, j]:8:0);\n    WriteLn;\n  end;\n\n  WriteLn;\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#norm-of-vectors-and-matrices","title":"Norm of Vectors and Matrices","text":"<p>A norm assigns a positive \"length\" to a vector or matrix.</p> <p>For vectors, <code>NumLib</code> supports these norms:</p> <ul> <li>The 1-norm is the sum of the absolute values of vector components, also known as the \"Taxicab\" or \"Manhattan\" norm because it represents the distance a taxi drives in a grid.</li> </ul> \\[ \\displaystyle{ \\|a\\|_1 = \\sum_{i=1}^n |{a_i}| } \\] <ul> <li>The 2-norm (Euclidean norm) is the distance from point a to the origin.</li> </ul> \\[ \\displaystyle{ \\|a\\|_2 = \\sqrt{\\sum_{i=1}^n {a_i}^2}  } \\] <ul> <li>The infinity norm is the largest absolute value of the vector components.</li> </ul> \\[ \\displaystyle{ \\|a\\|_\\infty = \\max({a_1}, {a_2}, ... {a_n}) } \\] <p>For matrices, <code>NumLib</code> defines norms based on rows or columns:</p> <ul> <li>The 1-norm is the largest absolute column sum.</li> </ul> \\[ \\displaystyle{ \\|M\\|_1 = \\max_{1 \\le j \\le {n}} \\sum_{i=1}^m|M_{ij}| } \\] <ul> <li>The infinity norm is the largest absolute row sum.</li> </ul> \\[ \\displaystyle{ \\|M\\|_\\infty = \\max_{1 \\le i \\le\\ m} \\sum_{j=1}^n |M_{ij}|  } \\] <ul> <li>The Frobenius norm sums the squares of all matrix elements, similar to the vector 2-norm.</li> </ul> \\[ \\displaystyle{ \\|M\\|_F = \\sqrt{\\sum_{i=1}^m \\sum_{j=1}^n {M_{ij}}^2}  } \\] <p>These are the NumLib routines for calculating norms:</p> <pre><code>function omvn1v(var a: ArbFloat; n: ArbInt): ArbFloat;               // 1-norm of a vector\nfunction omvn1m(var a: ArbFloat; m, n, rwidth: ArbInt): ArbFloat;    // 1-norm of a matrix\nfunction omvn2v(var a: ArbFloat; n: ArbInt): ArbFloat;               // 2-norm of a vector\nfunction omvnfm(Var a: ArbFloat; m, n, rwidth: ArbInt): ArbFloat;    // Frobenius norm of a matrix\nfunction omvnmv(var a: ArbFloat; n: ArbInt): ArbFloat;               // Maximum infinite norm of a vector\nfunction omvnmm(var a: ArbFloat; m, n, rwidth: ArbInt): ArbFloat;    // Maximum infinite norm of a matrix\n</code></pre> <p>Parameters</p> <ul> <li><code>a</code>: First element of the vector or matrix for norm calculation.</li> <li><code>m</code>: Number of rows (for matrix norms).</li> <li><code>n</code>: Number of elements (for vector norms) or columns (for matrix norms).</li> <li><code>rwidth</code>: Allocated column count, allowing for a larger matrix than required.</li> </ul> <p>Example</p> <pre><code>program omv_norm_demo;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  typ,\n  omv;\n\nvar\n  vector_a: array[0..3] of ArbFloat = (0, 1, 2, -3);\n  matrix_b: array[0..3, 0..1] of Arbfloat = ((3, -1),\n                                             (-2, 2),\n                                             (0, -1),\n                                             (2, 1));\n  n_vec, n_col_matrix, m_row_matrix, i, j: integer;\n\nbegin\n  // Get length of vector and the size of the matrix\n  n_vec := High(vector_a) - Low(vector_a) + 1;\n  m_row_matrix := High(matrix_b) - Low(matrix_b) + 1;\n  n_col_matrix := High(matrix_b[1]) - Low(matrix_b[1]) + 1;\n\n  Write('Vector a = [');\n  for i := Low(vector_a) to High(vector_a) do\n    Write(vector_a[i]: 5: 0);\n  WriteLn('  ]');\n  WriteLn('        1-norm of vector a: ', omvn1v(vector_a[0], n_vec): 0: 3);\n  WriteLn('        2-norm of vector a: ', omvn2v(vector_a[0], n_vec): 0: 3);\n  WriteLn('  maximum norm of vector a: ', omvnmv(vector_a[0], n_vec): 0: 3);\n  WriteLn;\n\n  WriteLn('Matrix b = ');\n  for i := 0 to m_row_matrix - 1 do\n  begin\n    for j := 0 to n_col_matrix - 1 do\n      Write(matrix_b[i, j]: 5: 0);\n    WriteLn;\n  end;\n  WriteLn('        1-norm of matrix b: ', omvn1m(matrix_b[0, 0], m_row_matrix, n_col_matrix, n_col_matrix): 0: 3);\n  WriteLn('Forbenius norm of matrix b: ', omvnfm(matrix_b[0, 0], m_row_matrix, n_col_matrix, n_col_matrix): 0: 3);\n  WriteLn('  maximum norm of matrix b: ', omvnmm(matrix_b[0, 0], m_row_matrix, n_col_matrix, n_col_matrix): 0: 3);\n\n  WriteLn;\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#determinant-of-a-matrix","title":"Determinant of a Matrix","text":"<p>Coming soon.</p>"},{"location":"docs/advanced/numlib/#inverse-of-a-matrix","title":"Inverse of a Matrix","text":"<p>Let's say we have a square matrix \\( A \\). The matrix \\( A^{-1} \\) is called the inverse of \\( A \\) if, when you multiply \\( A^{-1} \\) by \\( A \\), you get the identity matrix \\( I \\). The identity matrix is special because it has 1s on the diagonal (from the top left to bottom right) and 0s everywhere else.</p> \\[ \\displaystyle{  A^{-1} A = I =       \\begin{bmatrix}        1  &amp;         &amp; 0 \\\\           &amp; \\ddots  &amp;   \\\\        0  &amp;         &amp; 1      \\end{bmatrix}  } \\] <p>The inverse of a matrix only exists if the determinant of \\( A \\) is not zero. If the determinant is zero, \\( A \\) doesn't have an inverse.</p>"},{"location":"docs/advanced/numlib/#using-numlib-to-find-the-inverse","title":"Using NumLib to Find the Inverse","text":"<p>NumLib is a tool that has several ways (called routines) to calculate the inverse of a matrix. Which method it uses depends on what kind of matrix you have. All the routines expect the matrix to be stored in a common way\u2014as a 2D array of real numbers, or a 1D array of numbers arranged in rows and columns.</p> <p>Here are some routines that NumLib uses:</p> <ul> <li>invgen: This routine works for any square matrix.</li> <li>invgsy: This routine works for matrices that are symmetric (meaning the left side mirrors the right side).</li> <li>invgpd: This routine works for symmetric positive definite matrices (a special kind of symmetric matrix).</li> </ul> <pre><code>procedure invgen(n, rwidth: ArbInt; var ai: ArbFloat; var term: ArbInt);   // generic matrix\nprocedure invgsy(n, rwidth: ArbInt; var ai: ArbFloat; var term: ArbInt);   // symmetric matrix\nprocedure invgpd(n, rwidth: ArbInt; var ai: ArbFloat; var term: ArbInt);   // symmetric positive definite matrix\n</code></pre> <p>Parameters</p> <ul> <li>\\( n \\): The size of the matrix.</li> <li>\\( rwidth \\): The width of the rows (usually, this is the same as \\( n \\)).</li> <li>\\( ai \\): The first element of the matrix (the top-left corner).</li> <li>\\( term \\): A number that tells if the calculation was successful:</li> <li>1: Success! The inverse was found.</li> <li>2: The inverse couldn't be found because the matrix is too close to being singular (meaning its determinant is almost zero).</li> <li>3: There was a mistake with the input data (like if \\( n \\) was less than 1). </li> </ul> <p>Example</p> <p>Calculate the inverse of the symmetric matrix.</p> \\[ \\displaystyle{ A =   \\left[  \\begin{array}{rrrr}    5 &amp; 7 &amp; 6 &amp; 5  \\\\    7 &amp; 10 &amp; 8 &amp; 7 \\\\    6 &amp; 8 &amp; 10 &amp; 9 \\\\    5 &amp; 7 &amp; 9 &amp; 10  \\end{array}  \\right]  } \\] <p>Note, this matrix is symmetric and positive definite (the product \\(b^{T} A b\\) with any vector \\(b = [b1, b2, b3]^{T}\\) cannot become zero or negative since all elements of this matrix are positive). Therefore, <code>invgpd</code> is best-suited for this task although the other routines can be used as well (uncomment their calls below).</p> <pre><code>program inverse_matrix;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ, inv, omv;\n\nconst\n  n_mat_size = 4;\n  decimals = 5;\n\nvar\n  // a is the input matrix to be inverted\n  // Note that this is matrix must be symmetric positive definite.\n  mat_a: array[1..n_mat_size, 1..n_mat_size] of ArbFloat = (\n    (5,  7,  6,  5),\n    (7, 10,  8,  7),\n    (6,  8, 10,  9),\n    (5,  7,  9, 10)\n  );\n  mat_b: array[1..n_mat_size, 1..n_mat_size] of Arbfloat;\n  mat_c: array[1..n_mat_size, 1..n_mat_size] of ArbFloat;\n  term: integer = 0;\n  i, j: integer;\n\nbegin\n  // Write input matrix\n  WriteLn('a = ');\n  for i := 1 to n_mat_size do begin\n    for j := 1 to n_mat_size do\n      Write(mat_a[i, j]:10:decimals);\n    WriteLn;\n  end;\n  WriteLn;\n\n  // Store input matrix because it will be overwritten by the inverse of mat_a\n  for i := 1 to n_mat_size do\n    for j := 1 to n_mat_size do\n      mat_b[i, j] := mat_a[i, j];\n\n  // Calculate inverse  -- uncomment the procedure to be used.\n  //invgen(n_mat_size, n_mat_size, mat_a[1, 1], term);\n  //invgsy(n_mat_size, n_mat_size, mat_a[1, 1], term);\n  invgpd(n_mat_size, n_mat_size, mat_a[1, 1], term);\n\n  // Write inverse\n  WriteLn('a^(-1) = ');\n  for i := 1 to n_mat_size do begin\n    for j := 1 to n_mat_size do\n      Write(mat_a[i, j]:10:decimals);\n    WriteLn;\n  end;\n  WriteLn;\n\n  // Check validity of result by multiplying inverse with saved input matrix\n  omvmmm(mat_a[1, 1], n_mat_size, n_mat_size, n_mat_size,\n         mat_b[1, 1], n_mat_size, n_mat_size,\n         mat_c[1, 1], n_mat_size);\n\n  // Write inverse\n  WriteLn('a^(-1) x a = ');\n  for i := 1 to n_mat_size do begin\n    for j := 1 to n_mat_size do\n      Write(mat_c[i, j]:10:decimals);\n    WriteLn;\n  end;\n\n  // Pause console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#unit-sle-solving-systems-of-linear-equations","title":"Unit <code>sle</code> - Solving Systems of Linear Equations","text":"<p>A system of linear equations (or linear system) is a collection of two or more linear equations involving the same set of variables, \\(x_1 ... x_n\\).</p> \\[ \\displaystyle{  \\begin{cases}     a_{11} x_1 + a_{12} x_2 + \\dots + a_{1n} x_n = b_1 \\\\     a_{21} x_1 + a_{22} x_2 + \\dots + a_{2n} x_n = b_n \\\\     \\ \\ \\ \\vdots \\\\     a_{m1} x_1 + a_{m2} x_2 + \\dots + a_{mn} x_n = b_m   \\end{cases}   } \\] <p>In order to find a solution which satisfies all equations simultaneously the system of equations is usually converted to a matrix equation \\(A x = b\\), where</p> \\[ \\displaystyle{       A = \\left [ \\begin{array}{ccc}                   a_{11} &amp; a_{12} &amp; \\dots  &amp; a_{1n} \\\\                   a_{21} &amp; a_{22} &amp; \\dots  &amp; a_{2n} \\\\                   \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\                   a_{m1} &amp; a_{m2} &amp; \\dots  &amp; a_{mn}                 \\end{array}         \\right ],    \\    \\mathbf{x} = \\left [ \\begin{array}{c}                   x_1    \\\\                   x_2    \\\\                   \\vdots \\\\                   x_n                \\end{array}        \\right ],    \\    \\mathbf{b} = \\left [ \\begin{array}{c}                   b_1    \\\\                   b_2    \\\\                   \\vdots \\\\                   b_m                \\end{array}        \\right ]  } \\] <p>NumLib has several procedures to solve the matrix equation depending on the properties of the matrix.</p>"},{"location":"docs/advanced/numlib/#square-matrices","title":"Square Matrices","text":"<p>Pass the matrix to the procedures in the standard NumLib way as the first element of a 2D or 1D array. The 2D array must be dimensioned to contain at least \\(n\\) rows and \\(n\\) columns, the 1D array must contain at least \\(n^2\\) elements.</p> <pre><code>procedure slegen(n, rwidth: ArbInt; var a, b, x, ca: ArbFloat; var term: ArbInt);   // generic matrix\nprocedure slegsy(n, rwidth: ArbInt; var a, b, x, ca: ArbFloat; var term: ArbInt);   // symmetric matrix\nprocedure slegpd(n, rwidth: ArbInt; var a, b, x, ca: ArbFloat; var term: ArbInt);   // symmetric positive definite matrix\n</code></pre> <p>Parameters</p> <p><code>slegen</code> is the General-purpose for any square matrix (Gaussian elimination with partial pivoting).</p> <p><code>slegsy</code> is specialised for symmetric matrices (more stable reduction to tridiagonal form).</p> <p><code>slegpd</code> is optimisedfor symmetric positive definite matrices (Cholesky decomposition).</p> <ul> <li><code>n</code> is the matrix size.</li> <li><code>rwidth</code> is the number of allocated columns (must be <code>n &lt;= rwidth</code>). </li> <li><code>a</code> is the first element of the coefficient matrix (unchanged during calculation). </li> <li><code>b</code> is the constant vector (also unchanged).</li> <li><code>x</code> is where the solution vector will be stored. </li> <li><code>ca</code> indicates solution accuracy.</li> <li><code>term</code> returns an error code:<ul> <li><code>1</code>: Success, solution in <code>x</code>.</li> <li><code>2</code>: Matrix is nearly singular, no solution.</li> <li><code>3</code>: Invalid input, <code>n &lt; 1</code>.</li> </ul> </li> </ul> <p>Example</p> <p>Solve this system of linear equations:</p> \\[ \\displaystyle{  \\begin{cases}     5 x_1 +  7 x_2 +  6 x_3 +  5 x_4 = 57  \\\\     7 x_1 + 10 x_2 +  8 x_3 +  7 x_4 = 79  \\\\     6 x_1 +  8 x_2 + 10 x_3 +  9 x_4 = 88  \\\\     5 x_1 +  7 x_2 +  9 x_3 + 10 x_4 = 86   \\end{cases}   \\qquad \\Rightarrow \\qquad   A=   \\left[     \\begin{array}{rrrr}        5 &amp;  7 &amp;  6 &amp;  5    \\\\        7 &amp; 10 &amp;  8 &amp;  7 \\\\        6 &amp;  8 &amp; 10 &amp;  9 \\\\        5 &amp;  7 &amp;  9 &amp; 10     \\end{array}   \\right]   , \\;   \\mathbf{b} =   \\left[     \\begin{array}{r}       57 \\\\       79 \\\\       88 \\\\       86     \\end{array}   \\right]  } \\] <pre><code>program solve_linear_eq;\n\n{$mode objfpc}{$H+}{$J-}\n\n{\n  This is an example for solving linear equations; A x = b, using slgen in numlib.\n\n  5 x_1 +  7 x_2 +  6 x_3 +  5 x_4 = 57         |5  7 6 5|      |57|\n  7 x_1 + 10 x_2 +  8 x_3 +  7 x_4 = 79  =&gt; A = |7 10 8 7|, b = |79|\n  6 x_1 +  8 x_2 + 10 x_3 +  9 x_4 = 88         |6 8 10 9|      |88|\n  5 x_1 +  7 x_2 +  9 x_3 + 10 x_4 = 86         |5 7 9 10|      |86|\n\n  Lastly, it tests the result, x, by multiplying A x (from slgen's output) and\n  the result must be equal to b.\n  }\n\nuses\n  NumLib,\n  typ,\n  sle,\n  omv;\n\nconst\n  n_col = 4; // n (col) = m (row) for square matrice\n\nvar\n  mat_A: array[1..n_col, 1..n_col] of ArbFloat = (\n  (5, 7, 6,  5),\n  (7, 10, 8, 7),\n  (6, 8, 10, 9),\n  (5, 7, 9, 10));\n  vec_b: array[1..n_col] of ArbFloat = (57, 79, 88, 86);\n  soln_vec_x: array[1..n_col] of ArbFloat;\n  vec_b_test: array[1..n_col] of ArbFloat;\n  ca: ArbFloat;\n  i, j: integer;\n  term: integer;\n\nbegin\n\n  WriteLn('Solve matrix system A x = b');\n  WriteLn;\n\n    // Print mat_A\n    WriteLn('Matrix A = ');\n    for i:= 1 to n_col do begin\n      for j := 1 to n_col do\n        Write(mat_A[i, j]:10:0);\n      WriteLn;\n    end;\n    WriteLn;\n\n    // Print vec_b\n    WriteLn('Vector b = ');\n    for i:= 1 to n_col do\n      Write(vec_b[i]:10:0);\n    WriteLn;\n    WriteLn;\n\n    // Solve - select one of these methods\n    slegen(n_col, n_col, mat_A[1, 1], vec_b[1], soln_vec_x[1], ca, term);\n    //slegsy(n_col, n_col, mat_A[1, 1], vec_b[1], soln_vec_x[1], ca, term);\n    //slegpd(n_col, n_col, mat_A[1, 1], vec_b[1], soln_vec_x[1], ca, term);\n\n  if term = 1 then begin\n      WriteLn('Solution vector x = ');\n      for i:= 1 to n_col do\n        Write(soln_vec_x[i]:10:0);\n      WriteLn;\n      WriteLn;\n\n      omvmmv(mat_A[1,1], n_col, n_col, n_col, soln_vec_x[1], vec_b_test[1]);\n\n      WriteLn('Check result: A x = (must be equal to b)');\n      for i:= 1 to n_col do\n        Write(vec_b_test[i]:10:0);\n      WriteLn;\n    end\n    else\n      WriteLn('Error');\n\n  WriteLn('Press enter key to exit');\n  ReadLn; // Wait for user input before closing\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#band-matrix","title":"Band Matrix","text":"<p><code>slegba</code> is the optimised solution for band matrices, i.e. matrices in which all elements are zero outside a band of width <code>l</code> below and of width <code>r</code> above the main diagonal.</p> <pre><code>procedure slegba(n, l, r: ArbInt; var a, b, x, ca: ArbFloat; var term:ArbInt);\n</code></pre> <p>Warning</p> <p>Note that this routine cannot work with a 2D array.</p> <p>Parameters</p> <ul> <li><code>n</code> is the number of columns and rows of the matrix (it must be a square matrix).</li> <li><code>l</code> is the left bandwidth, i.e. the number of diagonals the band extends below (or to the left of) the main diagonal.</li> <li><code>r</code> is the right bandwidth, i.e. the number of diagonals the band extends above (or to the right of) the main diagonsl.</li> <li><code>a</code> is the first element of a 1D array which contains the elements of the diagonal band, see this.<ul> <li>This array contains only the band elements and is obtained by running across the rows of the band matrix from left to right and top to bottom, starting at \\(A_11\\). </li> <li>It must be dimensioned to contain at least <code>n*(l+1+r) - (r*(r+1)+l*(l+1)) div 2</code> elements. </li> <li>Note that a 2D array cannot be used for this routine.</li> </ul> </li> <li><code>b</code> is the first element of the array containing the constant vector \\(b\\). The array length at least must be equal to \\(n\\). The vector will not be changed during the calculation.</li> <li><code>x</code> is the first element of the array to receive the solution vector \\(x\\). It must be allocated to contain at least \\(n\\) values.</li> <li><code>ca</code> is a parameter to describe the accuracy of the solution.</li> <li><code>term</code> returns an error code:<ul> <li>1 - successful completion, the solution vector \\(x\\) is valid</li> <li>2 - the solution could not have been determined because the matrix is (almost) singular.</li> <li>3 - error in input values: n &lt; 1, l &lt; 0, l &gt;= n, r &lt; 0, or r &gt;= n</li> </ul> </li> </ul> <p>Example</p> <p>Solve this system of linear equations:</p> \\[ \\displaystyle{  \\begin{array}{ccccccc}     5 x_1 &amp; - &amp; 4 x_2 &amp; + &amp;   x_3 &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp; = 0  \\\\    -4 x_1 &amp; + &amp; 6 x_2 &amp; - &amp; 4 x_3 &amp; + &amp;   x_4 &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp; = 0  \\\\       x_1 &amp; - &amp; 4 x_2 &amp; + &amp; 6 x_3 &amp; - &amp; 4 x_4 &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp; = 0  \\\\           &amp;   &amp;   x_2 &amp; - &amp; 4 x_3 &amp; + &amp; 6 x_4 &amp; - &amp; 4 x_5 &amp;   &amp;       &amp;   &amp;       &amp; = 1  \\\\           &amp;   &amp;       &amp;   &amp;   x_3 &amp; - &amp; 4 x_4 &amp; + &amp; 6 x_5 &amp; - &amp; 4 x_6 &amp; + &amp;   x_7 &amp; = 0  \\\\           &amp;   &amp;       &amp;   &amp;       &amp;   &amp;   x_4 &amp; - &amp; 4 x_5 &amp; + &amp; 6 x_6 &amp; - &amp; 4 x_7 &amp; = 0  \\\\           &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp;   &amp;   x_5 &amp; - &amp; 4 x_6 &amp; + &amp; 5 x_7 &amp; = 0  \\\\   \\end{array}   \\qquad \\Rightarrow \\qquad   A=   \\left[     \\begin{array}{rrrr}        5 &amp; -4 &amp;  1 &amp;  0 &amp;  0 &amp;  0 &amp;  0  \\\\       -4 &amp;  6 &amp; -4 &amp;  1 &amp;  0 &amp;  0 &amp;  0  \\\\        1 &amp; -4 &amp;  6 &amp; -4 &amp;  1 &amp;  0 &amp;  0  \\\\        0 &amp;  1 &amp; -4 &amp;  6 &amp; -4 &amp;  1 &amp;  0  \\\\        0 &amp;  0 &amp;  1 &amp; -4 &amp;  6 &amp; -4 &amp;  1  \\\\        0 &amp;  0 &amp;  0 &amp;  1 &amp; -4 &amp;  6 &amp; -4  \\\\        0 &amp;  0 &amp;  0 &amp;  0 &amp;  1 &amp; -4 &amp;  5     \\end{array}   \\right]   , \\;   \\mathbf{b} =   \\left[     \\begin{array}{r}       0 \\\\       0 \\\\       0 \\\\       1 \\\\       0 \\\\       0 \\\\       0     \\end{array}   \\right]  } \\] <pre><code>program solve_band;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ, sle, omv;\n\nconst\n  n = 7;  // For Square matrices, n_col = m_row\n  L = 2;  // Number of diagonals the band extends below (or to the left of) the main diagonal.\n  R = L;  // Number of diagonals the band extends above (or to the right of) the main diagonal.\n  n_band_elements = n * (L + 1 + R) - (L * (L + 1) + R * (R + 1)) div 2;\n\nvar\n  // Band elements arranged in rows, elements outside of the band omitted!\n  mat_a_band_elements: array[1..n_band_elements] of Arbfloat = (\n             5, -4, 1,\n         -4, 6, -4, 1,\n      1, -4, 6, -4, 1,\n      1, -4, 6, -4, 1,\n      1, -4, 6, -4, 1,\n      1, -4, 6, -4,\n      1, -4, 5\n    );\n  vec_b: array[1..n] of ArbFloat = (\n    0, 0, 0, 1, 0, 0, 0\n  );\n  soln_vec_x: array[1..n] of ArbFloat;\n  mat_a_test: array[1..n, 1..n] of ArbFloat;\n  vec_b_test: array[1..n] of ArbFloat;\n  ca: ArbFloat;\n  i, j, k: integer;\n  term: integer;\n\nbegin\n  WriteLn('Solve matrix system A x = b where A is a band matrix');\n  WriteLn;\n\n  // Write diagonal elements\n  WriteLn('Matrix A:');\n  WriteLn('  n = ', n);\n  Writeln('  Left band width L = ', L);\n  WriteLn('  Right band width R = ', R);\n  WriteLn('  Diagonal elements of A = ');\n  for k := 1 to n_band_elements do\n    Write(mat_a_band_elements[k]:5:0);\n  WriteLn;\n  WriteLn;\n\n  // Solve\n  slegba(n, l, r, mat_a_band_elements[1], vec_b[1], soln_vec_x[1], ca, term);\n\n  if term = 1 then begin\n    // Optional -- Test if tyhe result of matrix A with the solution vector x equals to vector b.\n    // Since mutliplication of a matrix stored like a band matrix is quite\n    // cumbersome we copy the band matrix into a standard matrix.\n    FillChar(mat_a_test, SizeOf(mat_a_test), 0);\n    k := 1;\n    for i:=1 to L do\n      for j := i-L to i+R do\n        if (j &gt;= 1) and (j &lt;= n) then begin\n          mat_a_test[i,j] := mat_a_band_elements[k];\n          inc(k);\n        end;\n\n    for i:= L+1 to n-R do\n      for j := i-L to i+R do begin\n        mat_a_test[i,j] := mat_a_band_elements[k];\n        inc(k);\n      end;\n    for i := n-R+1 to n do\n      for j := i-L to i+R do\n        if j &lt;= n then begin\n          mat_a_test[i,j] := mat_a_band_elements[k];\n          inc(k);\n        end;\n\n    // Optional -- Print matrix A\n    WriteLn('Matrix A =');\n    for i:=1 to n do begin\n      for j:=1 to n do\n        Write(mat_a_test[i,j]:5:0);\n      WriteLn;\n    end;\n    WriteLn;\n\n    // Optional -- Print Vector b\n    WriteLn('Vector b = ');\n    for i:= 1 to n do\n      Write(vec_b[i]:10:0);\n    WriteLn;\n    WriteLn;\n\n    // Print solution\n    WriteLn('Solution: vector x = ');\n    for i:= 1 to n do\n      Write(soln_vec_x[i]:10:3);\n    WriteLn;\n    WriteLn;\n\n    // Optional -- Double-check result by multiply mat_a_text and the soln_vec_x\n    // The result should be the same as vec_b\n    omvmmv(mat_a_test[1,1], n, n, n, soln_vec_x[1], vec_b_test[1]);\n\n    WriteLn('Check result: A x = (must be equal to b)');\n    for i:= 1 to n do\n      Write(vec_b_test[i]:10:0);\n    WriteLn;\n  end\n  else\n    WriteLn('Error');\n\n\n  // Pause console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#symmetric-positive-definite-band-matrix","title":"Symmetric Positive Definite Band Matrix","text":"<p><code>slegpb</code> is the optimised solution for symmetric positive band matrices.</p> <pre><code>procedure slegpb(n, w: ArbInt; var a, b, x, ca: ArbFloat; var term: ArbInt);\n</code></pre> <p>Warning</p> <p>Note that this routine cannot work with a 2D array.</p> <p>Parameters</p> <ul> <li><code>n</code> is the number of rows and columns in the matrix (the matrix must be square).</li> <li><code>w</code> is the bandwidth (one-sided), which is the number of diagonals that extend below (or to the left of) the main diagonal. This value is also the number of diagonals that extend above (or to the right of) the main diagonal.</li> <li><code>a</code> points to the first element of a 1D array that contains the elements of the diagonal band. <ul> <li>This array holds only the band elements and is constructed by traversing the rows of the band matrix from top-left to bottom-right, stopping at the main diagonal. </li> <li>As a result, it contains only the left band and the main diagonal elements.</li> <li>The array must be dimensioned to hold at least <code>n*(w+1) - (w*(w+1)) div 2</code> elements. </li> <li>Note that this routine cannot work with a 2D array.</li> </ul> </li> <li><code>b</code> points to the first element of the array holding the constant vector \\(b\\). The length of this array must be at least \\(n\\), and the vector remains unchanged during the computation.</li> <li><code>x</code> is the first element of the array where the solution vector \\(x\\) will be stored. It must be large enough to hold at least <code>n</code> values. If term is not equal to 1, the solution array may contain invalid data.</li> <li><code>ca</code> specifies the accuracy of the solution.</li> <li><code>term</code> is an error code that indicates the result of the calculation:<ul> <li>1: The computation was successful, and the solution vector \\(x\\) is valid.</li> <li>2: The matrix is (nearly) singular, so a solution could not be determined.</li> <li>3: There was an error in the input values (e.g., <code>n &lt; 1</code>, <code>w &lt; 0</code>, or <code>w &gt;= n</code>).</li> </ul> </li> </ul> <p>Example</p> <p>Solve this system of linear equations.</p> \\[ \\displaystyle{  \\begin{array}{ccccccc}     5 x_1 &amp; - &amp; 4 x_2 &amp; + &amp;   x_3 &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp; = 0  \\\\    -4 x_1 &amp; + &amp; 6 x_2 &amp; - &amp; 4 x_3 &amp; + &amp;   x_4 &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp; = 0  \\\\       x_1 &amp; - &amp; 4 x_2 &amp; + &amp; 6 x_3 &amp; - &amp; 4 x_4 &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp; = 0  \\\\           &amp;   &amp;   x_2 &amp; - &amp; 4 x_3 &amp; + &amp; 6 x_4 &amp; - &amp; 4 x_5 &amp;   &amp;       &amp;   &amp;       &amp; = 1  \\\\           &amp;   &amp;       &amp;   &amp;   x_3 &amp; - &amp; 4 x_4 &amp; + &amp; 6 x_5 &amp; - &amp; 4 x_6 &amp; + &amp;   x_7 &amp; = 0  \\\\           &amp;   &amp;       &amp;   &amp;       &amp;   &amp;   x_4 &amp; - &amp; 4 x_5 &amp; + &amp; 6 x_6 &amp; - &amp; 4 x_7 &amp; = 0  \\\\           &amp;   &amp;       &amp;   &amp;       &amp;   &amp;       &amp;   &amp;   x_5 &amp; - &amp; 4 x_6 &amp; + &amp; 5 x_7 &amp; = 0  \\\\   \\end{array}   \\qquad \\Rightarrow \\qquad   A=   \\left[     \\begin{array}{rrrr}        5 &amp; -4 &amp;  1 &amp;  0 &amp;  0 &amp;  0 &amp;  0  \\\\       -4 &amp;  6 &amp; -4 &amp;  1 &amp;  0 &amp;  0 &amp;  0  \\\\        1 &amp; -4 &amp;  6 &amp; -4 &amp;  1 &amp;  0 &amp;  0  \\\\        0 &amp;  1 &amp; -4 &amp;  6 &amp; -4 &amp;  1 &amp;  0  \\\\        0 &amp;  0 &amp;  1 &amp; -4 &amp;  6 &amp; -4 &amp;  1  \\\\        0 &amp;  0 &amp;  0 &amp;  1 &amp; -4 &amp;  6 &amp; -4  \\\\        0 &amp;  0 &amp;  0 &amp;  0 &amp;  1 &amp; -4 &amp;  5     \\end{array}   \\right]   , \\;   \\mathbf{b} =   \\left[     \\begin{array}{r}       0 \\\\       0 \\\\       0 \\\\       1 \\\\       0 \\\\       0 \\\\       0     \\end{array}   \\right]  } \\] <pre><code>program solve_spd;    // \"spd\" = symmetric positive definite\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ, sle, omv;\n\nconst\n  n = 7;\n  w = 2;\n  n_band_elements = n * (w + 1) - (w * (w + 1)) div 2;\n\nvar\n  // Band elements arranged in rows\n  // Elements outside of the band as well as right diagonals are omitted!\n  mat_a: array[1..n_band_elements] of Arbfloat = (\n             5,\n            -4, 6,\n             1, -4, 6,\n                 1, -4, 6,\n                     1, -4, 6,\n                       1, -4, 6,\n                          1, -4, 5\n    );\n  vec_b: array[1..n] of ArbFloat = (\n    0, 0, 0, 1, 0, 0, 0\n  );\n  soln_vec_x: array[1..n] of ArbFloat;\n  mat_a_test: array[1..n, 1..n] of ArbFloat;\n  vec_b_test: array[1..n] of ArbFloat;\n  ca: ArbFloat;\n  i, j, k: integer;\n  term: integer;\n\nbegin\n  WriteLn('Solve matrix system A x = b where A is a symmetric positive definite band matrix');\n  WriteLn;\n\n  // Write diagonal elements\n  WriteLn('Matrix A:');\n  WriteLn('  n = ', n);\n  Writeln('  (One-sided) band width w = ', w);\n  WriteLn('  Diagonal elements of A = ');\n  for k := 1 to n_band_elements do\n    Write(mat_a[k]:5:0);\n  WriteLn;\n  WriteLn;\n\n  // Solve\n  slegpb(n, w, mat_a[1], vec_b[1], soln_vec_x[1], ca, term);\n\n  if term = 1 then begin\n    // To test the result we multiply a with the solution vector x and check\n    // whether the result is equal to b.\n    // Since mutliplication of a matrix stored like a band matrix is quite\n    // cumbersome we copy the band matrix into a standard matrix.\n    FillChar(mat_a_test, SizeOf(mat_a_test), 0);\n    i := 1;\n    k := 1;\n    while (k &lt;= n_band_elements) and (i &lt;= n) do begin\n      for j := i - w to i do\n        if (j &gt;= 1) and (j &lt;= n) then begin\n          mat_a_test[i, j] := mat_a[k];\n          mat_a_test[j, i] := mat_a[k];\n          inc(k);\n        end;\n      inc(i);\n    end;\n\n    // Print mat_a\n    WriteLn('Matrix A =');\n    for i:=1 to n do begin\n      for j:=1 to n do\n        Write(mat_a_test[i,j]:5:0);\n      WriteLn;\n    end;\n    WriteLn;\n\n    // Print vec_b\n    WriteLn('Vector b = ');\n    for i:= 1 to n do\n      Write(vec_b[i]:10:0);\n    WriteLn;\n    WriteLn;\n\n    // Print solution vec_x\n    WriteLn('Solution: vector x = ');\n    for i:= 1 to n do\n      Write(soln_vec_x[i]:10:3);\n    WriteLn;\n    WriteLn;\n\n    omvmmv(mat_a_test[1,1], n, n, n, soln_vec_x[1], vec_b_test[1]);\n\n    WriteLn('Check result: A x = (must be equal to b)');\n    for i:= 1 to n do\n      Write(vec_b_test[i]:10:3);\n    WriteLn;\n  end\n  else\n    WriteLn('Error');\n\n  // Pause Console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#tridiagonal-matrix","title":"Tridiagonal Matrix","text":"<p>NumLib provides two special procedures to solve linear equations based on a tridiagonal matrix. These procedures use an efficient way to store tridiagonal matrices, with slight differences in their calculation methods and handling of certain cases.</p> <pre><code>sledtr(n: ArbInt; var l, d, u, b, x: ArbFloat; var term: ArbInt)\nslegtr(n: ArbInt; var l, d, u, b, x, ca: ArbFloat; var term: ArbInt)\n</code></pre> <p>Parameters</p> <ul> <li><code>n</code> is the number of unknown variables. It must be the same as the number of columns and rows of the coefficent matrix.</li> <li><code>l</code> specifies the first element in the subdiagonal of the matrix \\(A\\). This 1D array must be dimensioned to at least <code>n-1</code> elements.</li> <li><code>d</code> specifies the first element along the main diagonal of the matrix \\(A\\). This 1D array must be dimensioned to contain at least <code>n</code> elements.</li> <li><code>u</code> specifies the first element along the superdiagonal of the matrix \\(A\\). The array must be dimensioned to have at least <code>n-1</code> elements.</li> <li><code>b</code> is the first element of the array containing the constant vector \\(b\\). The array length at least must be equal to <code>n</code>. The vector will not be changed during the calculation.</li> <li><code>x</code> is the first element of the array to receive the solution vector \\(x\\). It must be allocated to contain at least <code>n</code> values.</li> <li><code>ca</code> is a parameter to describe the accuracy of the solution.</li> <li><code>term</code> returns an error code:<ul> <li><code>1</code> - successful completion, the solution vector \\(x\\) is valid</li> <li><code>2</code> - the solution could not have been determined because the matrix is (almost) singular.</li> <li><code>3</code> - error in input values: <code>n &lt; 1</code>.</li> </ul> </li> </ul> <p>The <code>sledtr</code> routine is numerically stable if matrix \\(A\\) fulfills one of these conditions:</p> <ul> <li>Matrix \\(A\\) is regular (i.e. its inverse matrix exists), and \\(A\\) is columnar-diagonally dominant, this means:<ul> <li>|d1| \u2265 |l2|,</li> <li>|di| \u2265 |ui-1| + |li+1|, i = 2, ..., n-1,</li> <li>|dn| \u2265 |un-1|</li> </ul> </li> <li>Matrix \\(A\\) is regular, and \\(A\\) is diagonally dominant, this means:<ul> <li>|d1| \u2265 |l2|,</li> <li>|di| \u2265 |ui| + |li|, i = 2, ..., n-1,</li> <li>|dn| \u2265 |un|</li> </ul> </li> <li>Matrix \\(A\\) is symmetric and positive-definite.</li> </ul> <p>Note, the <code>sledtr</code> routine does not provide the parameter <code>ca</code> from which the accuracy of the determined solution can be evaluated. If this is needed the (less stable) procedure <code>slegtr</code> must be used.</p> <p>Example</p> <p>Solve this tridiagonal system of linear equations where \\(n=8\\).</p> \\[ \\displaystyle{  \\begin{cases}    188 x_1 - 100 x_2                    = 0   \\\\    -100 x_1 + 188 x_2 -100 x_3          = 0 \\\\    \\vdots  \\\\    -100 x_{n-2} + 188 x_{n-1} - 100 x_n = 0 \\\\              -100 x_{n-1} + 188 x_n               = 0    \\end{cases}   \\qquad \\Rightarrow \\qquad   A=   \\left[     \\begin{array}{rrrrr}        188 &amp; -100   &amp;        &amp;        &amp; 0    \\\\       -100 &amp;  188   &amp; -100   &amp;        &amp;      \\\\            &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp;      \\\\            &amp;        &amp; -100   &amp;   188  &amp; -100 \\\\            &amp;        &amp;        &amp;  -100  &amp;  188 \\\\     \\end{array}   \\right]   , \\;   \\mathbf{b} =   \\left[     \\begin{array}{r}        88 \\\\       -12 \\\\       \\vdots \\\\       -12 \\\\        88     \\end{array}   \\right]  } \\] <pre><code>program solve_tridiag_matrix;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ, sle;\n\nconst\n  n = 8;\n\nvar\n  u_super_diag_items: array[1..n-1] of ArbFloat = (-100, -100, -100, -100, -100, -100, -100      );\n  d_diag_items      : array[1..n]   of ArbFloat = ( 188,  188,  188,  188,  188,  188,  188,  188);\n  l_sub_diag_items  : array[1..n-1] of ArbFloat = (      -100, -100, -100, -100, -100, -100, -100);\n  vec_b             : array[1..n]   of ArbFloat = (  88,  -12,  -12,  -12,  -12,  -12,  -12,   88);\n  soln_vec_x: array[1..n] of ArbFloat;\n  ca: ArbFloat;\n  i, term: integer;\n  vec_b_test: array[1..n] of ArbFloat;\n\nbegin\n  WriteLn('Solve tridiagonal matrix system A x = b');\n  WriteLn;\n\n  Write('Superdiagonal of A:':25);\n  for i := 1 to n-1 do\n    Write(u_super_diag_items[i]:10:0);\n  WriteLn;\n\n  Write('Main diagonal of A:':25);\n  for i:= 1 to n do\n    Write(d_diag_items[i]:10:0);\n  WriteLn;\n\n  Write('Subdiagonal of A:':25);\n  Write('':10);\n  for i:=2 to n do\n    Write(l_sub_diag_items[i]:10:0);\n  WriteLn;\n\n  Write('Vector b:':25);\n  for i:=1 to n do\n    Write(vec_b[i]:10:0);\n  WriteLn;\n\n  // Solve for vector x\n  slegtr(n, l_sub_diag_items[2], d_diag_items[1], u_super_diag_items[1], vec_b[1], soln_vec_x[1], ca, term);\n  // Alternatively,\n  // sledtr(n, l_sub_diag_items[2], d_diag_items[1], u_super_diag_items[1], vec_b[1], soln_vec_x[1], term);\n\n\n  if term = 1 then begin\n    Write('Solution vector x:':25);\n    for i:= 1 to n do\n      Write(soln_vec_x[i]:10:0);\n    WriteLn;\n\n    // Multiply A with soln_vec_x to test the result\n    // NumLib does not have a routine to multiply a tridiagonal matrix with a\n    // vector... Let's do it manually.\n    vec_b_test[1] := d_diag_items[1]*soln_vec_x[1] + u_super_diag_items[1]*soln_vec_x[2];\n    for i := 2 to n-1 do\n      vec_b_test[i] := l_sub_diag_items[i]*soln_vec_x[i-1] + d_diag_items[i]*soln_vec_x[i] + u_super_diag_items[i]*soln_vec_x[i+1];\n    vec_b_test[n] := l_sub_diag_items[n]*soln_vec_x[n-1] + d_diag_items[n]*soln_vec_x[n];\n\n    Write('Check b = A x:':25);\n    for i:= 1 to n do\n      Write(vec_b_test[i]:10:0);\n    WriteLn;\n  end\n  else\n    WriteLn('Error');\n\n  // Pause Console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#overdetermined-systems-least-squares","title":"Overdetermined Systems (Least Squares)","text":"<p>Unlike other routines in the sle unit that require a square matrix \\(A\\), <code>slegls</code> can solve systems with a rectangular matrix, where there are more equations than unknowns. These systems usually can't be solved exactly. However, an approximate solution can minimize the sum of squared residuals, i.e. the norm \\(\\displaystyle{ \\|\\mathbf{b} - A \\mathbf{x}\\|_2 }\\) is as small as possible. This method is commonly used for fitting equations to data (regression analysis).</p> <pre><code>procedure slegls(var a: ArbFloat; m, n, rwidtha: ArbInt; var b, x: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li><code>a</code> is the first element of an array of matrix \\(A\\). The array won't be modified.</li> <li><code>m</code> is the number of rows in matrix \\(A\\) (i.e., the number of equations).</li> <li><code>n</code> is the number of columns in matrix \\(A\\) (i.e., the number of unknown variables). <ul> <li>Note: \\(n\\) must not exceed \\(m\\).</li> </ul> </li> <li><code>rwidtha</code> specifies the allocated number of columns for matrix \\(A\\), which can be larger than needed, with \\(n\u2264rwidth\\).</li> <li><code>b</code> is the first element of vector \\(b\\), with a lenth matching \\(m\\), though it can be allocated larger.</li> <li><code>x</code> is the first element of the array for the solution vector \\(x\\), with length matching \\(n\\), though it can also be allocated larger.</li> <li><code>term</code> returns an error code:<ul> <li>1 - Success, solution \\(x\\) is valid</li> <li>2 - No clear solution due to linearly dependent columns.</li> <li>3 - Input error: <code>n &lt; 1</code>, or <code>n &gt; m</code>.</li> </ul> </li> </ul> <p>The method uses Householder transformation to reduce \\(A\\) to an upper triangular form.</p> <p>Example</p> <p>Find the least-squares solution for the system \\(A x = b\\) of 4 equations and 3 unknowns.</p> \\[ \\displaystyle{  A=  \\left(  \\begin{array}{rrr}   1 &amp; 0 &amp; 1 \\\\   1 &amp; 1 &amp; 1 \\\\   0 &amp; 1 &amp; 0 \\\\   1 &amp; 1 &amp; 0  \\end{array}  \\right), \\ \\  b=  \\left(  \\begin{array}{r}  21 \\\\ 39 \\\\ 21 \\\\ 30  \\end{array}  \\right).  } \\] <pre><code>program solve_leastsquares;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ,\n  sle,\n  omv;\n\nconst\n  m_row = 4;\n  n_col = 3;\n\nvar\n  mat_A: array[1..m_row, 1..n_col] of ArbFloat = (\n     (1, 0, 1),\n     (1, 1, 1),\n     (0, 1, 0),\n     (1, 1, 0));\n  vec_b: array[1..m_row] of ArbFloat = (21, 39, 21, 30);\n  soln_vec_x: array[1..n_col] of ArbFloat;\n  term: ArbInt;\n  i, j: integer;\n  vec_b_test: array[1..m_row] of ArbFloat;\n  sum: ArbFloat;\n\nbegin\n  WriteLn('Solve A x = b with the least-squares method');\n  WriteLn;\n\n  // Display input data\n  WriteLn('A = ');\n  for i := 1 to m_row do\n  begin\n    for j := 1 to n_col do\n      Write(mat_A[i, j]: 10: 0);\n    WriteLn;\n  end;\n  WriteLn;\n  WriteLn('b = ');\n  for i := 1 to m_row do\n    Write(vec_b[i]: 10: 0);\n  WriteLn;\n\n  // Calculate and show solution\n  slegls(mat_A[1, 1], m_row, n_col, n_col, vec_b[1], soln_vec_x[1], term);\n\n  WriteLn;\n  WriteLn('Solution x = ');\n  for j := 1 to n_col do\n    Write(soln_vec_x[j]: 10: 0);\n  WriteLn;\n\n  // Calculate and display residuals\n  WriteLn;\n  WriteLn('Residuals A x - b = ');\n  sum := 0;\n  omvmmv(mat_A[1, 1], m_row, n_col, n_col, soln_vec_x[1], vec_b_test[1]);\n  for i := 1 to m_row do\n  begin\n    Write((vec_b_test[i] - vec_b[i]): 10: 0);\n    sum := sum + sqr(vec_b_test[i] - vec_b[i]);\n  end;\n  WriteLn;\n\n  // Sum of squared residuals\n  WriteLn;\n  WriteLn('Sum of squared residuals');\n  WriteLn(sum: 10: 0);\n\n  WriteLn;\n  WriteLn('----------------------------------------------------------------------------');\n  WriteLn;\n\n  // Modify solution to show that the sum of squared residuals increases';\n  WriteLn('Modified solution x'' (to show that it has a larger sum of squared residuals)');\n  soln_vec_x[1] := soln_vec_x[1] + 1;\n  soln_vec_x[2] := soln_vec_x[2] - 1;\n  WriteLn;\n  for j := 1 to n_col do\n    Write(soln_vec_x[j]: 10: 0);\n  omvmmv(mat_A[1, 1], m_row, n_col, n_col, soln_vec_x[1], vec_b_test[1]);\n  sum := 0;\n  for i := 1 to m_row do\n    sum := sum + sqr(vec_b_test[i] - vec_b[i]);\n  WriteLn;\n  WriteLn;\n  WriteLn('Sum of squared residuals');\n  WriteLn(sum: 5: 0);\n  WriteLn;\n\n  // Pause Console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>The output is:</p> <pre><code>Solve A x = b with the least-squares method\n\nA =\n    1    0    1\n    1    1    1\n    0    1    0\n    1    1    0\n\nb =\n   21   39   21   30\n\nSolution x =\n   10   20   10\n\nResiduals A x - b =\n   -1    1   -1   -0\n\nSum of squared residuals\n    3\n\n----------------------------------------------------------------------------\n\nModified solution x' (to show that it has a larger sum of squared residuals)\n\n   11   19   10\n\nSum of squared residuals\n    5\n</code></pre>"},{"location":"docs/advanced/numlib/#why-calculate-the-sum-of-squared-residuals-and-why-modify-the-solution-to-increase-the-sum-of-squared-residuals","title":"Why Calculate the Sum of Squared Residuals and Why Modify the Solution to Increase the Sum of Squared Residuals?","text":"<p>Why Calculate the Sum of Squared Residuals?</p> <p>The sum of squared residuals is a measure of how well the computed solution fits the data. It tells us how far off the computed values (from \\(A \u00d7 x\\)) are from the actual values in \\(b\\).</p> <p>In a least-squares solution, this sum is minimised. By calculating it, the code verifies how close the solution is to the actual results. A smaller sum of squared residuals means a better fit.</p> \\[ Sum\\_of\\_Squared\\_Residuals=(-1)^{2} + (1)^{2} + (-1)^{2} + 0^{2}=3 \\] <p>A smaller sum indicates a better fit. In this case, a sum of 3 is reasonable and shows that the solution is a close approximation.</p> <p>What about the residual of \\((-1, 1, -1, 0)\\)?</p> <p>The residuals \\(A \u00d7 x - b\\) being \\((-1, 1, -1, 0)\\) indicate that the least-squares solution is a close approximation, but not perfect.</p> <p>However, in an over-determined system (more equations than unknowns, as here with 4 equations and 3 unknowns), an exact solution is usually not possible. The least-squares method tries to find a solution \\(x\\) that minimizes the sum of the squared residuals.</p> <p>This means that, when solving the system, the predictions for some rows of \\(b\\) are slightly off:</p> <ul> <li>The first equation is off by -1 (under-predicted).</li> <li>The second equation is off by 1 (over-predicted).</li> <li>The third equation is off by -1 (under-predicted).</li> <li>The fourth equation is off by 0 (almost perfect prediction).</li> </ul> <p>Why Modify the Solution to Increase the Sum of Squared Residuals?</p> <p>In the second part of the code, the solution vector \\(x\\) is manually modified:</p> <pre><code>x[1] := x[1] + 1;\nx[2] := x[2] - 1;\n</code></pre> <p>This shows what happens if the solution is perturbed. By changing \\(x\\), the code     demonstrates that the sum of squared residuals increases:</p> <pre><code>sum := sum + sqr(b_test[i] - b[i]);\nWriteLn('Sum of squared residuals');\nWriteLn(sum:5:0);\n</code></pre> <p>The point of this modification is to highlight the importance of the least-squares solution. The original solution minimizes the residuals, but altering the solution results in a worse fit (higher residuals).</p> <p>Deviating from the least-squares solution results in a higher sum of squared residuals, indicating a poorer fit.</p>"},{"location":"docs/advanced/numlib/#unit-eig-eigenvalues-and-eigenvectors","title":"Unit <code>eig</code> - Eigenvalues and eigenvectors","text":"<p>An eigenvector is a special type of vector that keeps its direction even when a linear transformation (like multiplying by a matrix) is applied to it.When you multiply a square matrix \\(A\\) by a non-zero vector \\(x\\) and the result is the same vector multiplied by a number (called a scalar), then:   - \\(x\\) is the eigenvector   - The number is called the eigenvalue (represented by \\(\u03bb\\)).</p> \\[ \\displaystyle{  A \\mathbf{x} = \\lambda \\mathbf{x}  \\qquad \\Rightarrow \\qquad  A \\mathbf{x} - \\lambda \\mathbf{x} = 0   } \\] <p>NumLib has tools to calculate eigenvalues and eigenvectors for different types of matrices. Each matrix type has two to four procedures with numbers 1 to 4 that indicate their complexity:</p> <ul> <li>Procedures with \"1\": Calculate all eigenvalues.</li> <li>Procedures with \"2\": Calculate specific eigenvalues in a certain range.</li> <li>Procedures with \"3\": Calculate all eigenvalues and eigenvectors.</li> <li>Procedures with \"4\": Calculate specific eigenvalues and eigenvectors in a certain range.</li> </ul>"},{"location":"docs/advanced/numlib/#matrices-with-general-storage","title":"Matrices with General Storage","text":"<p>The routines assume the \\(n \\times n\\) matrix is stored as a 2D (or 1D) array of ArbFloat values.</p> <p>For Generic Matrices</p> <ul> <li>eigge1: Calculates all eigenvalues.</li> <li>eigge3: Calculates all eigenvalues and eigenvectors.</li> </ul> <p>For Generic Symmetric Matrices</p> <ul> <li>eiggs1: Calculates all eigenvalues.</li> <li>eiggs2: Calculates some eigenvalues in a specific range.</li> <li>eiggs3: Calculates all eigenvalues and eigenvectors.</li> <li>eiggs4: Calculates some eigenvalues and eigenvectors in a specific range.</li> </ul> <p>For Symmetric Positive Definite Matrices</p> <ul> <li>eiggg1: Calculates all eigenvalues.</li> <li>eiggg2: Calculates some eigenvalues in a specific range.</li> </ul> <pre><code>// Generic matrix (without any special symmetries)\nprocedure eigge1(var a: ArbFloat; n, rwidth: ArbInt; var lam: complex; var term: ArbInt);                      // all eigenvalues\nprocedure eigge3(var a: ArbFloat; n, rwidtha: ArbInt; var lam, x: complex; rwidthx: ArbInt; var term: ArbInt); // all eigenvalues and eigenvectors\n\n// Generic symmetric matrix\nprocedure eiggs1(var a: ArbFloat; n, rwidth: ArbInt; var lam: ArbFloat; var term: ArbInt);                     // all eigenvalues\nprocedure eiggs2(var a: ArbFloat; n, rwidth, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);             // some eigenvalues (index k1..k2)\nprocedure eiggs3(var a: ArbFloat; n, rwidtha: ArbInt; var lam, x: ArbFloat; var term: ArbInt);                 // all eigenvalues and eigenvectors\nprocedure eiggs4(var a: ArbFloat; n, rwidtha, k1, k2: ArbInt; var lam, x: ArbFloat; var term: ArbInt);         // some eigenvalues and eigenvectors (index k1..k2)\n\n// Symmetric positive definite matrix\nprocedure eiggg1(var a: ArbFloat; n, rwidth: ArbInt; var lam: ArbFloat; var term: ArbInt);                     // all eigenvalues\nprocedure eiggg2(var a: ArbFloat; n, rwidth, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);             // some eigenvalues (index k1..k2)\nprocedure eiggg3(var a: ArbFloat; n, rwidtha: ArbInt; var lam, x: ArbFloat; var term: ArbInt);                 // all eigenvalues and eigenvectors\nprocedure eiggg4(var a: ArbFloat; n, rwidtha, k1, k2: ArbInt; var lam, x: ArbFloat; var term: ArbInt);         // some eigenvalues and eigenvectors (index k1..k2)\n</code></pre> <p>Parameters</p> <ul> <li><code>a</code> is the first element of an array containing the matrix \\(A\\) for which the eigenvalue/eigenvector has to be calculated. <ul> <li>The array must be dimensioned to provide space for at least \\(n^{2}\\) floating point values.</li> </ul> </li> <li><code>n</code> specifies the size of the matrix \\(A\\), i.e. the number of rows or columns. Note that the input matrix must be square, i.e. the number of rows and columns is equal.</li> <li><code>rwidth</code> is the allocated row length of the array a. It can be larger than n if the array is allocated larger than necessary, but normally <code>rwidth = n</code>.</li> <li><code>lam</code> is the first element of an array receiving the calculated eigenvalues. <ul> <li>In case of a generic matrix (<code>eigge1</code>, <code>eigge3</code>) the eigenvalues can be complex; therefore, the array must be dimensioned for values of type <code>complex</code> as declared in unit <code>typ</code>. </li> <li>In the other cases (<code>eiggs1..4</code> or <code>eiggg1..4</code>) the eigenvalues are real, and the array must be dimensioned for datatype <code>ArbFloat</code>. </li> <li>Since a \\(n \\times n\\) matrix has \\(n\\) eigenvalues, the array must be allocated for at least <code>n</code> values, in case of the procedures with appended 2 or 4 only <code>k2-k1+1</code> values are sufficient (see below).</li> </ul> </li> <li><code>term</code> returns an error code:<ul> <li>1 -- successful calculation</li> <li>2 -- calculation failed</li> <li>3 -- error in input data: n&lt;1, k1&lt;1, k1&gt;k2, or k2&gt;n.</li> </ul> </li> </ul> <p>Additionally, in case of <code>eigge3</code>:</p> <ul> <li><code>x</code> is the first element of a matrix to receive the calculated eigenvectors. <ul> <li>Again, the eigenvectors of a generic matrix can have complex components. Therefore, the matrix must be declared for the datatype <code>complex</code>, and it must be large enough to hold at least \\(n^{2}\\) values. </li> <li>If the matrix is symmetric or positive definite, the eigenvectors are real, and the array must be declared for datatype <code>ArbFloat</code>. In any case, the eigenvectors are normalized to unit length and arranged in the columns of this matrix.</li> </ul> </li> <li><code>rwidthx</code> denotes the allocated row length of the matrix \\(x\\). Thus it is possible to dimension the result matrix larger than actually needed.</li> </ul> <p>Additionally, in case of procedures <code>eiggs2</code>, <code>eiggs4</code>, <code>eiggg2</code> and <code>eiggg4</code>:</p> <ul> <li><code>k1</code> and <code>k2</code> define the interval of indexes <code>k</code> for which the eigenvalues (\\(\\lambda k\\)) and eigenvalues (\\(c_k\\)) are to be calculated. They are integers and must be ordered such that \\(1&lt;=k1&lt;=k2&lt;=n\\).</li> </ul> <p>Example</p> <p>Calculate the eigenvalues and eigenvectors of the matrix.</p> \\[ \\displaystyle{  A=              \\begin{bmatrix}                  8 &amp; -1 &amp; -5 \\\\                 -4 &amp;  4 &amp; -2 \\\\                 18 &amp; -5 &amp; -7              \\end{bmatrix}    }    \\] <pre><code>program eig_general_matrix;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, math, typ, eig;\n\nconst\n  n = 3;         // Size of the matrix where m (row) = n (row)\n  dec_place = 3; // No of decimal place\n\nvar\n  // a is the input matrix\n  mat_a: array[1..n, 1..n] of ArbFloat = (\n    ( 8, -1, -5),\n    (-4,  4, -2),\n    (18, -5, -7)\n  );\n  eig_values_lambda: array[1..n] of complex;\n  eig_vec_mat_x: array[1..n, 1..n] of complex;\n  term: integer = 0;\n  i, j: integer;\n\n  function ComplexToStr(z: complex; decimals: integer): String;\n  var\n    sgn: array[boolean] of string = ('+', '-');\n  begin\n    Result := Format('%.*f %s %.*fi', [Decimals, z.Re, sgn[z.Im &lt; 0], Decimals, abs(z.Im)]);\n  end;\n\nbegin\n  // write input matrix\n  WriteLn('Matrix a = ');\n  for i := 1 to n do begin\n    for j := 1 to n do\n      Write(mat_a[i, j]:10:dec_place);\n    WriteLn;\n  end;\n  WriteLn;\n\n  // Calculate eigenvalues/vectors\n  eigge3(mat_a[1,1], n, n, eig_values_lambda[1], eig_vec_mat_x[1,1], n, term);\n\n  // write eigenvalues\n  WriteLn('Eigenvalues: lambda = ');\n  for i := 1 to n do\n    Write(ComplexToStr(eig_values_lambda[i], dec_place):25);\n  WriteLn;\n  WriteLn;\n\n  // Write eigenvectors\n  WriteLn('Eigenvectors (as columns): x = ');\n  for i := 1 to n do begin\n    for j := 1 to n do\n      Write(ComplexToStr(eig_vec_mat_x[i, j], dec_place):25);\n    WriteLn;\n  end;\n\n  // Pause console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>Matrix a =\n     8.000    -1.000    -5.000\n    -4.000     4.000    -2.000\n    18.000    -5.000    -7.000\n\nEigenvalues: lambda =\n           2.000 + 4.000i           2.000 - 4.000i           1.000 + 0.000i\n\nEigenvectors (as columns): x =\n           0.316 + 0.316i           0.316 - 0.316i           0.408 + 0.000i\n           0.000 + 0.632i           0.000 - 0.632i           0.816 + 0.000i\n           0.632 + 0.000i           0.632 + 0.000i           0.408 + 0.000i\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#symmetric-band-matrices","title":"Symmetric Band Matrices","text":"<p>NumLib provides four routines for calculating the eigenvalues and eigenvectors of symmetric band matrices (matrices with non-zero elements in a band around the main diagonal):</p> <ol> <li> <p>eigbs1: Calculates all eigenvalues.    <pre><code>procedure eigbs1(var a: ArbFloat; n, w: ArbInt; var lam: ArbFloat; var term: ArbInt);\n</code></pre></p> </li> <li> <p>eigbs2: Calculates some of the eigenvalues, within a specified range (from index <code>k1</code> to <code>k2</code>).    <pre><code>procedure eigbs2(var a: ArbFloat; n, w, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);\n</code></pre></p> </li> <li> <p>eigbs3: Calculates all eigenvalues and their corresponding eigenvectors.    <pre><code>procedure eigbs3(var a: ArbFloat; n, w: ArbInt; var lam, x: ArbFloat; rwidthx: ArbInt; var term: ArbInt);\n</code></pre></p> </li> <li> <p>eigbs4: Calculates some eigenvalues and their corresponding eigenvectors (within the range <code>k1</code> to <code>k2</code>).    <pre><code>procedure eigbs4(var a: ArbFloat; n, w, k1, k2: ArbInt; var lam, x: ArbFloat; rwidthx: ArbInt; var m2, term: ArbInt);\n</code></pre></p> </li> </ol> <p>Parameters</p> <ul> <li> <p>a: This is the first element of a 1D array that contains the matrix's diagonal and left band elements. The right band is ignored because the matrix is symmetric. The array needs to be large enough to hold at least <code>n*(w+1) - (w*(w+1)) div 2</code> elements.</p> </li> <li> <p>n: The number of rows and columns in the matrix (since the matrix is square).</p> </li> <li> <p>w: The bandwidth, or the number of diagonals the band extends on either side of the main diagonal (the left and right bandwidth must be the same since the matrix is symmetric).</p> </li> <li> <p>lam: The first element of an array where the computed eigenvalues will be stored. Since a matrix of size <code>n x n</code> has <code>n</code> eigenvalues, this array should have space for at least <code>n</code> values of type <code>ArbFloat</code>.</p> </li> <li> <p>x: (Used in <code>eigbs3</code> and <code>eigbs4</code>) The first element of a matrix that will store the computed eigenvectors. The matrix must be large enough to hold at least <code>n x n</code> values and will contain the eigenvectors as columns. These vectors are normalized (scaled to unit length).</p> </li> <li> <p>rwidthx: (Used in <code>eigbs3</code> and <code>eigbs4</code>) The allocated row length for the eigenvector matrix <code>x</code>. This allows the matrix to be larger than needed if desired.</p> </li> <li> <p>k1, k2: (Used in <code>eigbs2</code> and <code>eigbs4</code>) These define the range of eigenvalues and eigenvectors to compute. For example, setting <code>k1 = 1</code> and <code>k2 = 3</code> calculates the first three eigenvalues and their vectors. The values must satisfy <code>1 &lt;= k1 &lt;= k2 &lt;= n</code>.</p> </li> <li> <p>m2: (Used in <code>eigbs4</code>) The index of the largest eigenvalue for which an eigenvector has been computed.</p> </li> <li> <p>term: A return code indicating the result:</p> </li> <li>1: Calculation was successful.</li> <li>2: Calculation failed.</li> <li>3: There was an error in the input parameters, such as <code>n &lt; 1</code>, <code>w &lt; 0</code>, <code>w &gt;= n</code>, <code>k1 &lt; 1</code>, <code>k1 &gt; k2</code>, or <code>k2 &gt; n</code>.</li> </ul> <p>If the bandwidth <code>w</code> is larger than one-third of the matrix size (<code>n/3</code>), it is generally more efficient to compute all eigenvalues and eigenvectors, even if you don't need all of them.</p> <p>Example</p> <p>Calculate the eigenvalues and eigenvectors of the symmetric 7 x 7 matrix </p> \\[ \\displaystyle{  A=  \\begin{bmatrix}   5 &amp; -4 &amp; 1 &amp;  &amp;  &amp;  &amp; 0 \\\\  -4 &amp; 6  &amp; -4 &amp; 1 &amp;  &amp;  &amp;  \\\\   1 &amp; -4 &amp; 6  &amp; -4 &amp; 1 &amp;  &amp;  \\\\    &amp; 1 &amp; -4 &amp; 6 &amp; -4 &amp; 1 &amp;  \\\\    &amp;  &amp; 1 &amp; -4 &amp; 6 &amp; -4 &amp; 1 \\\\    &amp;  &amp;  &amp; 1 &amp; -4 &amp; 6 &amp; -4 \\\\  0 &amp;  &amp;  &amp;  &amp; 1 &amp; -4 &amp; 5  \\end{bmatrix}  } \\] <p>The eigenvalues are </p> \\[ \\displaystyle{ \\lambda_k = 16\\sin^{4}\\frac{k\\pi}{16}, \\qquad k=1,2,\\ldots,7 } \\] <pre><code>program eig_symband_matrix;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, math,\n  typ, eig;\n\nconst\n  n_mat_size = 7;    // Size of the matrix (n x n matrix)\n  w_band_size = 2;   // Bandwidth of the matrix (how many diagonals on either side of the main diagonal)\n\n  // Total number of elements in the 1D array representing the matrix's diagonals\n  n_diag_elements = n_mat_size * (w_band_size + 1) - (w_band_size * (w_band_size + 1)) div 2;\n\n  decimal_place = 3; // Number of decimal places for output\n\n// Converts a matrix index (i, j) into the corresponding 1D array index for a band matrix\nfunction MatrixIndexToArrayIndex(i, j, n, w: Integer): Integer;\n\n  // Calculates the starting index for a given diagonal element\n  function DiagElementIndex(i: Integer): Integer;\n  var\n    k: Integer;\n  begin\n    Result := 1;\n    if i = 1 then\n      exit;\n    // For diagonals truncated at the left side of the matrix\n    for k := 2 to w do begin\n      Result := Result + k;\n      if k = i then\n        exit;\n    end;\n    // For full rows and diagonals truncated on the right side\n    for k := w+1 to n do begin\n      Result := Result + w + 1;\n      if k = i then\n        exit;\n    end;\n    Result := n;\n  end;\n\nvar\n  d: Integer;\nbegin\n  // Ensures that we always access the upper diagonal by swapping (i, j) if necessary\n  if j &gt; i then begin\n    Result := MatrixIndexToArrayIndex(j, i, n, w);\n    exit;\n  end;\n\n  // Get the starting index of the diagonal element in the 1D array\n  Result := DiagElementIndex(i);\n\n  // If i = j, we are on the main diagonal\n  if (i = j) then\n    exit;\n\n  // Calculate the offset for the element in the band\n  d := i - j;\n  if d &gt; w then\n    Result := -1 // Element is outside the bandwidth, return -1 to indicate zero\n  else begin\n    dec(Result, d); // Adjust the index for the diagonal element\n    if (Result &lt; 1) then\n      Result := -1; // Invalid index (out of bounds)\n  end;\nend;\n\nvar\n  // Array to hold the elements of the banded matrix (diagonal and left band)\n  mat_a: array[1..n_diag_elements] of ArbFloat = (\n     5,   // Main diagonal element (row 1, col 1)\n    -4, 6,   // Row 2 (left band and main diagonal)\n     1, -4, 6,   // Row 3 (two left band, main diagonal)\n         1, -4, 6,   // Row 4, (two left band, main diagonal)\n             1, -4, 6,  // Row 5, the same ...\n                 1, -4, 6,\n                     1, -4, 5 );\n\n  // Array to store the calculated eigenvalues\n  eig_values_lambda: array[1..n_mat_size] of ArbFloat;\n\n  // Matrix to store the calculated eigenvectors\n  eig_vectors_mat_x: array[1..n_mat_size, 1..n_mat_size] of ArbFloat;\n\n  term: integer = 0; // Variable for capturing the result of the eigenvalue/eigenvector calculation\n  i, j, k: integer;  // Loop counters\n\nbegin\n  // Display matrix information\n  WriteLn('n = ', n_mat_size);\n  Writeln('(One-sided) band width w = ', w_band_size);\n\n  // Print diagonal elements of the band matrix\n  Write('Diagonal elements of A = ', mat_a[1]:0:0);\n  for k := 2 to n_diag_elements do\n    Write(mat_a[k]:3:0);\n  WriteLn;\n  WriteLn;\n\n  // Reconstruct and display the full symmetric band matrix from the 1D array (for verification purposes)\n  WriteLn('Reconstructed A = ');\n  for i := 1 to n_mat_size do begin\n    for j := 1 to n_mat_size do begin\n      k := MatrixIndexToArrayIndex(i, j, n_mat_size, w_band_size); // Get the 1D array index for the element (i, j)\n      if k = -1 then\n        Write(0.0:3:0) // Print 0 if the element is outside the band\n      else\n        Write(mat_a[k]:3:0); // Print the matrix element\n    end;\n    WriteLn;\n  end;\n  WriteLn;\n\n  // Call NumLib to calculate all eigenvalues and eigenvectors (eigbs3)\n  eigbs3(mat_a[1], n_mat_size, w_band_size, eig_values_lambda[1], eig_vectors_mat_x[1,1], n_mat_size, term);\n\n  // Check if the calculation was successful\n  if term &lt;&gt; 1 then begin\n    WriteLn('term = ', term, ' --&gt; ERROR'); // Error message in case of failure\n    halt;\n  end;\n\n  // Display expected eigenvalues for reference (example)\n  WriteLn('Expected eigenvalues:');\n  for i := 1 to n_mat_size do\n    Write(16 * intpower(sin(i*pi/16), 4):15:decimal_place); // Compute and print expected eigenvalues\n  WriteLn;\n  WriteLn;\n\n  // Print the calculated eigenvalues\n  WriteLn('Calculated eigenvalues: lambda = ');\n  for i := 1 to n_mat_size do\n    Write(eig_values_lambda[i]:15:decimal_place); // Print each eigenvalue\n  WriteLn;\n  WriteLn;\n\n  // Print the calculated eigenvectors (one per column)\n  WriteLn('Eigenvectors (as columns): x = ');\n  for i := 1 to n_mat_size do begin\n    for j := 1 to n_mat_size do\n      Write(eig_vectors_mat_x[i, j]:15:decimal_place); // Print each element of the eigenvector matrix\n    WriteLn;\n  end;\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>n = 7\n(One-sided) band width w = 2\nDiagonal elements of A = 5 -4  6  1 -4  6  1 -4  6  1 -4  6  1 -4  6  1 -4  5\n\nReconstructed A =\n  5 -4  1  0  0  0  0\n -4  6 -4  1  0  0  0\n  1 -4  6 -4  1  0  0\n  0  1 -4  6 -4  1  0\n  0  0  1 -4  6 -4  1\n  0  0  0  1 -4  6 -4\n  0  0  0  0  1 -4  5\n\nExpected eigenvalues:\n          0.023          0.343          1.524          4.000          7.647         11.657         14.805\n\nCalculated eigenvalues: lambda =\n          0.023          0.343          1.524          4.000          7.647         11.657         14.805\n\nEigenvectors (as columns): x =\n         -0.191         -0.354          0.462          0.500          0.462          0.354          0.191\n         -0.354         -0.500          0.354          0.000         -0.354         -0.500         -0.354\n         -0.462         -0.354         -0.191         -0.500         -0.191          0.354          0.462\n         -0.500         -0.000         -0.500          0.000          0.500          0.000         -0.500\n         -0.462          0.354         -0.191          0.500         -0.191         -0.354          0.462\n         -0.354          0.500          0.354         -0.000         -0.354          0.500         -0.354\n         -0.191          0.354          0.462         -0.500          0.462         -0.354          0.191\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#symmetric-tridiagonal-matrices","title":"Symmetric Tridiagonal Matrices","text":"<p>Symmetric tridiagonal matrices can be handled using the following routines: <code>eigts1</code>, <code>eigts2</code>, <code>eigts3</code>, and <code>eigts4</code>.</p> <ol> <li> <p>All Eigenvalues <pre><code>procedure eigts1(var d, cd: ArbFloat; n: ArbInt; var lam: ArbFloat; var term: ArbInt);\n</code></pre>    This procedure computes all eigenvalues of the matrix.</p> </li> <li> <p>Some Eigenvalues (with indices k1..k2) <pre><code>procedure eigts2(var d, cd: ArbFloat; n, k1, k2: ArbInt; var lam: ArbFloat; var term: ArbInt);\n</code></pre>    This computes the eigenvalues within the index range <code>k1</code> to <code>k2</code>.</p> </li> <li> <p>All Eigenvalues and Eigenvectors <pre><code>procedure eigts3(var d, cd: ArbFloat; n: ArbInt; var lam, x: ArbFloat; rwidth: ArbInt; var term: ArbInt);\n</code></pre>    This calculates all eigenvalues and their corresponding eigenvectors.</p> </li> <li> <p>Some Eigenvalues and Eigenvectors (with indices k1..k2) <pre><code>procedure eigts4(var d, cd: ArbFloat; n, k1, k2: ArbInt; var lam, x: ArbFloat; rwidth: ArbInt; var m2, term: ArbInt);\n</code></pre>    This computes eigenvalues and eigenvectors within the specified index range <code>k1</code> to <code>k2</code>.</p> </li> </ol> <p>Parameters</p> <ul> <li>d: A 1D array representing the main diagonal of the matrix. It must contain at least <code>n</code> elements.</li> <li>cd: A 1D array representing the subdiagonal of the matrix. It must have at least <code>n-1</code> elements.</li> <li>n: The size of the matrix (number of rows or columns), which must be square.</li> <li>k1, k2: The index range for the eigenvalues and eigenvectors to be calculated, where <code>1 &lt;= k1 &lt;= k2 &lt;= n</code>.</li> <li>lam: A 1D array to store the calculated eigenvalues. For routines <code>eigts1</code> and <code>eigts3</code>, it must contain at least <code>n</code> elements. For <code>eigts2</code> and <code>eigts4</code>, it only needs to store <code>k2 - k1 + 1</code> elements.</li> <li>x: A 2D array to store the calculated eigenvectors. For <code>eigts3</code>, the array must have at least <code>n^2</code> elements. For <code>eigts4</code>, it must provide space for <code>n * (k2 - k1 + 1)</code> elements. Eigenvectors are normalized to unit length and stored in columns.</li> <li>rwidth: The row length of the matrix <code>x</code>. This allows the result matrix to be dimensioned larger than necessary.</li> <li>term: An error code returned after calculation:</li> <li><code>1</code>: Successful calculation.</li> <li><code>2</code>: Calculation failed.</li> <li><code>3</code>: Error in input data (e.g., <code>n &lt; 1</code>, <code>k1 &lt; 1</code>, <code>k1 &gt; k2</code>, or <code>k2 &gt; n</code>).</li> </ul> <p>This explanation organizes the routines, clearly defines the parameters, and explains the error codes in a structured way for easier understanding.</p> <p>Example</p> <p>Calculate eigenvalues and eigenvectors of the matrix:</p> \\[ \\displaystyle{  A=  \\begin{bmatrix}   1 &amp; 1 &amp; 0 &amp; 0 \\\\   1 &amp; 1 &amp; 2 &amp; 0 \\\\   0 &amp; 2 &amp; 1 &amp; 1 \\\\   0 &amp; 0 &amp; 1 &amp; 1  \\end{bmatrix}  } \\] <p>The expected eigenvalues are:</p> \\[ \\displaystyle{  -\\sqrt{2},\\ 2-\\sqrt{2},\\ \\sqrt{2},\\ 2+\\sqrt{2} } \\] <pre><code>program eig_symtridiag_matrix;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ, eig;\n\nconst\n  n_mat_size = 4;\n\nvar\n  // This var contains the elements of the main diagonal of the input matrix\n  diag_elements: array[1..n_mat_size] of ArbFloat = (1, 1, 1, 1);\n\n  // This var contains the elements of the subdiagonal\n  subdiag_elements: array[2..n_mat_size] of ArbFloat = (1, 2, 1);\n\n  // Array to store the calculated eigenvalues\n  eig_values_lambda: array[1..n_mat_size] of ArbFloat;\n\n  // Matrix to store the calculated eigenvectors\n  eig_vectors_mat_x: array[1..n_mat_size, 1..n_mat_size] of ArbFloat;\n\n  // Variable for capturing the result of the eigenvalue/eigenvector calculation\n  term: integer = 0;\n\n  // Variables for loops\n  i, j, k: integer;\n\nbegin\n\n  // Write elements of diagonal\n  WriteLn('n = ', n_mat_size);\n  Write('Elements of main diagonal = ', diag_elements[1]:0:0);\n  for k := 2 to n_mat_size do\n    Write(diag_elements[k]:3:0);\n  WriteLn;\n\n  // Write elements of sub-diagonal\n  Write('Elements of subdiagonal   = ', ' ':3, subdiag_elements[2]:0:0);\n  for k := 3 to n_mat_size do\n    Write(subdiag_elements[k]:3:0);\n  WriteLn;\n  WriteLn;\n\n  // Write reconstructed band input matrix (not needed for calculation)\n  WriteLn('Reconstructed A = ');\n  for i := 1 to n_mat_size do begin\n    for j := 1 to n_mat_size do begin\n      if j = i then\n        Write(diag_elements[i]:3:0)\n      else if (j = i-1) then\n        Write(subdiag_elements[i]:3:0)\n      else if (j = i+1) then\n        Write(subdiag_elements[i+1]:3:0)\n      else\n        Write(0.0:3:0);\n    end;\n    WriteLn;\n  end;\n  WriteLn;\n\n  // Calculate eigenvalues/vectors\n  eigts3(diag_elements[1], subdiag_elements[2], n_mat_size, eig_values_lambda[1], eig_vectors_mat_x[1,1], n_mat_size, term);\n  if term &lt;&gt; 1 then begin\n    WriteLn('term = ', term, ' --&gt; ERROR');\n    halt;\n  end;\n\n  // Write expected results of eigenvalues\n  WriteLn('Expected eigenvalues:');\n  Write(-sqrt(2):15:3, 2-sqrt(2):15:3, sqrt(2):15:3, 2+sqrt(2):15:3);\n  WriteLn;\n  WriteLn;\n\n  // write eigenvalues\n  WriteLn('Calculated eigenvalues: lambda = ');\n  for i := 1 to n_mat_size do\n    Write(eig_values_lambda[i]:15:3);\n  WriteLn;\n  WriteLn;\n\n  // Write eigenvectors\n  WriteLn('Eigenvectors (as columns): x = ');\n  for i := 1 to n_mat_size do begin\n    for j := 1 to n_mat_size do\n      Write(eig_vectors_mat_x[i, j]:15:3);\n    WriteLn;\n  end;\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>n = 4\nElements of main diagonal = 1  1  1  1\nElements of subdiagonal   =    1  2  1\n\nReconstructed A =\n  1  1  0  0\n  1  1  2  0\n  0  2  1  1\n  0  0  1  1\n\nExpected eigenvalues:\n         -1.414          0.586          1.414          3.414\n\nCalculated eigenvalues: lambda =\n         -1.414          0.586          1.414          3.414\n\nEigenvectors (as columns): x =\n         -0.271         -0.653          0.653          0.271\n          0.653          0.271          0.271          0.653\n         -0.653          0.271         -0.271          0.653\n          0.271         -0.653         -0.653          0.271\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#unit-roo-finding-the-roots-of-a-function","title":"Unit <code>roo</code> - Finding the roots of a function","text":""},{"location":"docs/advanced/numlib/#roots-of-a-polynomial","title":"Roots of a Polynomial","text":"<p>A polynomial of degree <code>n</code> </p> \\[ \\displaystyle{  z^n + a_1 z^{n-1} + a_2 z^{n-2} + ... + a_{n-1} z + a_n = 0 } \\] <p>always has <code>n</code> complex solutions, though they may not all be distinct. The datatype <code>complex</code> is described in the section on complex numbers. You can calculate the roots using the <code>roopol</code> function.</p> <p>Note</p> <p>The polynomial must be normalized, meaning the coefficient of the highest-degree term should be 1.</p> <pre><code>procedure roopol(var a: ArbFloat; n: ArbInt; var z: complex; var k, term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li> <p>a: An array containing the polynomial coefficients, ordered from highest to lowest degree. </p> <ul> <li>The polynomial must be normalized, meaning the coefficient of the highest-degree term should be 1. This coefficient is not included in the array, so the array must have at least <code>n</code> elements. </li> <li>Since only real polynomials are handled, the array elements should be of type <code>ArbFloat</code>. Note: the data organization for this array is different from other polynomial routines in this library.</li> </ul> </li> <li> <p>n: The degree of the polynomial. It must be a positive integer.</p> </li> <li> <p>z: An array of complex values that will store the roots of the polynomial. The array must have at least <code>n</code> elements. The values returned are undefined if an error occurs (i.e., if <code>term &lt;&gt; 1</code>).</p> </li> <li> <p>k: The number of roots found. This value should always equal <code>n</code>; if it doesn't, an error has occurred.</p> </li> <li> <p>term: An error code returned by the function:</p> <ul> <li><code>1</code>: Successful completion, and the array <code>z</code> contains valid root data.</li> <li><code>2</code>: Not all roots were found (<code>k &lt; n</code>).</li> <li><code>3</code>: Error in input data (<code>n &lt; 1</code>).</li> </ul> </li> </ul> <p>Example</p> <p>Calculate the roots of the polynomial \\(z^5 + 3 z^4 + 4 z^3 - 8 z^2\\). The expected zero points are:</p> \\[ \\displaystyle{  z_1=0,\\ z_2=0,\\ z_3=1,\\ z_4=-2+2i,\\ z_5=-2-2i } \\] <pre><code>program solve_root_polynomials;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, typ, roo;\n\nconst\n  n = 5;\n\nvar\n  a: array[1..n] of ArbFloat = (3, 4, -8, 0, 0);\n  z: array[1..n] of complex;\n  k: ArbInt;\n  term: ArbInt;\n  i: integer;\n  c: complex;\n\n  function ComplexToStr(z: complex; Decimals: integer): string;\n  const\n    SIGN: array[boolean] of string = ('+', '-');\n  begin\n    Result := Format('%.*f %s %.*f i', [Decimals, z.re, SIGN[z.im &lt;0], Decimals, abs(z.im)]);\n  end;\n\nbegin\n  // Solve equation\n  roopol(a[1], n, z[1], k, term);\n\n  if term = 1 then begin\n    // Display results\n    WriteLn('Results of procedure roopol:');\n    for i:=1 to n do\n      WriteLn('  Solution #', i, ': ', ComplexToStr(z[i], 6):20);\n    WriteLn;\n\n    // Display expected results\n    Writeln('Expected results:');\n    c.Init(0, 0);  // z1 = 0\n    WriteLn('  Solution #1: ', complexToStr(c, 6):20);\n    c.Init(0, 0);  // z2 = 0\n    WriteLn('  Solution #2: ', complexToStr(c, 6):20);\n    c.Init(1, 0);  // z3 = 1\n    WriteLn('  Solution #3: ', complexToStr(c, 6):20);\n    c.Init(-2, +2);  // z4 = -2 + 2 i\n    WriteLn('  Solution #4: ', complexToStr(c, 6):20);\n    c.Init(-2, -2);  // z4 = -2 - 2 i\n    WriteLn('  Solution #5: ', complexToStr(c, 6):20);\n  end else\n    WriteLn('ERROR');\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#roots-of-a-quadratic-equation","title":"Roots of a Quadratic Equation","text":"<p>A quadratic equation is a polynomial of degree 2. It always has two complex roots, though they may not be distinct. You can find these roots using the <code>rooqua</code> procedure.</p> <pre><code>procedure rooqua(p, q: ArbFloat; var z1, z2: complex);\n</code></pre> <p>Parameters</p> <ul> <li>p: The coefficient of the linear term in the quadratic equation.</li> <li>q: The constant term of the quadratic equation.</li> <li>z1, z2: Variables that will store the two complex roots of the equation. The type <code>complex</code> is declared in the unit <code>typ</code>.</li> </ul> <p><code>rooqua</code> assumes that the quadratic term has been normalized, meaning the coefficient of the quadratic term is set to 1.</p> <p>Example</p> <p>Determine the roots of the equation \\(z^2 + 2 z + 5 = 0\\).</p> <pre><code>program solve_root_quadratic;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, typ, roo;\n\nvar\n  z1, z2: complex;\n\nconst\n  SIGN: array[boolean] of string = ('+', '-');\n\nbegin\n  rooqua(2, 5, z1, z2);\n\n  WriteLn(Format('1st solution: %g %s %g i', [z1.re, SIGN[z1.im &lt; 0], abs(z1.im)]));\n  WriteLn(Format('2nd solution: %g %s %g i', [z2.re, SIGN[z2.im &lt; 0], abs(z2.im)]));\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/advanced/numlib/#roots-of-the-binomial-equation","title":"Roots of the Binomial Equation","text":"<p>The binomial equation \\( z^n = a \\) is a special type of polynomial where all terms except for the highest- and lowest-order terms have zero coefficients. It has <code>n</code> complex solutions, which can be calculated using the <code>roobin</code> procedure.</p> <pre><code>procedure roobin(n: ArbInt; a: complex; var z: complex; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li>n: The exponent in the binomial equation. It must be a positive integer.</li> <li>a: The constant term on the right-hand side of the equation. This is expected to be a complex number (refer to the section on complex numbers).</li> <li>z: An array of type <code>complex</code> that will store the calculated roots. It must have space for at least <code>n</code> complex values.</li> <li>term: An error code returned by the procedure:<ul> <li><code>1</code>: Successful termination.</li> <li><code>2</code>: Error in input data (<code>n &lt; 1</code>).</li> </ul> </li> </ul> <p>Example</p> <p>Calculate the roots of the equation:</p> \\[ \\displaystyle{ z^4 = -1 } \\] <p>The exact solutions are</p> \\[ \\displaystyle{ z_1 = \\frac{1}{2} \\sqrt{2} (1+i) ,\\ z_2 = \\frac{1}{2} \\sqrt{2} (1-i) ,\\ z_3= \\frac{1}{2} \\sqrt{2} (-1+i) ,\\ z_4= \\frac{1}{2} \\sqrt{2} (-1-i) } \\] <pre><code>program solve_root_binomial;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, typ, roo;\n\nconst\n  n = 4;\n\nvar\n  z: array[1..n] of complex;\n  term: ArbInt;\n  i: Integer;\n  a: complex;\n  c: complex;\n\n  function ComplexToStr(z: complex; Decimals: Integer): string;\n  const\n    SIGN: array[boolean] of string = ('+', '-');\n  begin\n    Result := Format('%.*g %s %.*g i', [Decimals, z.re, SIGN[z.im &lt; 0], Decimals, abs(z.im)]);\n  end;\n\nbegin\n  // Prepare constant term as a complex value\n  a.Init(-1, 0);\n\n  // Solve equation\n  roobin(n, a, z[1], term);\n\n  if term = 1 then begin\n    // Display results\n    WriteLn('Results of procedure roobin:');\n    for i:=1 to n do\n      WriteLn('  Solution #', i, ': ', ComplexToStr(z[i], 6):20);\n    WriteLn;\n\n    // Display expected results\n    Writeln('Expected results:');\n    c.Init(1, 1);\n    c.Scale(0.5*sqrt(2));\n    WriteLn('  Solution #1: ', complexToStr(c, 6):20);\n    c.Init(1, -1);\n    c.Scale(0.5*sqrt(2));\n    WriteLn('  Solution #2: ', complexToStr(c, 6):20);\n    c.Init(-1, 1);\n    c.Scale(0.5*sqrt(2));\n    WriteLn('  Solution #3: ', complexToStr(c, 6):20);\n    c.Init(-1, -1);\n    c.Scale(0.5*sqrt(2));\n    WriteLn('  Solution #4: ', complexToStr(c, 6):20);\n  end else\n    WriteLn('ERROR');\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>Results of procedure roobin:\n  Solution #1: 0.707107 + 0.707107 i\n  Solution #2: 0.707107 - 0.707107 i\n  Solution #3: -0.707107 + 0.707107 i\n  Solution #4: -0.707107 - 0.707107 i\n\nExpected results:\n  Solution #1: 0.707107 + 0.707107 i\n  Solution #2: 0.707107 - 0.707107 i\n  Solution #3: -0.707107 + 0.707107 i\n  Solution #4: -0.707107 - 0.707107 i\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#bisection-method","title":"Bisection Method","text":"<p>The bisection method is used to estimate the root of a function by identifying two values, <code>a</code> and <code>b</code>, such that the function has opposite signs at those points. The midpoint of the interval is calculated, and the subinterval where the function's signs differ is selected for the next iteration. This process continues until the desired precision (i.e., interval length) is achieved.</p> <p>In NumLib, this method is implemented using the <code>roof1r</code> procedure:</p> <pre><code>procedure roof1r(f: rfunc1r; a, b, ae, re: ArbFloat; var x: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li>f: The function for which the root is to be determined. It must take a single floating-point argument of type <code>ArbFloat</code>. The function type <code>rfunc1r</code> is declared in the <code>typ</code> unit.</li> <li>a, b: The endpoints of the interval. The root must lie between these two values, meaning the function values <code>f(a)</code> and <code>f(b)</code> should have opposite signs.</li> <li>ae, re: These determine the absolute (<code>ae</code>) and relative (<code>re</code>) precision of the root. <code>re</code> is relative to the maximum of <code>abs(a)</code> and <code>abs(b)</code>. Higher accuracy is achieved by setting <code>ae</code> to <code>MachEps</code> (from the <code>typ</code> unit). Both parameters must be non-negative.</li> <li>x: The variable that returns the found root.</li> <li>term: An error code indicating the result of the process:<ul> <li><code>1</code>: Successful termination. A root has been found with the specified absolute or relative precision.</li> <li><code>2</code>: The required accuracy could not be achieved, but the value of <code>x</code> is the \"best achievable\" approximation.</li> <li><code>3</code>: Input error: <code>ae &lt; 0</code> or <code>re &lt; 0</code>, or the function values at <code>a</code> and <code>b</code> do not have opposite signs.</li> </ul> </li> </ul> <p>Example</p> <p>The following program uses the bisection method to find the square root of 2. The root is the value of <code>x</code> where the function \\( f(x) = x^2 - 2 \\) equals zero. Since \\( f(1) = -1 \\) and \\( f(2) = 2 \\), the root lies between 1 and 2.</p> <pre><code>program solve_root_bisection;\n\nuses\n  typ, roo;\n\nfunction f(x: ArbFloat): ArbFloat;\nbegin\n  Result := x*x - 2;\nend;\n\nvar\n  x: ArbFloat = 0.0;\n  term: ArbInt;\n\nbegin\n  roof1r(@f, 1.0, 2.0, 1e-9, 0, x, term);\n  WriteLn('Bisection result: ', x);\n  WriteLn('sqrt(2):          ', sqrt(2.0));\nend.\n</code></pre> <p>Output</p> <pre><code>Bisection result:  1.4142135621888698E+000\nsqrt(2):           1.4142135623730951E+000\nPress enter to quit\n</code></pre> <p>Here\u2019s a tidied version of your text:</p>"},{"location":"docs/advanced/numlib/#roots-of-a-system-of-nonlinear-equations","title":"Roots of a System of Nonlinear Equations","text":"<p>We want to find the roots of a system of nonlinear equations:</p> \\[ f_{i}(x_1, x_2, \\ldots, x_n) = 0, \\; i=1,2,\\ldots,n \\] <p>The <code>roofnr</code> procedure can be used to find the roots of such a system:</p> <pre><code>procedure roofnr(f: roofnrfunc; n: ArbInt; var x, residu: ArbFloat; ra: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li>f: The address of the procedure that calculates the function values \\( f_i(x_1, x_2, \\dots, x_n) \\). The function type <code>roofnrfunc</code> is declared in the <code>typ</code> unit:   <pre><code>type\n  roofnrfunc = procedure(var x, fx: ArbFloat; var deff: boolean);\n</code></pre></li> <li>x: An array of at least <code>n</code> <code>ArbFloat</code> values, providing the \\( x_j \\) values at which the functions are evaluated.</li> <li>fx: An array to store the calculated values of the functions \\( f_i \\).</li> <li>deff: A boolean flag that can be used to stop the root-finding process based on a condition.</li> </ul> <p>For example, to solve the system of equations:</p> \\[  \\begin{array}{l} f_1(x_1, x_2) = x_1^2 + x_2^2 - 2 = 0 \\\\ f_2(x_1, x_2) = -(x_1 - 1)^2 + x_2 = 0 \\end{array} \\] <p>The function <code>f</code> can be written as:</p> <pre><code>procedure func(var x1, f1x: real; var deff: boolean); \nvar \n  x: array[1..2] of real absolute x1;\n  f: array[1..2] of real absolute f1x;\nbegin\n  f[1] := sqr(x[1]) + sqr(x[2]) - 2;\n  f[2] := -sqr(x[1] - 1) + x[2];\nend;\n</code></pre> <p>To stop the process when \\( x_1 &lt; 1 \\), set <code>deff</code> to <code>false</code>:</p> <pre><code>procedure func(var x1, f1x: real; var deff: boolean); far;\nvar \n  x: array[1..2] of real absolute x1;\n  f: array[1..2] of real absolute f1x;\nbegin\n  deff := x[1] &gt;= 1;\n  if deff then begin\n    f[1] := sqr(x[1]) + sqr(x[2]) - 2;\n    f[2] := -sqr(x[1] - 1) + x[2];\n  end;\nend;\n</code></pre> <p>Parameters</p> <ul> <li>n: The number of equations or variables ( \\( x_i \\) ) in the system.</li> <li>x: The first element of an array (with at least <code>n</code> values) used for both input and output. Initially, it should contain estimates of the roots. After computation, it holds the found roots.</li> <li>residu: The 2-norm of the vector of residuals in the solution:   $$ |f|2 = \\sqrt{\\sum^{n} f_i^2} $$</li> <li>ra: The relative accuracy for calculating the solution. Typical values are \\( 10^{-3}, 10^{-5}, 10^{-8} \\) depending on the precision (<code>single</code>, <code>real</code>, or <code>double</code>).</li> <li>term: An error code indicating the result:<ul> <li><code>1</code>: Successful solution with desired accuracy.</li> <li><code>2</code>: The solution accuracy could not be achieved, but the returned <code>x</code> values are the best achievable.</li> <li><code>3</code>: Incorrect input data (e.g., <code>n &lt; 0</code> or <code>re &lt; 0</code>).</li> <li><code>4</code>: The calculation process was stopped due to exceeding function call limits.</li> <li><code>5</code>: Insufficient progress\u2014no solution found or needs a different starting value.</li> <li><code>6</code>: The procedure attempted to compute a value outside the range defined by <code>deff</code>.</li> </ul> </li> </ul> <p>Example</p> <p>Solve the system of equations:</p> \\[  \\begin{array}{l} f_1(x_1, x_2) = x_1^2 + x_2^2 - 2 = 0 \\\\ f_2(x_1, x_2) = -(x_1 - 1)^2 + x_2 = 0 \\end{array} \\] <pre><code>program solve_root_nonlinear;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, typ, roo;\n\nconst\n  n = 2;\n  ra = 1e-10;\n\nvar\n  x: array[1..n] of ArbFloat;\n  f_check: array[1..n] of ArbFloat;\n  residu: ArbFloat;\n  i: integer;\n  term: integer;\n  deff: boolean;\n\n  procedure funcs(var x0, fx: ArbFloat; var deff: boolean);\n  var\n    xloc: array[1..n] of ArbFloat absolute x0;\n    f: array[1..n] of ArbFloat absolute fx;\n  begin\n    f[1] := sqr(xloc[1]) + sqr(xloc[2]) - 2;\n    f[2] := -sqr(xloc[1] - 1) + xloc[2];\n  end;\n\nbegin\n  // Initial guess values\n  x[1] := 0;\n  x[2] := 0;\n\n  // Solve the equation system\n  roofnr(@funcs, n, x[1], residu, ra, term);\n\n  WriteLn('term = ', term);\n  WriteLn;\n\n  if term in [1, 2] then begin\n    WriteLn('Results found by procedure roofnr:');\n    for i := 1 to n do\n      WriteLn('Solution #' + IntToStr(i) + ': ', x[i]:0:6);\n    WriteLn('Norm of residuals: ', residu:0:15);\n  end else\n    WriteLn('ERROR');\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>term = 1\n\nResults found by procedure roofnr:\nSolution #1: 1.404698\nSolution #2: 0.163780\nNorm of residuals: 0.000000000000000\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#unit-int-numerical-integration-of-a-function","title":"Unit <code>int</code> - Numerical integration of a function","text":"<p>The <code>int1fr</code> function in the <code>NumLib</code> library calculates the integral of a given function between limits <code>a</code> and <code>b</code>, with a specified absolute accuracy <code>ae</code>:</p> <pre><code>procedure int1fr(f: rfunc1r; a, b, ae: ArbFloat; var integral, err: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li> <p><code>f</code>: A pointer to the function to be integrated. The function must take a single real variable of type <code>ArbFloat</code> and return a value of type <code>ArbFloat</code>. The function type is declared as <code>rfunc1r</code> in the <code>typ</code> unit.</p> </li> <li> <p><code>a, b</code>: The integration limits. These can also be set to <code>+/-Infinity</code> to allow integration over infinite intervals. The order of <code>a</code> and <code>b</code> follows correct mathematical conventions.</p> </li> <li> <p><code>ae</code>: The required absolute accuracy for the result.</p> </li> <li> <p><code>integral</code>: The result of the integration. It is valid only if <code>term = 1</code>.</p> </li> <li> <p><code>err</code>: The error in accuracy if the requested precision could not be achieved. In this case, <code>term = 2</code>.</p> </li> <li> <p><code>term</code>: The termination status code:</p> <ul> <li><code>1</code>: Integration successful with absolute accuracy <code>ae</code>.</li> <li><code>2</code>: Requested accuracy not reached, but the result is approximated with error <code>err</code>.</li> <li><code>3</code>: Invalid input (e.g., <code>ae &lt; 0</code>, or both <code>a</code> and <code>b</code> are infinite).</li> <li><code>4</code>: Integration failed due to divergence or slow convergence.</li> </ul> </li> </ul> <p>Example</p> <p>This example demonstrates calculating the integral:</p> \\[ \\int_a^b \\frac{1}{x^2} \\, dx \\] <p>for various integration limits <code>a</code> and <code>b</code>. Since the function diverges at <code>x = 0</code>, the integration interval must not include this point. The expected analytic result is provided for comparison.</p> <pre><code>program integrate;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, Math, typ, int;\n\n// Function representing 1/x^2\nfunction recipx2(x: ArbFloat): ArbFloat;\nbegin\n  Result := 1.0 / sqr(x);\nend;\n\n// Analytic result of the integral\nfunction integral_recipx2(a, b: ArbFloat): Arbfloat;\nbegin\n  if a = 0 then\n    a := Infinity\n  else if a = Infinity then\n    a := 0.0\n  else\n    a := -1 / a;\n\n  if b = 0 then\n    b := Infinity\n  else if b = Infinity then\n    b := 0.0\n  else\n    b := -1 / b;\n\n  Result := b - a;\nend;\n\n// Execute the integration and handle the result\nprocedure Execute(a, b: ArbFloat);\nvar\n  err: ArbFloat = 0.0;\n  term: ArbInt = 0;\n  integral: ArbFloat = 0.0;\nbegin\n  try\n    int1fr(@recipx2, a, b, 1e-9, integral, err, term);\n  except\n    term := 4;\n  end;\n\n  Write('  The integral from ' + FloatToStr(a) + ' to ' + FloatToStr(b));\n\n  case term of\n    1: WriteLn(' is ', integral:0:9, ', expected: ', integral_recipx2(a, b):0:9);\n    2: WriteLn(' is ', integral:0:9, ', error: ', err:0:9, ', expected: ', integral_recipx2(a, b):0:9);\n    3: WriteLn(' cannot be calculated: Invalid input.');\n    4: WriteLn(' cannot be calculated: Divergence or slow convergence.');\n  end;\nend;\n\nbegin\n  WriteLn('Integral of f(x) = 1/x^2');\n  Execute(1.0, 2.0);\n  Execute(1.0, 1.0);\n  Execute(2.0, 1.0);\n  Execute(1.0, Infinity);\n  Execute(-Infinity, -1.0);\n  Execute(0.0, Infinity);\n  // Note: The following case will raise an exception in some environments, but works outside the IDE.\n  // Execute(-1.0, Infinity);\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Notes</p> <ul> <li> <p><code>recipx2</code>: This function returns \\( \\frac{1}{x^2} \\), which is the integrand.</p> </li> <li> <p><code>integral_recipx2</code>: Computes the expected analytic result for the given integration limits.</p> </li> <li> <p><code>Execute</code>: Runs the integration for the specified limits <code>a</code> and <code>b</code>, handles potential errors, and prints the result.</p> </li> </ul> <p>Output</p> <pre><code>Integral of f(x) = 1/x^2\n  The integral from 1 to 2 is 0.500000000, expected: 0.500000000\n  The integral from 1 to 1 is 0.000000000, expected: 0.000000000\n  The integral from 2 to 1 is -0.500000000, expected: -0.500000000\n  The integral from 1 to +Inf is 1.000000000, expected: 1.000000000\n  The integral from -Inf to -1 is 1.000000000, expected: 1.000000000\n  The integral from 0 to +Inf cannot be calculated: Divergence or slow convergence.\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#unit-ode-ordinary-differential-equations","title":"Unit <code>ode</code> - Ordinary differential equations","text":""},{"location":"docs/advanced/numlib/#solving-a-single-first-order-differential-equation","title":"Solving a Single First-Order Differential Equation","text":"<p>The procedure <code>odeiv1</code> solves an initial value problem for a first-order differential equation of the form:</p> \\[ \\begin{cases} y' = f(x, y), \\qquad x \\in [a, b] \\\\ y(a) = \\alpha \\end{cases} \\] <p>where <code>a</code>, <code>b</code>, <code>f</code>, and the initial condition <code>y(a) = \u03b1</code> are given.</p> <pre><code>procedure odeiv1(f: rfunc2r; a, ya: ArbFloat; var b, yb: ArbFloat; ae: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li><code>f</code>: The function to be solved, depending on two real variables and returning a real value. Defined as <code>type rfunc2r = function(x, y: ArbFloat): ArbFloat</code>.</li> <li><code>a</code>: The starting <code>x</code> value of the interval.</li> <li><code>ya</code>: The initial value <code>\u03b1</code> at <code>x = a</code>.</li> <li><code>b</code>: The end <code>x</code> value of the interval. After the calculation, if <code>term = 2</code>, <code>b</code> contains the new endpoint with the required accuracy, <code>ae</code>.</li> <li><code>yb</code>: Returns the computed value <code>y(b)</code> if <code>term &lt; 3</code>. If <code>term = 3</code>, the result is undefined.</li> <li><code>ae</code>: Specifies the absolute accuracy required for <code>y(b)</code>.</li> <li><code>term</code>: Returns the following error codes:<ul> <li><code>1</code>: Successful completion.</li> <li><code>2</code>: The solution could not reach <code>b</code> with the required accuracy. <code>yb</code> is an approximation at the delivered <code>b</code>.</li> <li><code>3</code>: Input error, <code>ae &lt;= 0</code>.</li> </ul> </li> </ul> <p>This algorithm is based on a fifth-order adaptive Runge-Kutta method. It may not be accurate for stiff differential equations, and accuracy issues can arise in unstable problems where small variations in <code>y(a)</code> cause large variations in <code>y(b)</code>.</p> <p>If you want to solve for multiple points, like from <code>x = 0</code> to <code>x = 1</code> with a step size of 0.1, avoid restarting at each step and \"integrate\" instead.</p> <p>Example</p> <p>Solve the equation \\(y'' = -10  (y - x^2)\\) with initial condition \\(y(0) = 0\\) and compare it to the exact solution \\(y(x) = -0.02  exp(-10  x) + x^2 - 0.2  x + 0.02\\).</p> <pre><code>program solve_ode;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ, // This unit contains common type definitions used in the program.\n  ode; // This unit provides the ODE solver `odeiv1` used in the program.\n\n// Define the function representing the differential equation: y' = f(x, y).\n// In this case, f(x, y) = -10 * (y - x^2), a basic second-order ODE.\nfunction f(x, y: ArbFloat): ArbFloat;\nbegin\n  Result := -10 * (y - sqr(x)); // sqr(x) calculates x^2\nend;\n\n// Define the exact analytical solution for comparison purposes.\n// The solution to the differential equation is given by y(x) = -0.02 * exp(-10 * x) + x^2 - 0.2 * x + 0.02.\nfunction exact(x: real): real; far;\nbegin\n  Result := -0.02 * exp(-10 * x) + sqr(x) - 0.2 * x + 0.02;\nend;\n\nconst\n  d = 0.5;  // The length of the interval over which to solve the ODE.\n  ae = 1e-5; // The absolute error tolerance for the ODE solver.\n  n = 10;    // The number of steps to take between the start and end of the interval.\n\nvar\n  a, b, ya, yb: ArbFloat; // Variables representing the interval endpoints and function values.\n  term: ArbInt;           // Variable to hold the error code returned by the ODE solver.\n  i: ArbInt;              // Loop counter.\n\nbegin\n  // Set initial conditions for the ODE solver.\n  a := 0.0;      // Start at x = 0.\n  b := a + d;    // End of the first step at x = 0.5 (the interval length).\n  ya := 0.0;     // Initial condition: y(0) = 0.\n\n  // Print table headers for output (x, y, exact solution, error code).\n  WriteLn('x':12, 'y':12, 'exact':12, 'error code':17);\n  WriteLn;\n\n  // Output the initial condition at x = 0.\n  WriteLn(a:12:5, ya:12:5, exact(a):12:5, '-':17); // Display the starting point.\n\n  // Loop to solve the ODE in steps of 0.5 (controlled by 'd') until n steps are done.\n  for i := 1 to n do\n  begin\n    // Call the ODE solver (odeiv1) to compute y(b) based on the function 'f'.\n    // a: start of the interval, ya: initial value y(a), b: end of interval,\n    // yb: result of y(b), ae: accuracy, term: error code.\n    odeiv1(@f, a, ya, b, yb, ae, term);\n\n    // Output the results after each step: x = b, y(b), exact solution, and error code.\n    WriteLn(b:12:5, yb:12:5, exact(b):12:5, term:17);\n\n    // Update for the next step: set a = b and ya = yb, and increment b by 'd' for the next interval.\n    a := b;     // Move to the next interval.\n    ya := yb;   // Use the computed value y(b) as the initial value for the next step.\n    b := b + d; // Increment b for the next step.\n  end;\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>           x           y       exact       error code\n\n     0.00000     0.00000     0.00000                -\n     0.50000     0.16986     0.16987                1\n     1.00000     0.82000     0.82000                1\n     1.50000     1.97000     1.97000                1\n     2.00000     3.62000     3.62000                1\n     2.50000     5.77000     5.77000                1\n     3.00000     8.42000     8.42000                1\n     3.50000    11.57000    11.57000                1\n     4.00000    15.22000    15.22000                1\n     4.50000    19.37000    19.37000                1\n     5.00000    24.02000    24.02000                1\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#solving-a-system-of-first-order-differential-equations","title":"Solving a System of First-Order Differential Equations","text":"<p>To solve a system of first-order differential equations:</p> \\[ \\begin{cases} \\mathbf{y}' = \\mathbf{f}(x, \\mathbf{y}), \\qquad x \\in [a, b] \\\\ \\mathbf{y}(a) = \\alpha \\end{cases} \\] <p>where:</p> <ul> <li><code>y</code> is a vector \\([y_1(x), y_2(x), ..., y_n(x)]\\),</li> <li><code>f(x, y)</code> is a vector function \\([f_1(x, y), f_2(x, y), ..., f_n(x, y)]\\),</li> <li>The initial conditions are given as \\(y(a) = [y_1(a), y_2(a), ..., y_n(a)]\\).</li> </ul> <p>This can be solved using the procedure <code>odeiv2</code>, which uses an adaptive fifth-order Runge-Kutta method with variable step size.</p> <pre><code>procedure odeiv2(f: oderk1n; a: ArbFloat; var ya, b, yb: ArbFloat; n: ArbInt; ae: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li><code>f</code>: The procedure calculating \\(f_i(x, y_i)\\) values. It is of type <code>oderk1n = procedure(x: ArbFloat; var y, fxy: ArbFloat)</code>.</li> <li><code>a</code>: Starting point of the calculation.</li> <li><code>ya</code>: Initial values for the system, stored in an array.</li> <li><code>b</code>: Endpoint of the interval. If <code>term = 2</code>, <code>b</code> will be updated.</li> <li><code>yb</code>: Stores the results.</li> <li><code>n</code>: Number of equations in the system.</li> <li><code>ae</code>: Specifies absolute accuracy.</li> <li><code>term</code>: Error codes:</li> <li><code>1</code>: Successful completion.</li> <li><code>2</code>: Solution couldn't reach <code>b</code> with desired accuracy. <code>yb</code> contains approximations.</li> <li><code>3</code>: Input error, <code>n &lt; 1</code> or <code>ae &lt;= 0</code>.</li> </ul> <p>Example</p> <p>Integrate the following system of ODEs between <code>x = 0</code> and <code>x = 1</code>:</p> \\[ \\begin{cases} y'_1 = 2xy_1 + y_2 \\\\ y'_2 = -y_1 + 2xy_2 \\\\ y_1(0) = 0, \\quad y_2(0) = 1 \\end{cases} \\] <p>The exact solutions are:</p> \\[ \\begin{cases} y_1(x) = \\exp(x^2) \\sin(x) \\\\ y_2(x) = \\exp(x^2) \\cos(x) \\end{cases} \\] <pre><code>program solve_ode_sys;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ,  // Includes necessary types for operations with numlib.\n  ode;  // Provides the ODE solver used in the program.\n\nconst\n  ae = 1e-5;  // Absolute error tolerance for the ODE solver.\n\n  // This procedure defines the system of differential equations to solve.\n  // It takes the independent variable 'x' and the current values 'y' and computes the derivatives 'f(x,y)'.\n  procedure f(x: ArbFloat; var y, fxy: ArbFloat);\n  var\n    // These arrays represent the system of equations.\n    _y: array[1..2] of ArbFloat absolute y;\n    // Current y values (dependent variables).\n    _fxy: array[1..2] of ArbFloat absolute fxy;    // Corresponding derivatives (dy/dx).\n  begin\n    // First equation of the system: dy1/dx = 2*x*y1 + y2\n    _fxy[1] := 2 * x * _y[1] + _y[2];\n    // Second equation of the system: dy2/dx = -y1 + 2*x*y2\n    _fxy[2] := -_y[1] + 2 * x * _y[2];\n  end;\n\n  // This function returns the exact solution for y1 at a given 'x'.\n  function exact1(x: ArbFloat): ArbFloat;\n  begin\n    Result := exp(x * x) * sin(x);  // Exact solution for y1 = exp(x^2) * sin(x)\n  end;\n\n  // This function returns the exact solution for y2 at a given 'x'.\n  function exact2(x: ArbFloat): ArbFloat;\n  begin\n    Result := exp(x * x) * cos(x);  // Exact solution for y2 = exp(x^2) * cos(x)\n  end;\n\nvar\n  a, b, d: ArbFloat; // 'a' and 'b' are the interval bounds, 'd' is the step size.\n  ya, yb: array[1..2] of ArbFloat;  // Arrays to hold y values at 'a' and 'b'.\n  term, i, n: ArbInt;\n  // 'term' stores the error code, 'i' is the loop index, 'n' is the number of steps.\n\nbegin\n  // Set initial values.\n  a := 0.0;        // Start point for x.\n  b := 0.1;        // Initial end point for x.\n  d := b - a;      // Step size (difference between 'a' and 'b').\n  ya[1] := 0.0;    // Initial condition for y1 (y1(0) = 0).\n  ya[2] := 1.0;    // Initial condition for y2 (y2(0) = 1).\n  n := 10;         // Number of steps.\n\n  // Print table headers for output.\n  WriteLn('x': 12, 'y[1]': 12, 'y[2]': 12, 'exact[1]': 12, 'exact[2]': 12, 'error code': 17);\n  WriteLn;\n\n  // Output the initial conditions at x = 0.\n  WriteLn(a: 12: 5, ya[1]: 12: 5, ya[2]: 12: 5, exact1(a): 12: 5, exact2(a): 12: 5, '-': 17);\n\n  // Loop through 'n' steps to solve the system over each interval.\n  for i := 1 to n do\n  begin\n    // Call the ODE solver (odeiv2) to compute yb at x = b.\n    // 'f' is the function defining the system of ODEs, 'a' is the start point,\n    // 'ya[1]' are the initial y-values, 'b' is the end point,\n    // 'yb[1]' will store the computed y-values at 'b',\n    // '2' indicates the system size (two equations), 'ae' is the accuracy, and 'term' stores the error code.\n    odeiv2(@f, a, ya[1], b, yb[1], 2, ae, term);\n\n    // Output the results at each step: x = b, y1(b), y2(b), exact solutions, and error code.\n    WriteLn(b: 12: 5, yb[1]: 12: 5, yb[2]: 12: 5, exact1(b): 12: 5, exact2(b): 12: 5, term: 17);\n\n    // Update the values for the next iteration.\n    a := b;         // Move to the next interval starting from the current 'b'.\n    ya[1] := yb[1]; // Set ya to the computed yb for the next step.\n    ya[2] := yb[2];\n    b := b + d;     // Increment 'b' by the step size 'd'.\n  end;\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>           x        y[1]        y[2]    exact[1]    exact[2]       error code\n\n     0.00000     0.00000     1.00000     0.00000     1.00000                -\n     0.10000     0.10084     1.00500     0.10084     1.00500                1\n     0.20000     0.20678     1.02006     0.20678     1.02006                1\n     0.30000     0.32335     1.04530     0.32335     1.04530                1\n     0.40000     0.45699     1.08088     0.45699     1.08088                1\n     0.50000     0.61559     1.12684     0.61559     1.12684                1\n     0.60000     0.80932     1.18298     0.80932     1.18298                1\n     0.70000     1.05157     1.24846     1.05157     1.24846                1\n     0.80000     1.36045     1.32129     1.36045     1.32129                1\n     0.90000     1.76085     1.39732     1.76085     1.39732                1\n     1.00000     2.28736     1.46869     2.28736     1.46869                1\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#unit-ipf-interpolation-and-fitting","title":"Unit <code>ipf</code> - Interpolation and fitting","text":"<p>The unit <code>ipf</code> contains routines for:</p> <ul> <li>Fitting a set of data points with a polynomial.</li> <li>Interpolating or fitting a set of data points with a natural cubic spline. A spline is a piecewise function of polynomials with a high degree of smoothness at the connection points (called \"knots\"). In the case of a natural cubic spline, the polynomials are of degree 3, and their second derivatives are zero at the first and last knots.</li> </ul> <p>Definitions</p> <ul> <li>Fitting: Finding an approximating smooth function such that deviations from the data points are minimized.</li> <li>Interpolation: Determining a function that passes exactly through the data points.</li> </ul> <p>Use of Polynomials or Splines</p> <p>Polynomials or splines are recommended unless the data follows a known function but with some unknown parameters. For example, if the data is modeled by the function   \\( f(x) = a + b e^{-c x} \\), fitting to that form may be better.</p> <p>If the data contains measurement errors, fitting with a low-degree polynomial (e.g., degree \u2264 5) is usually a good first approach. If the data\u2019s shape is complex, consider fitting with a spline. </p> <p>If the data has no measurement noise, it\u2019s often best to interpolate using a spline.</p>"},{"location":"docs/advanced/numlib/#fitting-with-a-polynomial","title":"Fitting with a Polynomial","text":"<p>You can fit a polynomial to your data using the <code>ipfpol</code> routine. This routine takes a set of data points \\((x_i, y_i)\\) and calculates a polynomial of the form:</p> \\[ p(x) = b_0 + b_1 x + \\dots + b_n x^n \\] <p>The coefficients \\( b_0, \\dots, b_n \\) are adjusted to minimize the sum of squared deviations from the data points, using the least squares fitting method:</p> \\[ \\sum_{i=1}^m (p(x_i) - y_i)^2 \\] <pre><code>procedure ipfpol(m, n: ArbInt; var x, y, b: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li><code>m</code>: Number of data points (must be \\( m \\geq 1 \\)).</li> <li><code>n</code>: Degree of the polynomial (must be \\( n &gt; 0 \\)).</li> <li><code>x</code>: Array containing the \\( x \\)-values of the data points.</li> <li><code>y</code>: Array containing the \\( y \\)-values of the data points.</li> <li><code>b</code>: Array to store the calculated polynomial coefficients.</li> <li><code>term</code>: Error code.</li> <li><code>1</code>: Success.</li> <li><code>3</code>: Input error (e.g., \\( n &lt; 0 \\) or \\( m &lt; 1 \\)).</li> </ul> <p>Once the coefficients are determined, you can calculate the value of \\( p(x) \\) using the <code>spepol</code> procedure from the <code>spe</code> unit.</p> <p>Example: Fitting a Degree 2 Polynomial</p> <p>Fit a polynomial of degree 2 to these data points:</p> \\[ \\displaystyle{    \\begin{array}{ccc}     \\hline     i &amp; x_i &amp; y_i \\\\     \\hline     1 &amp; 0.00 &amp; 1.26 \\\\     2 &amp; 0.08 &amp; 1.37 \\\\     3 &amp; 0.22 &amp; 1.72 \\\\     4 &amp; 0.33 &amp; 2.08 \\\\     5 &amp; 0.46 &amp; 2.31 \\\\     6 &amp; 0.52 &amp; 2.64 \\\\     7 &amp; 0.67 &amp; 3.12 \\\\     8 &amp; 0.81 &amp; 3.48   \\end{array}  }  \\] <pre><code>program polynomial_fit;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils, typ, ipf, spe;\n\nconst\n  m = 8;  // Number of data points\n  n = 2;  // Polynomial degree\n\nvar\n  x: array[1..m] of ArbFloat = (0.00, 0.08, 0.22, 0.33, 0.46, 0.52, 0.67, 0.81);\n  y: array[1..m] of ArbFloat = (1.26, 1.37, 1.72, 2.08, 2.31, 2.64, 3.12, 3.48);\n  b: array[0..n] of ArbFloat;\n  i: Integer;\n  term: ArbInt;\n  xint, yint: ArbFloat;\nbegin\n  WriteLn('Fitting a polynomial of degree 2: p(x) = b[0] + b[1] x + b[2] x^2');\n\n  // Print data points\n  WriteLn('Data points');\n  WriteLn('i':10, 'x_i':10, 'y_i':10);\n  for i := 1 to m do\n    WriteLn(i:10, x[i]:10:2, y[i]:10:2);\n\n  // Fit polynomial\n  ipfpol(m, n, x[1], y[1], b[0], term);\n\n  // Display coefficients\n  WriteLn('Fitted coefficients b = ', b[0]:10:6, b[1]:10:6, b[2]:10:6);\n\n  // Interpolation\n  WriteLn('Interpolated values:');\n  for i := 1 to 5 do begin\n    xint := 0.2 * i;\n    yint := spepol(xint, b[0], n);\n    WriteLn(xint:10:2, yint:10:2);\n  end;\n\n  // Pause to allow user to see results before exiting the program\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>Fitting a polynomial of degree 2: p(x) = b[0] + b[1] x + b[2] x^2\nData points\n         i       x_i       y_i\n         1      0.00      1.26\n         2      0.08      1.37\n         3      0.22      1.72\n         4      0.33      2.08\n         5      0.46      2.31\n         6      0.52      2.64\n         7      0.67      3.12\n         8      0.81      3.48\nFitted coefficients b =   1.222195  2.224385  0.759178\nInterpolated values:\n      0.20      1.70\n      0.40      2.23\n      0.60      2.83\n      0.80      3.49\n      1.00      4.21\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#interpolation-with-a-natural-cubic-spline","title":"Interpolation with a Natural Cubic Spline","text":"<p>To interpolate data with a cubic spline, use the <code>ipfisn</code> routine. This calculates the spline\u2019s second derivatives. Once these are known, you can calculate the spline value at any point using the <code>ipfspn</code> procedure.</p> <pre><code>procedure ipfisn(n: ArbInt; var x, y, d2s: ArbFloat; var term: ArbInt);\n</code></pre> <p>Parameters</p> <ul> <li><code>n</code>: Number of data points minus one.</li> <li><code>x</code>, <code>y</code>: Arrays containing the data points' \\( x \\)- and \\( y \\)-values.</li> <li><code>d2s</code>: Array to store the second derivatives at each point (except at the endpoints, where it's set to 0).</li> <li><code>term</code>: Error code.</li> <li><code>1</code>: Success.</li> <li><code>2</code>: Error in calculating second derivatives.</li> <li><code>3</code>: Invalid input parameters (e.g., \\( n \\leq 1 \\)).</li> </ul> <p>Once the second derivatives are determined, you can use <code>ipfspn</code> to evaluate the spline at any point.</p> <p>Example: Natural Cubic Spline Interpolation</p> <p>Interpolate a natural cubic spline through the following data points:</p> \\[ \\displaystyle{    \\begin{array}{ccc}     \\hline     i &amp; x_i &amp; y_i \\\\     \\hline     0 &amp; 0.00 &amp; 0.980 \\\\     1 &amp; 0.09 &amp; 0.927 \\\\     2 &amp; 0.22 &amp; 0.732 \\\\     3 &amp; 0.34 &amp; 0.542 \\\\     4 &amp; 0.47 &amp; 0.385 \\\\     5 &amp; 0.58 &amp; 0.292 \\\\     6 &amp; 0.65 &amp; 0.248 \\\\     7 &amp; 0.80 &amp; 0.179 \\\\     8 &amp; 0.93 &amp; 0.139   \\end{array}  } \\] <pre><code>program spline_interpolation;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  typ,\n  ipf;\n\nconst\n  n = 8;\n\nvar\n  x: array[0..n] of ArbFloat = (0.00, 0.09, 0.22, 0.34, 0.47, 0.58, 0.65, 0.80, 0.93);\n  y: array[0..n] of ArbFloat = (0.990, 0.927, 0.734, 0.542, 0.388, 0.292, 0.248, 0.179, 0.139);\n  d2s: array[1..n - 1] of ArbFloat;\n  i: integer;\n  term: ArbInt;\n  xint, yint: ArbFloat;\nbegin\n  WriteLn('Cubic spline interpolation');\n\n  // Print data points\n  WriteLn('Data points');\n  WriteLn('i': 10, 'x_i': 10, 'y_i': 10);\n  for i := 0 to n do\n    WriteLn(i: 10, x[i]: 10: 2, y[i]: 10: 3);\n\n  // Calculate spline parameters\n  ipfisn(n, x[0], y[0], d2s[1], term);\n\n  // Display second derivatives\n  WriteLn('Second derivatives');\n  for i := 1 to n - 1 do\n    WriteLn(d2s[i]: 10: 6);\n\n  // Interpolation\n  WriteLn('Interpolated values');\n  for i := 1 to 5 do\n  begin\n    xint := 0.2 * i;\n    yint := ipfspn(n, x[0], y[0], d2s[1], xint, term);\n    WriteLn(xint: 10: 2, yint: 10: 2);\n  end;\n\n// Pause to allow user to see results before exiting the program\nWriteLn('Press enter to quit');\nReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>Cubic spline interpolation\nData points\n         i       x_i       y_i\n         0      0.00     0.990\n         1      0.09     0.927\n         2      0.22     0.734\n         3      0.34     0.542\n         4      0.47     0.388\n         5      0.58     0.292\n         6      0.65     0.248\n         7      0.80     0.179\n         8      0.93     0.139\nSecond derivatives\n-10.810021\n  0.374744\n  4.380190\n  1.978794\n  3.200753\n  1.357095\n  1.268361\nInterpolated values\n      0.20      0.77\n      0.40      0.46\n      0.60      0.28\n      0.80      0.18\n      1.00      0.12\nPress enter to quit\n</code></pre>"},{"location":"docs/advanced/numlib/#unit-spe-special-functions","title":"Unit <code>spe</code> - Special functions","text":"<p>Coming soon.</p>"},{"location":"docs/advanced/overview/","title":"Advanced Topics","text":"<p>This section covers more difficult topics (beyond the core tasks) using Free Pascal and Lazarus.</p> <p>Important</p> <p>This section assumes you have correctly set up the Free Pascal Compiler and the Lazarus IDE for your OS.</p> <p>Choose a topic from the left sidebar.</p>"},{"location":"docs/basics/basic-hello-world/","title":"Hello, World!","text":"<p>How would you like to do your <code>Hello World</code>?</p> <ul> <li>I'm using the Lazarus IDE</li> <li>I'm using the CLI</li> </ul>"},{"location":"docs/basics/basic-hello-world/#using-the-lazarus-ide","title":"Using the Lazarus IDE","text":"<p>Note</p> <p>This section assumes you have correctly set up the following for your OS.</p> <ol> <li>The Free Pascal Compiler.</li> <li>The Lazarus IDE.</li> </ol>"},{"location":"docs/basics/basic-hello-world/#create-a-project","title":"Create a Project","text":"<ol> <li>Launch Lazarus IDE.</li> <li>Create a new Project.<ul> <li>On the top menu bar, click <code>Project -&gt; Simple Program -&gt; OK</code>.</li> </ul> </li> <li>Save this Project.<ul> <li>Click <code>Project -&gt; Save Project</code>. </li> <li>Save the Project file as <code>HelloWorld.lpi</code> in a new folder. </li> <li>Note: Lazarus will save the main source file as <code>HelloWorld.lpr</code>.</li> </ul> </li> </ol> <p>You will see a simple program in the Source Editor window. The <code>program</code>'s name will be the same as the Project's name, as shown below.</p> <pre><code>program HelloWorld;\n\nbegin\nend.\n</code></pre>"},{"location":"docs/basics/basic-hello-world/#add-code","title":"Add Code","text":"<ol> <li>Now insert the following lines between <code>begin</code> and <code>end.</code>.</li> </ol> <pre><code>WriteLn('Hello, World!');\nReadLn;\n</code></pre> <ul> <li>The <code>WriteLn</code> function prints text on the console.</li> <li>The <code>ReadLn</code> in the code prevents the console from being closed automatically.</li> </ul> <ol> <li>Add the following compiler directives after the <code>program</code> declaration. </li> </ol> <pre><code>{$mode objfpc}{$H+}{$J-}\n</code></pre> <p>Note</p> <p>Make sure to have this line in all your Object Pascal codes.</p> <p><code>{$mode objfpc}{$H+}{$J-}</code></p> <p>Your final code would look as follows.</p> <pre><code>program HelloWorld;\n\n{$mode objfpc}{$H+}{$J-} // Add this line in your object pascal codes.\n\nbegin\n  WriteLn('Hello, World!');\n  ReadLn;\nend.\n</code></pre> <ol> <li>Press Ctrl+S to save the code.</li> </ol>"},{"location":"docs/basics/basic-hello-world/#compile-run","title":"Compile &amp; Run","text":"<p>Press F9 to run the compile and run the program.</p> <p>You should be able to see a console open with <code>Hello World</code> in it.</p> <p>Press the Enter key to exit the progam, which also closes the console.</p>"},{"location":"docs/basics/basic-hello-world/#using-the-cli","title":"Using the CLI","text":"<p>Note</p> <p>This section assumes you have correctly set up the Free Pascal Compiler and the <code>fpc</code> is in your <code>PATH</code>. </p>"},{"location":"docs/basics/basic-hello-world/#create-a-pas-file-add-code","title":"Create a <code>.pas</code> File &amp; Add Code","text":"<ol> <li>Launch your favourite text editor</li> <li>Create a new file and put the following snippet in it.</li> </ol> <pre><code>{$mode objfpc}{$H+}{$J-} \n\nbegin\n    WriteLn('Hello, World!');\nend.\n</code></pre> <ol> <li>Save it as <code>HelloWorld.pas</code>.</li> </ol>"},{"location":"docs/basics/basic-hello-world/#compile-run_1","title":"Compile &amp; Run","text":""},{"location":"docs/basics/basic-hello-world/#windows-cli","title":"Windows CLI","text":"<p>On Windows, compile and run as follows.</p> <pre><code>&gt; fpc HelloWorld.pas &amp;&amp; HelloWorld.exe\n</code></pre> <p>Tip</p> <p>If running <code>fpc</code> from CLI doesn't work, try one of the following options.</p> <ol> <li>Supply the full path to the <code>fpc</code>.</li> <li>Put the <code>fpc/bin/&lt;architecture&gt;</code> to your <code>PATH</code> then compile and run again.</li> <li>Consider using Lazarus IDE instead.</li> <li>Are you a VSCode or VSCodium user? Make sure to setup Pascal by Allesandro Fragnani properly.</li> <li>Have you considered OmniPascal?</li> </ol>"},{"location":"docs/basics/basic-hello-world/#linux-cli","title":"Linux CLI","text":"<p>On Linux, compile and run as follows.</p> <pre><code>$ fpc HelloWorld.pas &amp;&amp; ./HelloWorld\n</code></pre>"},{"location":"docs/basics/common-data-types/","title":"Common Data Types in Free Pascal","text":"<p>Here is a list of common data types in Free Pascal, along with a simple example.</p> <p>See the official docs for more info; Types.</p>"},{"location":"docs/basics/common-data-types/#summary-table","title":"Summary Table","text":"Type Data Type Range / Size Integer <code>Byte</code> 0 .. 255 Integer <code>ShortInt</code> -128 .. 127 Integer <code>SmallInt</code> -32,768 .. 32,767 Integer <code>Integer</code> -2,147,483,648 .. 2,147,483,647 Integer <code>LongInt</code> Same as <code>Integer</code> Integer <code>Int64</code> -9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807 Integer <code>Word</code> 0 .. 65,535 Integer <code>Cardinal</code> 0 .. 4,294,967,295 Integer <code>QWord</code> 0 .. 18,446,744,073,709,551,615 Boolean <code>Boolean</code> <code>True</code> or <code>False</code> Character <code>Char</code> ASCII characters String <code>String</code> Default length 255 characters Floating-Point <code>Single</code> \u00b11.5 x 10^\u221245 .. \u00b13.4 x 10^38 Floating-Point <code>Real</code> Similar to <code>Single</code> Floating-Point <code>Double</code> \u00b15.0 x 10^\u2212324 .. \u00b11.7 x 10^308 Floating-Point <code>Extended</code> More precise than <code>Double</code> (varies by implementation) Enumerated <code>Enum</code> User-defined values Subrange <code>Subrange</code> Defined range Record <code>Record</code> User-defined complex type Advanced Record <code>Adv Record</code> Records with methods Array <code>Static Array</code> Fixed size Array <code>Dynamic Array</code> Variable size Pointer <code>Pointer</code> Memory address of a type"},{"location":"docs/basics/common-data-types/#integer-types","title":"Integer Types","text":""},{"location":"docs/basics/common-data-types/#byte","title":"Byte","text":"<ul> <li>Range: 0 .. 255</li> <li>Example:</li> </ul> <pre><code>var\n  b: Byte; \nbegin   \n  b := 100;   \n  WriteLn(b); \nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#shortint","title":"ShortInt","text":"<ul> <li>Range: -128 .. 127</li> <li>Example:</li> </ul> <pre><code>var   \n  s: ShortInt; \nbegin   \n  s := -50;   \n  WriteLn(s); \nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#smallint","title":"SmallInt","text":"<ul> <li>Range: -32,768 .. 32,767</li> <li>Example:</li> </ul> <pre><code>var\n  sm: SmallInt;\nbegin\n  sm := 32000;\n  WriteLn(sm);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#integer","title":"Integer","text":"<ul> <li>Range: -2,147,483,648 .. 2,147,483,647</li> <li>Example:</li> </ul> <pre><code>var\n  i: Integer;\nbegin\n  i := 1234567890;\n  WriteLn(i);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#longint","title":"LongInt","text":"<ul> <li>Range: Same as <code>Integer</code></li> <li>Example:</li> </ul> <pre><code>var\n  li: LongInt;\nbegin\n  li := -2147483648;\n  WriteLn(li);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#int64","title":"Int64","text":"<ul> <li>Range: -9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807</li> <li>Example:</li> </ul> <pre><code>var\n  i64: Int64;\nbegin\n  i64 := 9223372036854775807;\n  WriteLn(i64);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#word","title":"Word","text":"<ul> <li>Range: 0 .. 65,535</li> <li>Example:</li> </ul> <pre><code>var\n  w: Word;\nbegin\n  w := 65535;\n  WriteLn(w);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#cardinal","title":"Cardinal","text":"<ul> <li>Range: 0 .. 4,294,967,295</li> <li>Example:</li> </ul> <pre><code>var\n  c: Cardinal;\nbegin\n  c := 4294967295;\n  WriteLn(c);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#qword","title":"QWord","text":"<ul> <li>Range: 0 .. 18,446,744,073,709,551,615</li> <li>Example:</li> </ul> <pre><code>var\n  qw: QWord;\nbegin\n  qw := 18446744073709551615;\n  WriteLn(qw);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#boolean","title":"Boolean","text":"<ul> <li>Values: <code>True</code> or <code>False</code></li> <li>Example:</li> </ul> <pre><code>var\n  qw: QWord;\nbegin\n  qw := 18446744073709551615;\n  WriteLn(qw);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#char-character","title":"Char (Character)","text":"<ul> <li>Range: 'A' .. 'Z', 'a' .. 'z', and other ASCII characters</li> <li>Example:</li> </ul> <pre><code>var\n  c: Char;\nbegin\n  c := 'A';\n  WriteLn(c);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#string","title":"String","text":"<ul> <li>Length: Default length is 255 characters</li> <li>Example:</li> </ul> <pre><code>var\n  str: String;\nbegin\n  str := 'Hello, Pascal!';\n  WriteLn(str);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#floating-point-types","title":"Floating-Point Types","text":""},{"location":"docs/basics/common-data-types/#single","title":"Single","text":"<ul> <li>Range: Approximately \u00b11.5 x 10^\u221245 .. \u00b13.4 x 10^38</li> <li>Example:</li> </ul> <pre><code>var\n  s: Single;\nbegin\n  s := 3.14;\n  WriteLn(s);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#real","title":"Real","text":"<ul> <li>Range: Varies by implementation, usually similar to <code>Single</code></li> <li>Example:</li> </ul> <pre><code>var\n  r: Real;\nbegin\n  r := 2.71828;\n  WriteLn(r);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#double","title":"Double","text":"<ul> <li>Range: Approximately \u00b15.0 x 10^\u2212324 .. \u00b11.7 x 10^308</li> <li>Example:</li> </ul> <pre><code>var\n  d: Double;\nbegin\n  d := 1.7976931348623157E+308;\n  WriteLn(d);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#extended","title":"Extended","text":"<ul> <li>Range: Varies by implementation, generally more precise than <code>Double</code></li> <li>Example:</li> </ul> <pre><code>var\n  e: Extended;\nbegin\n  e := 1.0e+308;\n  WriteLn(e);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#enumerated-types","title":"Enumerated Types","text":"<ul> <li>Example:</li> </ul> <pre><code>type\n  TColor = (Red, Green, Blue);\nvar\n  color: TColor;\nbegin\n  color := Green;\n  WriteLn(color);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#subrange-types","title":"Subrange Types","text":"<ul> <li>Example:</li> </ul> <pre><code>type\n  TSmallRange = 1..100;\nvar\n  r: TSmallRange;\nbegin\n  r := 50;\n  WriteLn(r);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#record-types","title":"Record Types","text":"<ul> <li>Example:</li> </ul> <pre><code>type\n  TPerson = record\n    Name: String;\n    Age: Integer;\n  end;\nvar\n  person: TPerson;\nbegin\n  person.Name := 'Alice';\n  person.Age := 30;\n  WriteLn(person.Name, ' is ', person.Age, ' years old.');\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#advanced-records-with-methods","title":"Advanced Records (with methods)","text":"<ul> <li>Example:</li> </ul> <pre><code>type\n  TAdvancedPerson = record\n    Name: String;\n    Age: Integer;\n    procedure DisplayInfo;\n  end;\nprocedure TAdvancedPerson.DisplayInfo;\nbegin\n  WriteLn(Name, ' is ', Age, ' years old.');\nend;\nvar\n  person: TAdvancedPerson;\nbegin\n  person.Name := 'Bob';\n  person.Age := 40;\n  person.DisplayInfo;\nend.    \n</code></pre>"},{"location":"docs/basics/common-data-types/#arrays","title":"Arrays","text":""},{"location":"docs/basics/common-data-types/#static-array","title":"Static Array","text":"<ul> <li>Example:</li> </ul> <pre><code>var   \n  arr: array[1..5] of Integer; \nbegin   \n  arr[1] := 10;\n  WriteLn(arr[1]);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#dynamic-array","title":"Dynamic Array","text":"<ul> <li>Example:</li> </ul> <pre><code>var\n  arr: array of Integer;\n  i: Integer;\nbegin\n  SetLength(arr, 5);\n\n  for i := 0 to High(arr) do\n    arr[i] := i * 10;\n\n  for i := 0 to High(arr) do\n    WriteLn(arr[i]);\nend.\n</code></pre>"},{"location":"docs/basics/common-data-types/#pointers","title":"Pointers","text":"<ul> <li>Example:</li> </ul> <pre><code>var\n  p: ^Integer;\n  x: Integer; \nbegin   \n  New(p);\n  p^ := 10;\n  x := p^;\n  WriteLn(x);\n  Dispose(p); \nend. \n</code></pre>"},{"location":"docs/basics/install/","title":"Setup Lazarus IDE and FPC","text":"<p>Here are two easy ways to set up Lazarus IDE and Free Pascal Compiler (FPC) on your system.</p> <ul> <li>Use Lazarus IDE's Installer (easiest)</li> <li>Use <code>fpcupdeluxe</code> (more options)</li> </ul>"},{"location":"docs/basics/install/#use-lazarus-ides-installer-easiest","title":"Use Lazarus IDE's Installer (easiest)","text":"<ol> <li> <p>Head to https://www.lazarus-ide.org.</p> </li> <li> <p>Click the Download button to get an installer for your OS</p> </li> </ol> <p></p>"},{"location":"docs/basics/install/#use-fpcupdeluxe-more-options","title":"Use <code>fpcupdeluxe</code> (more options)","text":""},{"location":"docs/basics/install/#install-on-windows","title":"Install on Windows","text":""},{"location":"docs/basics/install/#get-the-installer","title":"Get the installer","text":"<ol> <li>Head to https://github.com/LongDirtyAnimAlf/fpcupdeluxe/releases</li> <li>Download the latest <code>fpcupdeluxe</code> for your OS and architecture, and save it in a new folder.</li> <li>Run <code>fpcupdeluxe</code>.</li> </ol>"},{"location":"docs/basics/install/#get-latest-fixes","title":"Get latest fixes","text":"<p>Steps.</p> <ol> <li>Set installation path.</li> <li>Click the Fixes button.</li> <li>Click Yes when the confirmation box appears. </li> </ol> <p></p> <p>The installtion of FPC and Lazarus might take a while. Sit back and relax.</p> <p>Once succesfully installed, the console will let you know a shortcut to Lazarus IDE is available on the Windows desktop.</p> <pre><code>SUCCESS: installation by fpcupdeluxe complete !\n\nFpcupdeluxe has created a desktop shortcut to start Lazarus.\nShortcut-name: Lazarus_fpcupdeluxe\nLazarus by fpcupdeluxe MUST be started with this shortcut !!\n</code></pre> <p></p>"},{"location":"docs/basics/install/#add-recommended-modules","title":"Add recommended modules","text":"<p>There are two more recommended modules to install.</p> <ul> <li>With the Online Package Manager (OPM), you can easily install online packages right within the Lazarus IDE.</li> <li>The Dock (anchordocking) module turns the Lazarus IDE into a one-window setup.</li> </ul> <p>Steps.</p> <ol> <li>Click on the Modules tab.</li> <li>Click on the OPM button. Click yes when the confirmation box appears. Wait until the installation is completed before moving to the last step.</li> <li>Click on the Dock button. Click yes when the confirmation box appears.</li> </ol> <p></p> <p>Once the installation is completed succesfully, close <code>fcpupdeluxe</code>.</p>"},{"location":"docs/basics/install/#launch-lazarus-ide","title":"Launch Lazarus IDE","text":"<p>At the end of the installation, you will find <code>Lazarus_fcpupdeluxe</code> on your desktop.</p> <p>Double click to run it. You will see Lazarus IDE as shown below.</p> <p></p>"},{"location":"docs/basics/install/#install-on-linux-or-macos","title":"Install on Linux or macOS","text":"<p>Consult the <code>fpcupdeluxe</code> github page.</p>"},{"location":"docs/basics/intro-objpas-fpc/","title":"Intro to Object Pascal using FPC","text":"<p>This page is my go-to guide to the key basics of Object Pascal with the Free Pascal Compiler. It's not a complete guide, but it\u2019s got all the essentials to help you dive in and discover just how powerful Free Pascal can be!</p> <p>Hope you find it helpful! \ud83d\ude80</p> <p>Note</p> <p>Setup the Lazarus IDE (which includes the Free Pascal Compiler) for your OS to run the snippets on this page.</p>"},{"location":"docs/basics/intro-objpas-fpc/#1-hello-world","title":"1. Hello, World!","text":"<p>Here is a simple program that prints <code>Hello, World!</code> in Free Pascal.</p> <pre><code>begin\n  WriteLn('Hello, World!');\nend.\n</code></pre> <p>Tip: Running from the Lazarus IDE</p> <p>When running a console program in the Lazarus IDE, the console window may close too quickly to see the output. </p> <p>Use <code>ReadLn</code> to keep it open until you press the Enter key.</p> <pre><code>begin\n  WriteLn('Hello, World!');\n  ReadLn; // Waits for the user to press Enter\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#2-reserved-words","title":"2. Reserved Words","text":"<p>Reserved words are special words in the Pascal language that you cannot change or redefine.</p> <p>Note</p> <p>The Free Pascal Compiler lets you use uppercase or lowercase letters for these special words; they will work the same way.</p> <p>The following keywords exist in Turbo Pascal mode.</p> <pre><code>absolute    file            object      string  \nand         for             of          then  \narray       function        operator    to  \nasm         goto            or          type  \nbegin       if              packed      unit  \ncase        implementation  procedure   until  \nconst       in              program     uses  \nconstructor inherited       record      var  \ndestructor  inline          reintroduce while   \ndiv         interface       repeat      with  \ndo          label           self        xor\ndownto      mod             set         \nelse        nil             shl         \nend         not             shr         \n</code></pre> <p>The special words in Object Pascal (used in Delphi or Objfpc mode) are the same as in Turbo Pascal, but with these extra keywords:</p> <pre><code>as              finalization    library     raise   \nclass           finally         on          resourcestring     \ndispinterface   initialization  out         threadvar  \nexcept          inline          packed      try \nexports         is              property    \n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#3-comments","title":"3. Comments","text":"<p>Comments are pieces of the source code which are completely discarded by the compiler.</p> <p>In Free Pascal, you can create comments by using the following methods:</p> <ol> <li><code>(*</code> and <code>*)</code></li> <li><code>{</code> and <code>}</code></li> <li><code>//</code></li> </ol> <p>Tip</p> <p>Mobius1 \u2014 2024-10-06 at 08:15</p> <p>Suggested the addition of <code>(* ... *)</code>. Since <code>{ ... }</code> can be combined with directives, it may confuse the syntax checker.</p> <p>You can use <code>(* ... *)</code> to prevent accidental <code>{ }</code>.</p> <pre><code>(*\n   Example of multiple lines commented.\n   And immune to accidental }\n*)\n</code></pre> <p>Examples</p> <pre><code>(*\n Example of multiple lines commented.\n And immune to accidental }\n*)\n\n{  This is a single line comment. }  \n\n// This is a single line comment. All is ignored till the end of the line.\n\n{\n  This is a multi-line comment in Object Pascal.\n  You can write as much text as you want here,\n  and it will all be ignored by the compiler.\n  Multi-line comments are useful for explaining\n  more complex parts of your code or adding\n  detailed documentation.\n}\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#4-main-block","title":"4. Main Block","text":"<p>An Object Pascal program must have a main (program) block, marked by <code>begin ... end.</code>. Note the <code>.</code> after the <code>end</code>.</p> <pre><code>{ This is the main block }\nbegin\n  { ... your code ... }\n\n  // Example, print a message.\n  WriteLn('Hello, World!');\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#5-variable-and-basic-types","title":"5. Variable and Basic Types","text":""},{"location":"docs/basics/intro-objpas-fpc/#declaration","title":"Declaration","text":"<p>Declare variables within the <code>var</code> section of your program.</p> <p>Syntax</p> <pre><code>var\n  variableName:dataType; \n</code></pre> <p>Example</p> <p>Here's a simple example of declaring basic variable types in Free Pascal.</p> <pre><code>var\n  myChar: char;       // A single character, like 'A' or 'b'\n  myString: string;   // A sequence of characters, like \"Hello, world!\"\n  myInt: integer;     // A whole number, like 42 or -7\n  myBool: boolean;    // A true or false value\n  myReal: real;       // A number with decimals, like 3.14 or -0.5\n</code></pre> <p>Check out the official documentation Types for a full list and explanation of the types you can use.</p>"},{"location":"docs/basics/intro-objpas-fpc/#assignment","title":"Assignment","text":"<p>Tip</p> <p>After declaring a variable, make sure to initialise it before use, else you might end up with a garbage value.</p> <p>Note</p> <p><code>:=</code> is assignment.</p> <p><code>=</code>  is comparison, equality.</p> <p>Use <code>:=</code> for assigning a variable to a value.</p> <p>Syntax</p> <pre><code>variableName := value\n</code></pre> <p>Example</p> <pre><code>program BasicVariableTypes;\n\n  {$mode objfpc}{$H+}{$J-}\n\nvar\n  myChar: char;       // A single character, like 'A' or 'b'\n  myString: string;   // A sequence of characters, like \"Hello, world!\"\n  myInt: integer;     // A whole number, like 42 or -7\n  myBool: boolean;    // A true or false value\n  myReal: real;       // A number with decimals, like 3.14 or -0.5\n\nbegin\n  // Assign values to the variables\n  myChar := 'A';\n  myString := 'Hello, World!';\n  myInt := 42;\n  myBool := True;\n  myReal := 1234.5678;\n\n  // Print the values of the variables to the console\n  Writeln('Character: ', myChar);\n  Writeln('String: ', myString);\n  Writeln('Integer: ', myInt);\n  Writeln('Boolean: ', myBool);\n  Writeln('Real: ', myReal:0:4);\n\n  // Pause Console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#6-console","title":"6. Console","text":""},{"location":"docs/basics/intro-objpas-fpc/#user-input","title":"User Input","text":"<p>In Free Pascal, <code>Read</code> and <code>ReadLn</code> are used for input, but they work a bit differently.</p> <p>Use <code>Read</code> when you want to read input without moving to the next line.</p> <pre><code>{$mode objfpc}{$H+}{$J-}\nvar\n  num1, num2: integer;\nbegin\n  { Using Read -- The next value read will be num 2. }\n  Write('Enter two numbers: ');\n  Read(num1);\n  Read(num2);\n  WriteLn('You entered: ', num1, ' and ', num2);\nend.\n</code></pre> <p>Use <code>ReadLn</code> when you want to read input and move to the next line afterward.</p> <pre><code>{$mode objfpc}{$H+}{$J-}\nvar\n  num1, num2: integer;\nbegin\n  { Using ReadLn -- The next value after a new line will be num 2. }\n  Write('Enter two numbers on separate lines: ');\n  ReadLn(num1);\n  ReadLn(num2);\n  WriteLn('You entered: ', num1, ' and ', num2);\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#display-text","title":"Display Text","text":"<p>Similarly, <code>Write</code> and <code>WriteLn</code> are used to output text, but they behave differently.</p> <p>Use <code>Write</code> to output text without moving to the next line. It keeps the cursor on the same line, so subsequent output will continue from where the previous output ended.</p> <pre><code>{$mode objfpc}{$H+}{$J-}\n\nbegin\n  { Using Write -- World! appears after Hello. }\n  Write('Hello '); // No new line at the end of the string.\n  Write('World!'); // No new line at the end of the string.\n\n  // A spacer\n  WriteLn;\nend.\n</code></pre> <p>Use <code>WriteLn</code> to output text and then moves the cursor to the next line. It adds a newline character after the text, so any subsequent output starts on a new line.</p> <pre><code>{$mode objfpc}{$H+}{$J-}\n\nbegin\n  { Using WriteLn -- World! appears underneath Hello. }\n  WriteLn('Hello '); // There is a new line at the end of the string.\n  WriteLn('World!'); // There is a new line at the end of the string.\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#7-routines","title":"7. Routines","text":""},{"location":"docs/basics/intro-objpas-fpc/#procedure","title":"Procedure","text":"<p>A <code>procedure</code> is a block of code that performs a specific task but does not return a value. Use it when you want to execute a series of statements without returning a result.</p> <p>Syntax</p> <pre><code>procedure ProcedureName(AParam:Type;...);\nconst\n  { const section }\nvar\n  { var section }\nbegin\n  { your code goes here }\nend;\n</code></pre> <p>Example - Procedure without parameters</p> <pre><code>program ExampleProcedureWithoutParams;\n\nprocedure Greet;\nbegin\n  WriteLn('Hello, World!');\nend;\n\nbegin\n  Greet;  // Calling the procedure\nend.\n</code></pre> <p>Example - Procedure with Parameters</p> <pre><code>program ExampleProcedureWithParams;\n\nprocedure Greet(name: string);\nbegin\n  WriteLn('Hello, ', name, '!');\nend;\n\nbegin\n  Greet('Alice'); // Calling the procedure with arguments\nend.\n</code></pre> <p>Example - Procedure with <code>var</code> section</p> <pre><code>program ExampleProcedureWithVarSection;\n\nprocedure SwapNumbers(var x, y: integer);\nvar\n  temp: integer;  // Local variable to help with swapping\nbegin\n  temp := x;  // Store the value of x in temp\n  x := y;     // Assign the value of y to x\n  y := temp;  // Assign the value of temp (original x) to y\nend;\n\nvar\n  a, b: integer;\n\nbegin\n  a := 10;\n  b := 20;\n\n  WriteLn('Before swapping: a = ', a, ', b = ', b);\n\n  SwapNumbers(a, b);  // Call the procedure to swap the values\n\n  WriteLn('After swapping: a = ', a, ', b = ', b);\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#function","title":"Function","text":"<p>A <code>function</code> is similar to a procedure but it returns a value. Use this when you need to perform a task and get a result back.</p> <p>Syntax</p> <pre><code>function FunctionName(AParam:Type;...): Type;\nconst\n  { const section }\nvar\n  { var section }\nbegin\n  { your code goes here }\n  Result := {value to return} \nend;\n</code></pre> <p>Example - Function without parameters</p> <pre><code>program ExampleFunctionWithoutParams;\n\nfunction GetGreeting: string;\nbegin\n  Result := 'Hello, World!';\nend;\n\nbegin\n  WriteLn(GetGreeting);  // Calling the function and printing the result\nend.\n</code></pre> <p>Example - Function with parameters</p> <pre><code>program ExampleFunctionWithParams;\n\nfunction Add(a, b: integer): integer;\nbegin\n  Result := a + b; // Returning the product\nend;\n\nbegin\n  WriteLn('3 + 5 = ', Add(3, 5));\nend.\n</code></pre> <p>Example - Function with <code>var</code> section</p> <pre><code>program ExampleFunctionWithVarSection;\n\nfunction Factorial(n: integer): integer;\nvar\n  i, tempCalc: integer;\nbegin\n  tempCalc := 1;\n  for i := 1 to n do\n    tempCalc := tempCalc * i;\n  Result := tempCalc;\nend;\n\nbegin\n  WriteLn('Factorial of 5 is: ', Factorial(5));\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#8-loops","title":"8. Loops","text":""},{"location":"docs/basics/intro-objpas-fpc/#the-forto-statement","title":"The <code>for..to</code> Statement","text":"<p>Syntax</p> <pre><code>for counter := startValue to endValue do\nbegin\n  // statements\nend;\n</code></pre> <p>Example of <code>for..to..do</code> loop</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  i: integer;\n\n  // Main block\nbegin\n  for i := 1 to 10 do\n  begin\n    WriteLn('i = ', i);\n  end;\nend.\n</code></pre> <p>Example of <code>for..downto..do</code> Loop</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  i: integer;\n\n  // Main block\nbegin\n  for i := 10 downto 1 do\n  begin\n    WriteLn('i = ', i);\n  end;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#the-forin-statement","title":"The <code>for..in</code> Statement","text":"<p>Syntax</p> <pre><code>for element in collection do\nbegin\n  // Your code here\nend;\n</code></pre> <p>Example</p> <pre><code>program ForInLoop;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils;\n\nvar\n  numbers: array of integer;\n  num: integer;\n\n  // Main block\nbegin\n  // Initialize the array\n  numbers := [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  // Use the for..in loop to iterate over the array\n  for num in numbers do\n  begin\n    WriteLn('Number: ', num);\n  end;\n\n  // Pause console\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#9-conditional-loops","title":"9. Conditional Loops","text":""},{"location":"docs/basics/intro-objpas-fpc/#the-while-statement","title":"The <code>while</code> Statement","text":"<p>The <code>while</code> loop is used to repeat a block of statements as long as a condition is true.</p> <p>Syntax</p> <pre><code>while condition do\nbegin\n  // statements\nend;\n</code></pre> <p>Example</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  i: integer;\n\n  // Main block\nbegin\n  i := 1;\n  while i &lt;= 10 do\n  begin\n    WriteLn('i = ', i);\n    i := i + 1;\n  end;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#the-repeat-statement","title":"The <code>repeat</code> Statement","text":"<p>The <code>repeat..until</code> loop is similar to the <code>while</code> loop, but the condition is checked after the loop has executed, ensuring the statements are executed at least once.</p> <p>Syntax</p> <pre><code>repeat\n  // statements\nuntil condition;\n</code></pre> <p>Example</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  i: integer;\n\n  // Main block\nbegin\n  i := 1;\n  repeat\n    WriteLn('i = ', i);\n    i := i + 1;\n  until i &gt; 10;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#10-choices-and-decisions","title":"10. Choices and Decisions","text":""},{"location":"docs/basics/intro-objpas-fpc/#the-case-statement","title":"The <code>case</code> Statement","text":"<p>Syntax</p> <pre><code>case expression of\n  value1: \n    begin\n      // statements for value1\n    end;\n  value2: \n    begin\n      // statements for value2\n    end;\n  value3, value4: \n    begin\n      // statements for value3 and value4\n    end;\n  else\n    begin\n      // statements if none of the above values match\n    end;\nend;\n</code></pre> <p>Example</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  grade: char;\n\n  // Main block\nbegin\n  Write('Enter a grade (A, B, C, D or F): ');\n  ReadLn(grade);\n\n  case grade of\n    'A': \n      begin\n        WriteLn('Excellent!');\n      end;\n    'B': \n      begin\n        WriteLn('Good job!');\n      end;\n    'C': \n      begin\n        WriteLn('Well done.');\n      end;\n    'D': \n      begin\n        WriteLn('You passed.');\n      end;\n    'F': \n      begin\n        WriteLn('You failed!');\n      end;\n    else\n      begin\n        WriteLn('Invalid grade');\n      end;\n  end;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#the-if-statement","title":"The <code>if</code> Statement","text":"<p>Syntax</p> <pre><code>if condition then\nbegin\n  // statements to execute if condition is true\nend;\n</code></pre> <p>Optionally, you can include an else part to execute a different block of code if the condition is false.</p> <pre><code>if condition then\nbegin\n  // statements to execute if condition is true\nend\nelse\nbegin\n  // statements to execute if condition is false\nend;\n</code></pre> <p>For multiple conditions, you can use else if:</p> <pre><code>if condition1 then\nbegin\n  // statements to execute if condition1 is true\nend\nelse if condition2 then\nbegin\n  // statements to execute if condition2 is true\nend\nelse\nbegin\n  // statements to execute if none of the conditions are true\nend;\n</code></pre> <p>Example of <code>if..then</code> Statement</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  age: integer;\n\n  // Main block\nbegin\n  Write('Enter your age: ');\n  ReadLn(age);\n\n  if age &gt;= 18 then\n  begin\n    WriteLn('You are an adult.');\n  end;\nend.\n</code></pre> <p>Example of <code>if..then..else</code> Statement</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  age: integer;\n\n  // Main block\nbegin\n  Write('Enter your age: ');\n  ReadLn(age);\n\n  if age &gt;= 18 then\n  begin\n    WriteLn('You are an adult.');\n  end\n  else\n  begin\n    WriteLn('You are a minor.');\n  end;\nend.\n</code></pre> <p>Example of many conditions with <code>else if</code> Statement</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\nvar\n  grade: char;\n\n  // Main block\nbegin\n  Write('Enter your grade (A, B, C, D, F): ');\n  ReadLn(grade);\n\n  if grade = 'A' then\n  begin\n    WriteLn('Excellent!');\n  end\n  else if grade = 'B' then\n  begin\n    WriteLn('Good job!');\n  end\n  else if grade = 'C' then\n  begin\n    WriteLn('Well done.');\n  end\n  else if grade = 'D' then\n  begin\n    WriteLn('You passed.');\n  end\n  else if grade = 'F' then\n  begin\n    WriteLn('Failed subject!');\n  end\n  else\n  begin\n    WriteLn('Invalid grade.');\n  end;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#11math-operations","title":"11.Math Operations","text":"Operator/Function Description <code>+</code>  (Addition) Adds numbers together. <code>-</code>  (Subtraction) Subtracts one number from another. <code>*</code>  (Multiplication) Multiplies numbers. <code>Power</code> Require unit <code>Math</code>. Raises one number to the power of another. <code>div</code> (Division) Divides numbers and returns the whole number part of the result. <code>/</code>   (Real Division) Divides numbers and includes the decimal part of the result. <code>LogN(n, a)</code> Require unit <code>Math</code>. Calculates the logarithm base n of a number. <code>mod</code> (Modulus) Returns the remainder when one number is divided by another. <p>Example</p> <pre><code>program BasicMathOperations;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Math; // Include the Math unit for Power and Logarithm functions\n\nvar\n  a, b, intResult: integer;\n  realResult: real;\n\nbegin\n  // Assign values to variables\n  a := 10;\n  b := 3;\n\n  // Addition\n  intResult := a + b;\n  WriteLn('Addition: ', a, ' + ', b, ' = ', intResult);\n\n  // Subtraction\n  intResult := a - b;\n  WriteLn('Subtraction: ', a, ' - ', b, ' = ', intResult);\n\n  // Multiplication\n  intResult := a * b;\n  WriteLn('Multiplication: ', a, ' * ', b, ' = ', intResult);\n\n  // Power\n  realResult := Power(a, b); // 'Power' is used to calculate a^b\n  WriteLn('Power: ', a, ' ^ ', b, ' = ', realResult: 0: 0);\n\n  // Division\n  intResult := a div b; // 'div' is used for integer division\n  WriteLn('Division: ', a, ' div ', b, ' = ', intResult);\n\n  // Real (Float) Division\n  realResult := a / b; // '/' is used for real division\n  WriteLn('Real (Float) Division: ', a, ' / ', b, ' = ', realResult: 0: 6);\n\n  // Logarithm with Arbitrary Base (LogN)\n  realResult := LogN(b, a); // 'LogN' is used to calculate logarithm base b\n  WriteLn('Logarithm Base ', b, ': LogN(', b, ', ', a, ') = ', realResult: 0: 6);\n\n  // Modulus\n  intResult := a mod b; // 'mod' is used to find the remainder\n  WriteLn('Modulus: ', a, ' mod ', b, ' = ', intResult);\n\n  // Pause console\n  WriteLn('Press enter key to exit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#12-round-floats","title":"12. Round Floats","text":""},{"location":"docs/basics/intro-objpas-fpc/#to-nearest-integers","title":"To Nearest Integers","text":"<p>You can use the following functions.</p> <ul> <li><code>Round</code>: Rounds a floating-point number to the nearest integer uses banker's rounding.</li> <li><code>Ceil</code>: Rounds a floating-point number up to the nearest integer.</li> <li><code>Floor</code>: Rounds a floating-point number down to the nearest integer.</li> </ul> <p>Note</p> <p>For <code>Round</code>, in the case of .5 (equidistant from two numbers), the algorithm uses \"banker's rounding\": .5 values are always rounded towards the even number.</p> <p>Source: https://www.freepascal.org/docs-html/rtl/system/round.html</p> <p>Note</p> <p>Remember to add <code>Math</code> in the <code>uses</code> section <code>Ceil</code> and <code>Floor</code> functions.</p> <p>Examples</p> <pre><code>program RoundingExamples;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Math;  // Include the Math unit for Ceil and Floor\n\nvar\n  num: real;\n  rounded: integer;\n\n  // Main block\nbegin\n  num := 123.4567;\n\n  // Using Round\n  rounded := Round(num);  // Nearest integer, Banker's Rounding\n  WriteLn('Rounded value (Round): ', rounded);\n\n  // Using Ceil\n  rounded := Ceil(num);   // Always rounds up\n  WriteLn('Ceiling value (Ceil): ', rounded);\n\n  // Using Floor\n  rounded := Floor(num);  // Always rounds down\n  WriteLn('Floor value (Floor): ', rounded);\n\n  // Examples of Banker's Rounding\n  num := 2.5;\n  rounded := Round(num);  // Banker's Rounding\n  WriteLn('Rounded value for 2.5 (Banker''s Rounding): ', rounded);\n\n  num := 3.5;\n  rounded := Round(num);  // Banker's Rounding\n  WriteLn('Rounded value for 3.5 (Banker''s Rounding): ', rounded);\n\n  // Pause console\n  WriteLn('Press enter key to exit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#to-n-decimal-places","title":"To <code>n</code> Decimal Places","text":"<p>Use the RoundTo function.</p> <p>Note</p> <p><code>RoundTo</code> uses the standard <code>Round</code> function for this. Hence, in the case of .5 (equidistant from two numbers), the algorithm uses \"banker's rounding\": .5 values are always rounded towards the even number.</p> <p>Source: https://www.freepascal.org/docs-html/rtl/math/roundto.html</p> <p>Example</p> <pre><code>program NDecimalRoundingExample;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Math;\n\nvar\n  num: real;\n  rounded: real;\n  n: integer;\n\n  // Main block\nbegin\n  num := 12345.678875;\n  n := 4;  // Number of decimal places you want\n\n  rounded := RoundTo(num, -n);\n\n  WriteLn('Rounded Number: ', rounded: 0: 4);  // Format to 4 decimal places\n\n  // Pause console\n  WriteLn('Press enter key to exit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#13-bitwise-operations","title":"13. Bitwise Operations","text":"Operator Description Example Binary Notation Result <code>AND</code> Bitwise AND <code>5 and 3</code> <code>0101 and 0011</code> <code>0001</code> <code>OR</code> Bitwise OR <code>5 or 3</code> <code>0101 or 0011</code> <code>0111</code> <code>XOR</code> Bitwise XOR <code>5 xor 3</code> <code>0101 xor 0011</code> <code>0110</code> <code>NOT</code> Bitwise NOT (unary) <code>not 5</code> <code>not 0101</code> <code>...1010</code> (in 2's complement) <code>SHL</code> Shift left <code>5 shl 1</code> <code>0101 shl 1</code> <code>1010</code> <code>&lt;&lt;</code> Shift left (equivalent) <code>5 &lt;&lt; 1</code> <code>0101 &lt;&lt; 1</code> <code>1010</code> <code>SHR</code> Shift right <code>5 shr 1</code> <code>0101 shr 1</code> <code>0010</code> <code>&gt;&gt;</code> Shift right (equivalent) <code>5 &gt;&gt; 1</code> <code>0101 &gt;&gt; 1</code> <code>0010</code> <p>Examples</p> <pre><code>program BitwiseOperatorsDemos;\n\nvar\n  a, b, result: integer;\n\nbegin\n  a := 5;  // 0101 in binary\n  b := 3;  // 0011 in binary\n\n  // Bitwise AND\n  result := a and b;  // 0101 and 0011 = 0001 (1 in decimal)\n  writeln('AND: 5 and 3 = ', result, ' (', BinStr(result, 4), ')');\n\n  // Bitwise OR\n  result := a or b;  // 0101 or 0011 = 0111 (7 in decimal)\n  writeln('OR: 5 or 3 = ', result, ' (', BinStr(result, 4), ')');\n\n  // Bitwise XOR\n  result := a xor b;  // 0101 xor 0011 = 0110 (6 in decimal)\n  writeln('XOR: 5 xor 3 = ', result, ' (', BinStr(result, 4), ')');\n\n  // Bitwise NOT\n  result := not a;  // not 0101 = 1010 (in a 4-bit system, this is -6 in two's complement)\n  writeln('NOT: not 5 = ', result, ' (', BinStr(result, 4), ')');\n\n  // Shift left (SHL)\n  result := a shl 1;  // 0101 shl 1 = 1010 (10 in decimal)\n  writeln('SHL: 5 shl 1 = ', result, ' (', BinStr(result, 4), ')');\n\n  // Shift left (&lt;&lt;) - same as SHL\n  result := a &lt;&lt; 1;  // 0101 &lt;&lt; 1 = 1010 (10 in decimal)\n  writeln('&lt;&lt; : 5 &lt;&lt; 1 = ', result, ' (', BinStr(result, 4), ')');\n\n  // Shift right (SHR)\n  result := a shr 1;  // 0101 shr 1 = 0010 (2 in decimal)\n  writeln('SHR: 5 shr 1 = ', result, ' (', BinStr(result, 4), ')');\n\n  // Shift right (&gt;&gt;) - same as SHR\n  result := a &gt;&gt; 1;  // 0101 &gt;&gt; 1 = 0010 (2 in decimal)\n  writeln('&gt;&gt; : 5 &gt;&gt; 1 = ', result, ' (', BinStr(result, 4), ')');\n\n  readln;\nend.\n</code></pre> <p>Outputs</p> <pre><code>AND: 5 and 3 = 1 (0001)\nOR: 5 or 3 = 7 (0111)\nXOR: 5 xor 3 = 6 (0110)\nNOT: not 5 = -6 (1010)\nSHL: 5 shl 1 = 10 (1010)\n&lt;&lt; : 5 &lt;&lt; 1 = 10 (1010)\nSHR: 5 shr 1 = 2 (0010)\n&gt;&gt; : 5 &gt;&gt; 1 = 2 (0010)\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#14-boolean-operations","title":"14. Boolean Operations","text":"Operator Operation Description <code>not</code> Logical negation Inverts the boolean value: <code>True</code> becomes <code>False</code>, and <code>False</code> becomes <code>True</code>. <code>and</code> Logical conjunction Returns <code>True</code> only if both operands are <code>True</code>. <code>or</code> Logical disjunction Returns <code>True</code> if at least one operand is <code>True</code>. <code>xor</code> Exclusive OR Returns <code>True</code> if exactly one of the operands is <code>True</code>. <p>Note</p> <p>By default, boolean expressions are evaluated with short-circuit evaluation.</p> <p>This means that from the moment the result of the complete expression is known, evaluation is stopped and the result is returned. </p> <p>For instance, in the following expression:</p> <pre><code>B := True or MaybeTrue;\n</code></pre> <p>The compiler will never look at the value of <code>MaybeTrue</code>, since it is obvious that the expression will always be <code>True</code>. </p> <p>As a result of this strategy, if <code>MaybeTrue</code> is a function, it will not get called! (This can have surprising effects when used in conjunction with properties).</p> <p>Adapted from: https://www.freepascal.org/docs-html/current/ref/refsu46.html#x153-17700012.8.3</p> <p>Examples</p> <pre><code>var\n  a, b: boolean;\nbegin\n  a := True;\n  b := False;\n\n  Writeln('not a: ', not a);           // Outputs: False\n  Writeln('a and b: ', a and b);       // Outputs: False\n  Writeln('a or b: ', a or b);         // Outputs: True\n  Writeln('a xor b: ', a xor b);       // Outputs: True\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#15-string-operations","title":"15. String Operations","text":"<p>Useful strings operators and functions.</p> Operator/Function Description <code>+</code> Concatenates two strings. <code>CompareStr</code> Case-sensitive string comparison. Returns 0 if strings are the same. <code>CompareText</code> Case-insensitive string comparison. Returns 0 if strings are the same. <code>Length</code> Returns the string length. <code>Pos</code> Finds the position of a substring. <code>Copy</code> Extracts a substring from a string. <code>Delete</code> Removes part of a string. <code>Insert</code> Inserts a substring at a specific position. <code>StringReplace</code> Replaces a substring with options for case sensitivity and all occurrences. <code>str[n]</code> Accesses the character at the nth position. <code>UpperCase</code> Converts a string to uppercase. <code>LowerCase</code> Converts a string to lowercase. <p>Examples</p> <pre><code>program StringOperationsExample;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils;\n\nvar\n  str1, str2, str3, result: string;\n  position: integer;\n  comparisonResult: integer;\n\nbegin\n  str1 := 'Hello World';\n  str2 := 'Welcome to Pascal';\n  str3 := 'This is not easy!';\n\n  // Concatenation\n  result := str1 + ', ' + str2;\n  Writeln('Concatenated string: ', result);\n  // Outputs: Hello World, Welcome to Pascal\n\n  // CompareStr (case-sensitive)\n  comparisonResult := CompareStr(str1, 'hello world');\n  Writeln('CompareStr result: ', comparisonResult);\n  // Outputs: &lt; 0 , since orc('H') &lt; ord('h')\n\n  // CompareText (case-insensitive)\n  comparisonResult := CompareText(str1, 'hello world');\n  Writeln('CompareText result: ', comparisonResult);\n  // Outputs: 0,  since 'Hello World' = 'hello world' ignoring case\n\n  // Length\n  Writeln('Length of str1: ', Length(str1));\n  // Outputs: 11\n\n  // Pos\n  position := Pos('World', str1);\n  Writeln('Position of ''World'' in str1: ', position);\n  // Outputs: 7\n\n  // Copy\n  result := Copy(str1, Pos('World', str1), Length('World'));\n  Writeln('Copy ''World'' from str1: ', result);\n  // Outputs: World\n\n  // Delete\n  Delete(str3, Pos('not ', str3), Length('not '));\n  Writeln('After deleting ''NOT '' from str3: ', str3);\n  // Outputs: This is easy\n\n  // Insert\n  Insert('really ', str3, pos('easy', str3));\n  Writeln('After inserting ''really '' into str3: ', str3);\n  // Outputs: This is really easy\n\n  // StringReplace\n  result := StringReplace(str1, 'Hello', 'Hello Free Pascal', [rfReplaceAll, rfIgnoreCase]);\n  Writeln('After StringReplace to str1: ', result);\n  // Outputs: Hello Free Pascal\n\n  // Access character at position n\n  Writeln('Character at pos 7 in str2: ', str2[7]);\n  // Outputs: e\n\n  // UpperCase\n  result := UpperCase(str2);\n  Writeln('UpperCase of str2: ', result);\n  // Outputs: WELCOME TO FREE PASCAL\n\n  // LowerCase\n  result := LowerCase(str2);\n  Writeln('LowerCase of str2: ', result);\n  // Outputs: welcome to free pascal\n\n  //Pause console\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre> <p>Outputs</p> <pre><code>Concatenated string: Hello World, Welcome to Pascal\nCompareStr result: -32\nCompareText result: 0\nLength of str1: 11\nPosition of 'World' in str1: 7\nCopy 'World' from str1: World\nAfter deleting 'NOT ' from str3: This is easy!\nAfter inserting 'really ' into str3: This is really easy!\nAfter StringReplace to str1: Hello Free Pascal World\nCharacter at pos 7 in str2: e\nUpperCase of str2: WELCOME TO PASCAL\nLowerCase of str2: welcome to pascal\nPress enter key to quit\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#16-format-strings","title":"16. Format Strings","text":""},{"location":"docs/basics/intro-objpas-fpc/#format-numbers-with-commas","title":"Format Numbers with Commas","text":"<ol> <li>Include the <code>SysUtils</code> unit, as the <code>Format</code> function is part of this unit.</li> <li>Use the <code>Format</code> function with appropriate format specifiers.</li> </ol> <p>See Format for more info.</p> <p>Example</p> <pre><code>program FormatNumberCommas;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils;\n\nvar\n  number: int64;\n  formattedNumber: string;\n\n  // Main block\nbegin\n  // Formatting a number with commas\n  number := 12345678;\n  formattedNumber := Format('%.0n', [number * 1.0]);\n  WriteLn('Formatted Number: ', formattedNumber);  // Output: 12,345,678\n\n  // Pause console\n  WriteLn('Press enter key to exit');\n  ReadLn;\nend.\n</code></pre> <ul> <li><code>'%.0n'</code> format specifier means \"format as a number with no decimal places, using the locale's thousands separator\".</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#format-numbers-as-currency","title":"Format Numbers as Currency","text":"<ol> <li>Include the <code>SysUtils</code> unit, as the <code>CurrToStrF</code> function is part of this unit.</li> <li>Use the <code>CurrToStrF</code> function with appropriate format specifiers and decimal place.</li> </ol> <p>See <code>CurrToStrF</code> for more info.</p> <p>Example</p> <pre><code>program FormatCurrency;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils;\n\nvar\n  amount: currency;\n  formattedAmount: string;\n\n  // Main block\nbegin\n  amount := 12345678.90;\n  formattedAmount := CurrToStrF(amount, ffCurrency, 2);\n  WriteLn(formattedAmount);  // Output: $12,345,678.90\n\n  // Pause console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <ul> <li><code>CurrToStrF</code> function: This formats a number as currency. The parameters are:<ul> <li>The number to format.</li> <li><code>ffCurrency</code>: A format specifier indicating that we want currency formatting.</li> <li><code>2</code>: The number of decimal places.</li> </ul> </li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#17-processing-text-files","title":"17. Processing Text Files","text":""},{"location":"docs/basics/intro-objpas-fpc/#read-a-text-file","title":"Read a Text File","text":"<p>Here's an example to read a file line by line using <code>TFileStream</code> and <code>TStreamReader</code>:</p> <p>Example</p> <pre><code>program SimpleReadTextFile;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils,\n  Classes,\n  streamex;\n\nvar\n  fileStream: TFileStream;\n  streamReader: TStreamReader;\n  line: string;\n\n  // Main block\nbegin\n  try\n    // Open the file\n    fileStream := TFileStream.Create('your-file.csv', fmOpenRead);\n    try\n      streamReader := TStreamReader.Create(fileStream, 65536, False);\n      try\n        // Read the file line by line\n        while not streamReader.Eof do\n        begin\n          line := streamReader.ReadLine;\n          // Process the line (for now, we just print it)\n          Writeln(line);\n        end;\n      finally\n        // Clean up\n        streamReader.Free;\n      end;\n    finally\n      // Clean up\n      fileStream.Free;\n    end;\n  except\n    on E: Exception do\n      Writeln('An error occurred: ', E.Message);\n  end;\nend.\n</code></pre> <ul> <li>The <code>streamex</code> unit includes the <code>TStreamReader</code> class for handling text stream operations.</li> <li>The <code>try...finally</code> blocks guarantee that both <code>streamReader</code> and <code>fileStream</code> are properly released, even if an error occurs during the file reading process.</li> <li>Substitute <code>your-file.txt</code> with the name of your file.</li> <li>The <code>try...except</code> block handles any exceptions that arise during file operations and outputs an appropriate error message.</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#write-a-text-file","title":"Write a Text File","text":"<p>Example</p> <pre><code>program SimpleWriteTextFile;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Classes,\n  SysUtils;\n\nvar\n  text: string;\n  filename: string;\n  fileStream: TFileStream;\n  size: longint;\n\n  // Main block\nbegin\n  try\n    // String to be written\n    text := 'Hello Text!' + LineEnding + 'I''ll be written in a file!';\n\n    // Text file to write the text to\n    filename := 'hello-text.txt';\n\n    // Create a TFileStream\n    fileStream := TFileStream.Create(filename, fmCreate);\n    try\n      // Set writing position at the beginning of file\n      fileStream.Position := 0;\n      // Write text into the file and return written bytes\n      size := fileStream.Write(Text[1], Length(Text));\n      // Optional - Show confirmation\n      Writeln(Format('Created %s. %d bytes written.', [filename, size]));\n    finally\n      // Free TFileStream object\n      fileStream.Free;\n    end;\n  except\n    on E: Exception do\n      Writeln('An error occurred: ', E.Message);\n  end;\nend.\n</code></pre> <ul> <li>The <code>try...finally</code> block ensures that the fileStream is properly closed and released even if an exception occurs during the file writing process.</li> <li>Update the content of the Text variable with the string you want to write to the file.</li> <li>Change <code>hello-text.txt</code> to the name of the file you wish to create or modify.</li> <li>The <code>try...except</code> block captures any exceptions that might occur during file operations and displays an appropriate error message.</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#18-enum-types","title":"18. Enum Types","text":"<p>In Free Pascal, enumerated ordinal types are user-defined types that consist of a set of named values. These values are called enumeration constants, and each constant has an associated integer value, starting from 0 by default. </p> <p>Enumerated types provide a way to define a variable that can only take one of a specified set of values, making the code more readable and type-safe.</p> <p>Syntax</p> <pre><code>type\n  TEnumName = (Value1, Value2, Value3, ...);\n</code></pre> <p>Example</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\ntype\n  TDay = (Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday);\n\nvar\n  today: TDay;\n\n  // Main block\nbegin\n  // Assign today var to TDay.Wednesday \n  today := Wednesday;\n\n  WriteLn('Integer(today)      gives ', Integer(today));     // Prints 3\n  WriteLn('Integer(Wednesday)) gives ', Integer(Wednesday)); // Prints 3\n  WriteLn('TDay(0)             gives ', TDay(0));            // Prints Sunday\n\n  if today = Wednesday then\n  begin\n    WriteLn('Today is Wednesday');\n  end;\nend.\n</code></pre> <p>Example of an Enum in case statement</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\ntype\n  TColor = (Red, Green, Blue);\n\nvar\n  color: TColor;\n\n  // Main block\nbegin\n  color := Green;\n  case color of\n    Red: WriteLn('Red');\n    Green: WriteLn('Green');\n    Blue: WriteLn('Blue');\n  end;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#19-subrange-types","title":"19. Subrange Types","text":"<p>A subrange is a subset of values within a specific range. In Free Pascal, subranges allow you to limit the values a variable can hold, which can help catch errors and make your code more robust and readable.</p> <p>Syntax</p> <pre><code>type\n  SubrangeType = LowValue..HighValue;\n</code></pre> <p>Example</p> <pre><code>program SubrangeDaysofWeek;\n\n  {$mode objfpc}{$H+}{$J-}\n\ntype\n  // Define a subrange type for days of the week (1 = Sunday, 7 = Saturday)\n  TDayOfWeek = 1..7;\n\nvar\n  // Declare a variable of type TDayOfWeek\n  day: TDayOfWeek;\n\n  // Main block\nbegin\n  // Assign a valid value within the subrange to the variable\n  day := 3;  // 3 represents Tuesday\n  WriteLn('Day of the week is: ', day);\n\n  // Uncommenting the following line would cause a compile-time error\n  // because 8 is not within the defined subrange\n  // day := 8;  // This will cause a compile-time error\n\n  // Pause console\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre> <p>Note</p> <p>Why Not Just Use Integer?</p> <p>Using a subrange like <code>TDayOfWeek</code> instead of a plain integer provides type safety. It ensures that the variable <code>day</code> can only be assigned values within the defined range (<code>1</code> to <code>7</code>). </p> <p>This (1) helps prevent errors and makes your code more robust and (2) readable. For example, if you accidentally try to assign a value outside the range, the compiler will catch the error.</p>"},{"location":"docs/basics/intro-objpas-fpc/#20-arrays","title":"20. Arrays","text":"<p>Arrays are useful when you need to handle multiple values of the same type. For example, if you have grades for students, you can use an array to store all these grades and easily access each one by its position.</p>"},{"location":"docs/basics/intro-objpas-fpc/#defining-arrays","title":"Defining Arrays","text":"<p>1. Directly in the var section</p> <pre><code>var\n  numbers: array[1..5] of integer;\n</code></pre> <p>2. Using the type section</p> <pre><code>type\n  TNumberArray = array[1..5] of Integer;\n\nvar\n  numbers: TNumberArray;\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#working-with-arrays","title":"Working with Arrays","text":"<p>Example</p> <pre><code>var\n  numbers: array[1..5] of Integer;\n\n  // Main block\nbegin\n  numbers[1] := 10;  // Set the first element to 10\n  numbers[2] := 20;  // Set the second element to 20\n  WriteLn(numbers[1]); // This will print 10\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#static-arrays","title":"Static Arrays","text":"<p>Static arrays have a fixed size defined at compile time.</p> <p>Syntax</p> <pre><code>var\n  arrayName: array[startIndex..endIndex] of elementType;\n</code></pre> <p>Example</p> <pre><code>program StaticArrayExample;\n\nvar\n  numbers: array[1..5] of integer;\n  i: integer;\n\n  // Main block\nbegin\n  // Initialising the array\n  numbers[1] := 10;\n  numbers[2] := 20;\n  numbers[3] := 30;\n  numbers[4] := 40;\n  numbers[5] := 50;\n\n  // Accessing and printing array elements\n  for i := 1 to 5 do\n    WriteLn('numbers[', i, '] = ', numbers[i]);\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#dynamic-arrays","title":"Dynamic Arrays","text":"<p>Dynamic arrays can be resized at runtime using the <code>SetLength</code> procedure.</p> <p>Syntax</p> <pre><code>var\n  arrayName: array of elementType;\n</code></pre> <p>Example</p> <pre><code>program DynamicArrayExample;\n\nvar\n  numbers: array of integer;\n  i: integer;\n\n  // Main block\nbegin\n  // Setting the length of the array\n  SetLength(numbers, 5);\n\n  // Initialising the array\n  for i := 0 to High(numbers) do\n    numbers[i] := (i + 1) * 10;\n\n  // Accessing and printing array elements\n  for i := 0 to High(numbers) do\n    WriteLn('numbers[', i, '] = ', numbers[i]);\n\n  // Resizing the array\n  SetLength(numbers, 10);\n  for i := 5 to 9 do\n    numbers[i] := (i + 1) * 10;\n\n  // Accessing and printing array elements after resizing\n  for i := 0 to High(numbers) do\n    WriteLn('numbers[', i, '] = ', numbers[i]);\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#concat-dynamic-arrays","title":"Concat Dynamic Arrays","text":"<p>This operator is available in Delphi mode, but must be enabled explicily using the modeswitch arrayoperators in objfpc mode:</p> <pre><code>{$mode objfpc}  \n{$modeswitch arrayoperators}\n</code></pre> <p>Syntax</p> <pre><code>resultArray := array1 + array2;\n</code></pre> <p>Example</p> <pre><code>program DynArrayConcat;\n\n  {$mode objfpc}{$H+}{$J-}\n  {$modeswitch arrayoperators}\n\nuses\n  SysUtils;\n\ntype\n  TIntArray = array of integer;\n\nprocedure PrintArray(arr: TIntArray);\nvar\n  i: integer;\nbegin\n  for i := Low(arr) to High(arr) do\n    Write(arr[i], ' ');\n  WriteLn;\nend;\n\nvar\n  arr1, arr2, resultArr: TIntArray;\n\n  // Main block\nbegin\n  // Initialize the first array\n  arr1 := [1, 2, 3, 4, 5];\n\n  // Initialize the second array\n  arr2 := [6, 7, 8, 9, 10];\n\n  // Concatenate the arrays using the + operator\n  resultArr := arr1 + arr2;\n\n  // Print the arrays\n  WriteLn('Array 1:');\n  PrintArray(arr1);\n  WriteLn('Array 2:');\n  PrintArray(arr2);\n  WriteLn('Concatenated Array:');\n  PrintArray(resultArr);\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre> <p>See more info on the Dynamic Array Operators document.</p>"},{"location":"docs/basics/intro-objpas-fpc/#open-arrays","title":"Open Arrays","text":"<p>Open arrays are typically used in procedures or functions to accept arrays of varying sizes.</p> <p>Syntax</p> <pre><code>procedure ProcedureName(arrayName: array of elementType);\n</code></pre> <p>Example</p> <pre><code>program OpenArrayExample;\n\nprocedure PrintArray(arr: array of integer);\nvar\n  i: integer;\nbegin\n  for i := Low(arr) to High(arr) do\n    WriteLn('arr[', i, '] = ', arr[i]);\nend;\n\nvar\n  numbers: array[1..5] of integer;\n\n  // Main block\nbegin\n  // Initialising the array\n  numbers[1] := 10;\n  numbers[2] := 20;\n  numbers[3] := 30;\n  numbers[4] := 40;\n  numbers[5] := 50;\n\n  // Passing the array to the procedure\n  PrintArray(numbers);\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#21-records-types","title":"21. Records Types","text":"<p>Just for the <code>Record</code>, a <code>record</code> is a data structure that allows you to group different types of data together. This feature in Free Pascal allow you to create complex data structures and manage related data efficiently.</p> <p>Syntax</p> <pre><code>type\n  TRecordName = record\n    field1: dataType1;\n    field2: dataType2;\n    field3: dataType3;\n    // Add more fields as needed\n  end;\n</code></pre> <p>Example</p> <pre><code>  {$mode objfpc}{$H+}{$J-}\n\ntype\n  TPerson = record\n    name: string;\n    age: integer;\n    height: real;\n  end;\n\nvar\n  person1, person2: TPerson;\n\n  // Main block\nbegin\n  // Assign values to the fields of Person1\n  person1.Name := 'Javert';\n  person1.Age := 30;\n  person1.Height := 5.9;\n\n  // Print the values of Person1\n  WriteLn('Person1 Name: ', person1.Name);\n  WriteLn('Person1 Age: ', person1.Age);\n  WriteLn('Person1 Height: ', person1.Height:0:2);\n\n  // Assign values to the fields of Person2\n  person2.Name := 'Jean Valjean';\n  person2.Age := 25;\n  person2.Height := 5.7;\n\n  // Print the values of Person2\n  WriteLn('Person2 Name: ', person2.Name);\n  WriteLn('Person2 Age: ', person2.Age);\n  WriteLn('Person2 Height: ', person2.Height:0:2);\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#22-advanced-records","title":"22. Advanced Records","text":"<p>In Free Pascal, an advanced record is a type of record that can do more than just store data. It can also have methods (which are like functions or procedures) and properties (ways to get or set values) attached to it.</p> <p>You must include the following switch to use Advanced Records.</p> <pre><code>{$modeswitch advancedrecords}\n</code></pre> <p>Syntax</p> <pre><code>type\n  TMyRecord = record\n  private\n    // Private fields and methods\n    FField: integer;\n    procedure SetField(Value: integer);\n    function GetField: integer;\n  public\n    // Public methods and properties\n    procedure ShowInfo;\n    property Field: integer read GetField write SetField;\n  end;\n</code></pre> <p>Example: A Simple TRectangle Record</p> <p>Let\u2019s create an advanced record to represent a rectangle. This record will store the width and height of the rectangle and include methods to calculate the area and display the rectangle's details.</p> <p>We\u2019ll create a record called <code>TRectangle</code> that has fields for width and height. It will also include a method to calculate the area and another to display the details.</p> <pre><code>type\n  TRectangle = record\n  private\n    FWidth, FHeight: Double;\n    procedure SetWidth(Value: Double);\n    procedure SetHeight(Value: Double);\n    function GetWidth: Double;\n    function GetHeight: Double;\n  public\n    constructor Create(AWidth, AHeight: Double);\n    function Area: Double;\n    procedure ShowDetails;\n    property Width: Double read GetWidth write SetWidth;\n    property Height: Double read GetHeight write SetHeight;\n  end;\n\nconstructor TRectangle.Create(AWidth, AHeight: Double);\nbegin\n  FWidth := AWidth;\n  FHeight := AHeight;\nend;\n\nprocedure TRectangle.SetWidth(Value: Double);\nbegin\n  FWidth := Value;\nend;\n\nprocedure TRectangle.SetHeight(Value: Double);\nbegin\n  FHeight := Value;\nend;\n\nfunction TRectangle.GetWidth: Double;\nbegin\n  Result := FWidth;\nend;\n\nfunction TRectangle.GetHeight: Double;\nbegin\n  Result := FHeight;\nend;\n\nfunction TRectangle.Area: Double;\nbegin\n  Result := FWidth * FHeight;\nend;\n\nprocedure TRectangle.ShowDetails;\nbegin\n  WriteLn('Rectangle Width: ', FWidth:0:2);\n  WriteLn('Rectangle Height: ', FHeight:0:2);\n  WriteLn('Rectangle Area: ', Area:0:2);\nend;\n</code></pre> <p>We use the <code>TRectangle</code> like this:</p> <pre><code>var\n  Rect: TRectangle;\n\n  {Main Block}\nbegin\n  // Create a rectangle with width 10 and height 5\n  Rect := TRectangle.Create(10, 5);\n\n  // Show the details of the rectangle\n  Rect.ShowDetails;\nend.\n</code></pre> <p>Full Example</p> <pre><code>program AdvancedRecordDemo;\n\n{$mode objfpc}{$H+}{$J-}\n\ntype\n  TRectangle = record\n  private\n    FWidth, FHeight: Double;\n    procedure SetWidth(Value: Double);\n    procedure SetHeight(Value: Double);\n    function GetWidth: Double;\n    function GetHeight: Double;\n  public\n    constructor Create(AWidth, AHeight: Double);\n    function Area: Double;\n    procedure ShowDetails;\n    property Width: Double read GetWidth write SetWidth;\n    property Height: Double read GetHeight write SetHeight;\n  end;\n\nconstructor TRectangle.Create(AWidth, AHeight: Double);\nbegin\n  FWidth := AWidth;\n  FHeight := AHeight;\nend;\n\nprocedure TRectangle.SetWidth(Value: Double);\nbegin\n  FWidth := Value;\nend;\n\nprocedure TRectangle.SetHeight(Value: Double);\nbegin\n  FHeight := Value;\nend;\n\nfunction TRectangle.GetWidth: Double;\nbegin\n  Result := FWidth;\nend;\n\nfunction TRectangle.GetHeight: Double;\nbegin\n  Result := FHeight;\nend;\n\nfunction TRectangle.Area: Double;\nbegin\n  Result := FWidth * FHeight;\nend;\n\nprocedure TRectangle.ShowDetails;\nbegin\n  WriteLn('Rectangle Width: ', FWidth:0:2);\n  WriteLn('Rectangle Height: ', FHeight:0:2);\n  WriteLn('Rectangle Area: ', Area:0:2);\nend;\n\nvar\n  Rect: TRectangle;\n\n  // Main block\nbegin\n  // Create a rectangle with width 10 and height 5\n  Rect := TRectangle.Create(10, 5);\n\n  // Show the details of the rectangle\n  Rect.ShowDetails;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#23-classes","title":"23. Classes","text":"<p>Here is a simple example of creating a class. For mroe info, visit the official documentation; Classes. </p> <p>Syntax</p> <pre><code>type\n  TMyClass = class\n  private\n    // Private fields and methods\n  protected\n    // Protected fields and methods\n  public\n    // Public fields and methods\n    constructor Create; // Constructor\n    destructor Destroy; override; // Destructor\n  end;\n</code></pre> <p>Example</p> <pre><code>program ClassExample;\n\n{$mode objfpc}{$H+}{$J-}\n\ntype\n  // Define the class\n  TPerson = class\n  private\n    FName: string;\n    FAge: integer;\n  public\n    constructor Create(const AName: string; AAge: integer);\n    procedure DisplayInfo;\n    property Name: string read FName write FName;\n    property Age: integer read FAge write FAge;\n  end;\n\n// Implementation of the constructor\nconstructor TPerson.Create(const AName: string; AAge: integer);\nbegin\n  FName := AName;\n  FAge := AAge;\nend;\n\n// Implementation of the method to display information\nprocedure TPerson.DisplayInfo;\nbegin\n  WriteLn('Name: ', FName);\n  WriteLn('Age: ', FAge);\nend;\n\nvar\n  Person: TPerson;\n\n  // Main block\nbegin\n  // Create an instance of TPerson\n  Person := TPerson.Create('John Doe', 28);\n\n  // Access properties\n  Person.Name := 'Waldo Catto';\n  Person.Age := 18;\n\n  // Display information\n  Person.DisplayInfo;\n\n  // Free the memory used by the instance\n  Person.Free;\n\n  // Pause console\n  WriteLn('Press enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#24-generics","title":"24. Generics","text":"<p>Generics allow you to write code that can work with different data types without having to rewrite the same code for each type.</p>"},{"location":"docs/basics/intro-objpas-fpc/#generic-routines","title":"Generic Routines","text":"<p>Syntax</p> <pre><code>generic function GenericFunction&lt;T&gt;(AParam: T; ... ): T;\nbegin\n  // Function body\n  Result := value;\nend;\n</code></pre> <p>Example</p> <pre><code>program GenericFunctionExample;\n\n{$mode objfpc}{$H+}{$J-}\n\ngeneric function DoubleValue&lt;T&gt;(AValue: T): T;\nbegin\n  Result := AValue + AValue;\nend;\n\nvar\n  resultInt: integer;\n  resultReal: real;\n\n// Main block\nbegin\n  resultInt := specialize DoubleValue&lt;integer&gt;(8);\n  Writeln('resultInt:  ', resultInt);         // Output: resultInt: 64\n\n  resultReal := specialize DoubleValue&lt;real&gt;(-1.2);\n  Writeln('resultReal: ', resultReal: 0: 2); // Output: resultReal: -2.40\n\n  // Pause console\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#generic-records","title":"Generic Records","text":"<p>Syntax</p> <pre><code>type\n  TRecordName&lt;T&gt; = record\n    // Record body\n  end;\n\n  TMyType = specialize TRecordName&lt;DataType&gt;;\n</code></pre> <p>Example</p> <pre><code>program GenericRecordExample;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch advancedrecords}\n\ntype\n  // Define a generic record TPair\n  generic TPair&lt;T1, T2&gt; = record\n    First: T1;\n    Second: T2;\n    constructor Create(AFirst: T1; ASecond: T2);\n  end;\n\n  constructor TPair.Create(AFirst: T1; ASecond: T2);\n  begin\n    First := AFirst;\n    Second := ASecond;\n  end;\n\ntype\n  // Create types based on TPair\n  TIntegerStringPair = specialize TPair&lt;integer, string&gt;;\n  TRealBoolPair = specialize TPair&lt;real, boolean&gt;;\n\nvar\n  intStrPair: TIntegerStringPair;\n  realBoolPair: TRealBoolPair;\n\n// Main block\nbegin\n  intStrPair := TIntegerStringPair.Create(10, 'Ten');\n  realBoolPair := TRealBoolPair.Create(3.14, True);\n\n  Writeln('intStrPair  : (', intStrPair.First, ', ', intStrPair.Second, ')');\n  Writeln('realBoolPair: (', realBoolPair.First: 0: 2, ', ', realBoolPair.Second, ')');\n\n  // Pause console\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Alternatively, use <code>specialize</code> directly in the var section.</p> <pre><code>var\n  intStrPair:specialize TPair&lt;integer, string&gt;;\n  realBoolPair:specialize TPair&lt;real, boolean&gt;;\n</code></pre> <p>And use <code>specialize</code> again when you initialise the variables</p> <pre><code>begin\n  // ...\n  intStrPair := specialize TPair&lt;integer, string&gt;.Create(10, 'Ten');\n  realBoolPair := specialize TPair&lt;double, boolean&gt;.Create(3.14, True);\n  // ...\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#generic-classes","title":"Generic Classes","text":"<p>Syntax</p> <pre><code>type\n  TClassName&lt;T&gt; = class\n    // Class body\n  end;\n\n  TMyType = specialize TClassName&lt;DataType&gt;;\n</code></pre> <p>Example</p> <pre><code>program GenericClassExample;\n\n{$mode objfpc}{$H+}{$J-}\n\ntype\n  // Define a generic class TSimpleCalculator\n  generic TSimpleCalculator&lt;T&gt; = class\n  public\n    function Add(A, B: T): T;\n    function Subtract(A, B: T): T;\n  end;\n\n  function TSimpleCalculator.Add(A, B: T): T;\n  begin\n    Result := A + B;\n  end;\n\n  function TSimpleCalculator.Subtract(A, B: T): T;\n  begin\n    Result := A - B;\n  end;\n\ntype\n  // Define specific calculator types based on the generic class\n  TIntCalculator = specialize TSimpleCalculator&lt;integer&gt;;\n  TRealCalculator = specialize TSimpleCalculator&lt;double&gt;;\n\nvar\n  intCalc: TIntCalculator;\n  floatCalc: TRealCalculator;\n\n  // Main block\nbegin\n  // Create a calculator for integers\n  intCalc := TIntCalculator.Create;\n  Writeln('Integer Calculator:');\n  Writeln('5 + 3 = ', intCalc.Add(5, 3));\n  Writeln('5 - 3 = ', intCalc.Subtract(5, 3));\n\n  // Create a calculator for floating-point numbers\n  floatCalc := TRealCalculator.Create;\n  Writeln('Float Calculator:');\n  Writeln('5.5 + 3.2 = ', floatCalc.Add(5.5, 3.2): 0: 2);\n  Writeln('5.5 - 3.2 = ', floatCalc.Subtract(5.5, 3.2): 0: 2);\n\n  // Free the calculators\n  intCalc.Free;\n  floatCalc.Free;\n\n  // Pause console\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#25-function-references","title":"25. Function References","text":"<p>Note</p> <p>Function References is available for FPC versions &gt;= 3.3.1. </p> <p>Official doc: https://forum.lazarus.freepascal.org/index.php/topic,59468.msg443370.html#msg443370.</p> <p>Enable function references using the modeswitch FUNCTIONREFERENCES.</p> <pre><code>{$modeswitch functionreferences}\n</code></pre> <p>Syntax</p> <pre><code>type \n  funcRef = reference to function|procedure [(argumentlist)][: resulttype;] [directives;]\n</code></pre> <p>Example - A simple Function Reference</p> <pre><code>program FuncRefEx1;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch functionreferences}\n\ntype\n  // Define a type for a function reference that take two doubles and return a double\n  TMathOpFuncRef = reference to function(a, b: double): double;\n\n  // Define a function that adds two doubles\n  function Add(a, b: double): double;\n  begin\n    Result := a + b;\n  end;\n\n  // Define a function that multiplies two doubles\n  function Multiply(a, b: double): double;\n  begin\n    Result := a * b;\n  end;\n\nvar\n  // A variable of type TMathOpFuncRef to hold function references\n  mathOp: TMathOpFuncRef;\n  num1, num2: double;\n\n// Main block\nbegin\n  num1 := 5;\n  num2 := 3;\n\n  // Assign the Add function to the mathOp function reference\n  mathOp := @Add;\n  WriteLn(num1:0:2, ' + ', num2:0:2, ' = ', mathOp(num1, num2):0:2);\n\n  // Assign the Multiply function to the mathOp function reference\n  mathOp := @Multiply;\n  WriteLn(num1:0:2, ' * ', num2:0:2, ' = ', mathOp(num1, num2):0:2);\n\n  // Pause console\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Example - A Calculator</p> <pre><code>program FuncRefCalculatorExample;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch functionreferences}\n\nuses\n  SysUtils;\n\ntype\n  // Define a type represents a reference to a function\n  // that takes two doubles and returns a double\n  TMathOperation = reference to function(a, b: double): double;\n\n  // Define basic math operations\n  function Add(a, b: double): double;\n  begin\n    // Return the sum of a and b\n    Result := a + b;\n  end;\n\n  function Subtract(a, b: double): double;\n  begin\n    // Return the difference of a and b\n    Result := a - b;\n  end;\n\n  function Multiply(a, b: double): double;\n  begin\n    // Return the product of a and b\n    Result := a * b;\n  end;\n\n  function Divide(a, b: double): double;\n  begin\n    try\n      // Return the quotient of a and b\n      Result := a / b\n    except\n      on E: Exception do\n        WriteLn('Error: ' + E.Message);\n    end;\n  end;\n\n  // Procedure to perform a math operation\n  // Takes a math operation and two operands as arguments\n  procedure Calculate(mathOp: TMathOperation; a, b: double);\n  begin\n    WriteLn(mathOp(a, b): 0: 2);\n  end;\n\n// Main block\nbegin\n  Calculate(@Add, 10, 5);      // Outputs: 15.00\n  Calculate(@Subtract, 10, 5); // Outputs: 5.00\n  Calculate(@Multiply, 10, 5); // Outputs: 50.00\n  Calculate(@Divide, 10, 5);   // Outputs: 2.00\n\n  // Pause console\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Example - Digital Circuit Simulator</p> <pre><code>program FuncRefDigitalCircuitSimulator;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch functionreferences}\n\nuses\n  SysUtils;\n\ntype\n  // Define a function reference type that takes booleans and return a boolean\n  TLogicGate = reference to function(A, B: boolean): boolean;\n\n  // Define the AND logic gate function\n  function ANDGate(A, B: boolean): boolean;\n  begin\n    Result := A and B;\n  end;\n\n  // Define the OR logic gate function\n  function ORGate(A, B: boolean): boolean;\n  begin\n    Result := A or B;\n  end;\n\n  // Define the XOR logic gate function\n  function XORGate(A, B: boolean): boolean;\n  begin\n    Result := A xor B;\n  end;\n\n  // Procedure to simulate a digital circuit using a given logic gate\n  procedure SimulateCircuit(Gate: TLogicGate; A, B: boolean);\n  begin\n    // Print the result of applying the logic gate to A and B\n    WriteLn(BoolToStr(Gate(A, B), True));\n  end;\n\nbegin\n  // Simulate the circuit with the AND gate and inputs True and False\n  SimulateCircuit(@ANDGate, True, False);  // Outputs: FALSE\n\n  // Simulate the circuit with the OR gate and inputs True and False\n  SimulateCircuit(@ORGate, True, False);   // Outputs: TRUE\n\n  // Simulate the circuit with the XOR gate and inputs True and False\n  SimulateCircuit(@XORGate, True, False);  // Outputs: TRUE\n\n  // Pause the console to view the output\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#26-anonymous-functions","title":"26. Anonymous Functions","text":"<p>Note</p> <p>Anonymous Functions is available for FPC versions &gt;= 3.3.1.</p> <p>Official doc: https://forum.lazarus.freepascal.org/index.php/topic,59468.msg443370.html#msg443370.</p> <p>Enable anonymous functions using the modeswitch ANONYMOUSFUNCTIONS.</p> <pre><code>{$modeswitch anonymousfunctions}\n</code></pre> <p>Syntax</p> <pre><code>function|procedure [(argumentList)][[resultName]: resultType;] [directives;]\n[[var|type|const section]|[nested routine]]*\nbegin\n[statements]\nend\n</code></pre> <p>Example</p> <pre><code>program AnonymousFuncSimple;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch anonymousfunctions}  // Enable anonymous functions\n\nuses\n  SysUtils, Classes;\n\ntype\n  TFunc = function: integer;\n\nvar\n  proc: TProcedure;     // Declared in SysUtils\n  func: TFunc;\n  notify: TNotifyEvent; // Declared in Classes\n\nbegin\n\n  // Anonymous procedure with a single argument\n  procedure(const aArg: string)\n  begin\n    Writeln(aArg);\n  end('Hello World');\n\n  // Assigning an anonymous procedure to the 'proc' variable\n  proc := procedure\n          begin\n            Writeln('Foobar');\n          end;\n  proc;\n\n  // Assigning an anonymous procedure to the 'notify' event\n  notify := procedure(aSender: TObject)\n            begin\n              Writeln(HexStr(Pointer(aSender)));\n            end;\n  notify(Nil);\n\n  // Assigning an anonymous function to the 'func' variable\n  func := function MyRes : integer\n          begin\n            Result := 42;\n          end;\n  Writeln(func);\n\n  // Pause the console to view the output\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Example - Grade Calculator</p> <pre><code>program AnonymousFuncGradeCalculator;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch anonymousfunctions}  // Enable anonymous functions\n\nvar\n  calculateGrade: function(score: integer): string;\n\nbegin\n  // Assigning an anonymous function to the 'CalculateGrade' variable\n  calculateGrade := function(score: integer): string\n  begin\n    if score &gt;= 85 then\n      Result := 'HD'\n    else if score &gt;= 75 then\n      Result := 'D'\n    else if score &gt;= 65 then\n      Result := 'C'\n    else if score &gt;= 50 then\n      Result := 'P'\n    else\n      Result := 'F';\n  end;\n\n  // Using the anonymous function to calculate grades\n  Writeln('Grade for score 90: ', CalculateGrade(90));\n  Writeln('Grade for score 70: ', CalculateGrade(70));\n  Writeln('Grade for score 40: ', CalculateGrade(40));\n\n  // Pause the console to view the output\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Example - Student Data Processor</p> <pre><code>program StudentDataProcessor;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch anonymousfunctions}// Enable anonymous functions\n\ntype\n  TStudent = record\n    Name: string;\n    Age: integer;\n    Score: integer;\n  end;\n\ntype\n  TStudentList = array of TStudent;\n  TStudentPredicate = function(student: TStudent): boolean;\n\nvar\n  studentList: TStudentList;\n  student: TStudent;\n  filterStudents: function(arr: TStudentList; condition: TStudentPredicate): TStudentList;\n\nbegin\n  // Initialize student data\n  SetLength(studentList, 5);\n\n  // Populate student data\n  studentList[0].Name := 'Brent';\n  studentList[0].Age := 20;\n  studentList[0].Score := 85;\n  studentList[1].Name := 'Dylan';\n  studentList[1].Age := 22;\n  studentList[1].Score := 90;\n  studentList[2].Name := 'Jared';\n  studentList[2].Age := 21;\n  studentList[2].Score := 78;\n  studentList[3].Name := 'Holly';\n  studentList[3].Age := 20;\n  studentList[3].Score := 92;\n  studentList[4].Name := 'Julie';\n  studentList[4].Age := 23;\n  studentList[4].Score := 88;\n\n  // Filters a list of students based on a given condition.\n  // Returns a new list containing only the students that satisfy the condition.\n  filterStudents := function(arr: TStudentList; condition: TStudentPredicate): TStudentList\n  var\n    resultArr: array of TStudent;\n    i: integer;\n  begin\n    SetLength(resultArr, 0);\n    for i := Low(arr) to High(arr) do if condition(arr[i]) then\n      begin\n        SetLength(resultArr, Length(resultArr) + 1);\n        resultArr[High(resultArr)] := arr[i];\n      end;\n    Result := resultArr;\n  end;\n\n\n  // Using the anonymous function to filter studentList based on conditions\n  Writeln('Students with score above 85:');\n  for student in filterStudents(studentList, function(student: TStudent): boolean\n                                             begin\n                                               Result := student.Score &gt; 85;\n                                             end) do\n    Writeln(student.Name, ' - ', student.Score);\n\n  Writeln('Students aged 21 or below:');\n  for student in filterStudents(studentList, function(student: TStudent): boolean\n                                             begin\n                                               Result := student.Age &lt;= 21;\n                                             end) do\n    Writeln(student.Name, ' - ', student.Age);\n\n  // Pause the console to view the output\n  WriteLn('Press Enter to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#27-interfaces","title":"27. Interfaces","text":"<p>Note</p> <p>By default, Free Pascal uses the Windows COM <code>IUnknown</code> interface type.</p> <p>Ref: $INTERFACES : Specify Interface type.</p> <p>Think of an interface as a plan that outlines what actions a class should perform, without specifying how to do them. In Free Pascal, interfaces serve as an alternative to multiple inheritance, which is used in languages like C++.</p> <ul> <li>Interfaces can only be used in <code>delphi</code> or <code>objfpc</code> modes. </li> <li>All parts of an <code>interface</code> are always <code>public</code>, so you can't hide them.</li> <li>Properties can only have methods to get or set their values. </li> <li>You can't create interfaces directly. Instead, you need a <code>class</code> that uses the <code>interface</code>.</li> <li>It is not possible for a class to implement only part of the interface: it is all or nothing.</li> <li>You can only use calling convention modifiers in methods within an interface. You can't use special modifiers like <code>virtual</code>, <code>abstract</code>, <code>dynamic</code>, or <code>override</code> in an <code>interface</code>.</li> </ul> <p>Info</p> <p>Refer to the official doc Interfaces for more info.</p> <p>Syntax</p> <ol> <li> <p>Use the <code>interface</code> keyword to define an interface, specifying the methods (and properties, if any) that any implementing class must provide.</p> </li> <li> <p>Use the <code>class</code> keyword to define a class that implements the interface. The class must provide concrete implementations for all the methods and properties declared in the interface.</p> </li> </ol> <p>Example</p> <p>This example defines a simple interface <code>IMyInterface</code> with one method <code>DoSomething</code>, and then implement this interface in a class <code>TMyClass</code>.</p> <p>1. Define the Interface</p> <p>Note</p> <p>Especially on Windows systems, the GUID of an interface can and must be used when using COM.</p> <p>Source: Interfaces - Definition</p> <pre><code>type\n  IMyInterface = interface\n    ['{12345678-1234-1234-1234-1234567890AB}'] // Unique identifier (GUID) for the interface\n    procedure DoSomething;\n  end;\n</code></pre> <p>Step 2: Implement the Interface in a Class</p> <pre><code>type\n  TMyClass = class(TInterfacedObject, IMyInterface)\n  public\n    procedure DoSomething;\n  end;\n\nprocedure TMyClass.DoSomething;\nbegin\n  WriteLn('Doing something...');\nend;\n</code></pre> <p>Step 3: Use the Interface and Class</p> <pre><code>var\n  MyObject: IMyInterface;\nbegin\n  MyObject := TMyClass.Create;\n  MyObject.DoSomething;\nend.\n</code></pre> <p>You don\u2019t need to call <code>MyObject.Free</code> because COM interfaces automatically handle memory management. When no more references to the COM interface exist (when the reference count reaches zero), the object that implements the interface is automatically freed.</p> <p>Note</p> <p>All COM interfaces use reference counting. This means that whenever an interface is assigned to a variable, its reference count is updated. Whenever the variable goes out of scope, the reference count is automatically decreased. </p> <p>When the reference count reaches zero, usually the instance of the class that implements the interface, is freed.</p> <p>Source: Interfaces - Reference counting</p> <p>Note</p> <p>... COM interfaces are by default reference counted, because they descend from <code>IUnknown</code>.</p> <p>Source: Interfaces - CORBA and other interfaces</p> <p>Complete Example</p> <pre><code>program COMInterfaceExample;\n\n{$mode objfpc}{$H+}{$J-}\n\ntype\n  // Step 1: Define the Interface\n  IMyInterface = interface\n    ['{12345678-1234-1234-1234-1234567890AB}'] // Unique identifier (GUID) for the interface\n    procedure DoSomething;\n  end;\n\n  // Step 2: Implement the Interface in a Class\n  TMyClass = class(TInterfacedObject, IMyInterface)\n  public\n    procedure DoSomething;\n  end;\n\nprocedure TMyClass.DoSomething;\nbegin\n  WriteLn('Doing something...');\nend;\n\nvar\n  MyObject: IMyInterface;\nbegin\n  // Step 3: Use the Interface and Class\n  MyObject := TMyClass.Create;\n  MyObject.DoSomething;\n\n  // Pause console\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <ul> <li>The GUID <code>['{12345678-1234-1234-1234-1234567890AB}']</code> is required for COM compatibility but can be a unique identifier in your application.</li> <li><code>TInterfacedObject</code> is a base class that implements <code>IUnknown</code>, which is the ancestor of all interfaces. This ensures proper reference counting for memory management.</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#26-more-on-interfaces","title":"26. More on Interfaces","text":""},{"location":"docs/basics/intro-objpas-fpc/#what-is-a-guid","title":"What is a GUID?","text":"<p>A GUID is like a super-unique name tag. Imagine you're at a huge event with thousands of people, and everyone needs to wear a name tag to avoid confusion. Each name tag has to be unique so that when someone calls out a name, only one person responds. That's what a GUID does for interfaces in programming.</p>"},{"location":"docs/basics/intro-objpas-fpc/#why-do-we-need-a-guid-for-interfaces","title":"Why do we need a GUID for interfaces?","text":"<p>When we create interfaces in programming, we often have many different interfaces that might look similar. The GUID helps us keep track of each one and makes sure there's no mix-up. Here\u2019s why this is important:</p> <ol> <li> <p>Uniqueness: Just like a unique name tag, a GUID makes sure that each interface is uniquely identified. No two interfaces will have the same GUID.</p> </li> <li> <p>Identification: When your program is running, it might need to check if an object (a piece of data or a function) follows a certain set of rules (an interface). The GUID is used to ask,\"Do you follow these rules?\" and get a clear answer.</p> </li> <li> <p>Compatibility: In complex programs or systems that involve many parts working together, like different pieces of software communicating with each other, the GUID ensures that they all understand each other correctly. It's like a universal language for interfaces.</p> </li> </ol>"},{"location":"docs/basics/intro-objpas-fpc/#example-to-understand-guid","title":"Example to Understand GUID","text":"<p>Imagine you're organizing a science fair. Each project needs a unique ID so judges know exactly which project they're looking at. Without unique IDs, two projects could have the same name, leading to confusion. GUIDs work the same way for interfaces in programming.</p>"},{"location":"docs/basics/intro-objpas-fpc/#practical-example-in-programming","title":"Practical Example in Programming","text":"<p>Here's a simple example in Free Pascal:</p> <ol> <li>Define the Interface with a GUID</li> </ol> <pre><code>type\n  IMyInterface = interface\n    ['{12345678-1234-1234-1234-1234567890AB}'] // This is the GUID\n    procedure DoSomething;\n  end;\n</code></pre> <ol> <li>Implement the Interface in a Class</li> </ol> <pre><code>type\n  TMyClass = class(TInterfacedObject, IMyInterface)\n  public\n    procedure DoSomething;\n  end;\n\nprocedure TMyClass.DoSomething;\nbegin\n  WriteLn('Doing something...');\nend;\n</code></pre> <ol> <li>Use the Interface and Class</li> </ol> <pre><code>var\n  MyObject: IMyInterface;\nbegin\n  MyObject := TMyClass.Create;\n  MyObject.DoSomething;\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#breaking-down-the-example","title":"Breaking Down the Example","text":"<ul> <li>Define the Interface: <code>IMyInterface</code> is like a rulebook that says any class that follows it must have a <code>DoSomething</code> procedure.</li> <li>GUID: <code>{12345678-1234-1234-1234-1234567890AB}</code> is a unique identifier for IMyInterface. It's like saying, \"This rulebook has a unique ID so there's no confusion.\"</li> <li>Implement the Interface: <code>TMyClass</code> says, \"I follow the IMyInterface rulebook and provide a DoSomething procedure.\"</li> <li>Using the Interface: The program creates an instance of <code>TMyClass</code> and calls <code>DoSomething</code> on it, knowing exactly which rules it's following because of the GUID.</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#summary","title":"Summary","text":"<ul> <li>GUIDs are unique identifiers that ensure interfaces are uniquely recognized.</li> <li>They help prevent confusion in large and complex systems.</li> <li>They allow programs to check if objects follow specific rules (interfaces) correctly.</li> <li>Think of a GUID as a unique fingerprint for an interface, ensuring it\u2019s always identified correctly and uniquely in a program.</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#28-even-more-on-interfaces","title":"28. Even More on Interfaces","text":""},{"location":"docs/basics/intro-objpas-fpc/#what-is-a-function","title":"What is a Function?","text":"<p>Think of a function as a recipe. If you have a recipe for chocolate chip cookies, you follow those instructions every time you want cookies. You don\u2019t need to worry about the recipe being mixed up with other recipes because you have the name of the recipe right there.</p>"},{"location":"docs/basics/intro-objpas-fpc/#what-is-an-interface","title":"What is an Interface?","text":"<p>An interface is like a contract or a blueprint that tells different objects (think of them as different people or tools) how they should behave. For instance, imagine you have a blueprint for different types of devices that can play music, like a smartphone, a tablet, or a speaker. Each of these devices follows the same set of instructions (the interface) for how to play music, but they might play it differently.</p>"},{"location":"docs/basics/intro-objpas-fpc/#why-does-an-interface-need-a-guid","title":"Why Does an Interface Need a GUID?","text":"<p>Unique Identification:</p> <ul> <li>Functions: In a program, you call functions by their names. If you want to bake cookies, you just call the \"cookie recipe\" function. There's no need for a special identifier because each function name is unique within its context.</li> <li>Interfaces: Different interfaces might have similar methods, but they need a way to be uniquely identified. This is because many objects (devices) can follow the same interface (blueprint). The GUID acts like a unique serial number to make sure you\u2019re dealing with the exact right blueprint.</li> </ul> <p>Multiple Implementations:</p> <ul> <li>Functions: Each function is a specific set of instructions in your code. If you call a function, you're calling a specific set of instructions.</li> <li>Interfaces: An interface can be implemented by many different classes (objects). For example, you could have a <code>Player</code> interface for different types of media players. Each player (smartphone, tablet, speaker) will follow the same <code>Player</code> interface but might have different ways of playing the music. The GUID helps ensure that when you ask for a <code>Player</code>, you get the right kind of <code>Player</code>.</li> </ul> <p>Checking at Runtime:</p> <ul> <li>Functions: When your program runs, it directly calls functions by their names. No extra checking is needed because you know exactly what function you're calling.</li> <li>Interfaces: Sometimes, you need to check if an object follows a particular interface, especially if you\u2019re not sure what kind of object you have. The GUID helps you confirm that the object adheres to the right blueprint.</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#simple-analogy","title":"Simple Analogy","text":"<p>Imagine you're at a huge convention where every booth has a unique ID number. Each booth might have a different type of product, but the unique ID ensures that when you ask for a specific type of product, you find the right booth.</p> <ul> <li>Functions: Like knowing the exact name of a recipe.</li> <li>Interfaces: Like having a unique ID for each type of product to make sure you get the right one.</li> </ul>"},{"location":"docs/basics/intro-objpas-fpc/#example-in-programming","title":"Example in Programming","text":"<p>Let's say you have an interface called <code>IDriveable</code> that any vehicle (like cars or bikes) should implement.</p> <p>Interface Definition:</p> <pre><code>type\n  IDriveable = interface\n    ['{11111111-1111-1111-1111-111111111111}'] // Unique ID\n    procedure Drive;\n  end;\n</code></pre> <p>Class Implementing the Interface:</p> <pre><code>type\n  TCar = class(TInterfacedObject, IDriveable)\n  public\n    procedure Drive;\n  end;\n\nprocedure TCar.Drive;\nbegin\n  WriteLn('Driving a car...');\nend;\n</code></pre> <p>Using the Interface:</p> <pre><code>var\n  Vehicle: IDriveable;\n  MyCar: TCar;\nbegin\n  MyCar := TCar.Create;\n  Vehicle := MyCar;\n  Vehicle.Drive; // Calls the Drive method from TCar\nend.\n</code></pre> <p>In this example, <code>IDriveable</code> has a unique <code>GUID</code>, so even if you have many different classes (like <code>TCar</code>, <code>TBike</code>) that implement IDriveable, the GUID ensures you\u2019re interacting with the right interface.</p>"},{"location":"docs/basics/intro-objpas-fpc/#summary_1","title":"Summary","text":"<ul> <li>GUID for Interfaces: Ensures each interface is uniquely identified, especially when dealing with multiple implementations.</li> <li>Ordinary Functions: Are unique by their names within their code context, so they don\u2019t need an extra unique identifier.</li> </ul> <p>The GUID is like a special label that makes sure you\u2019re talking to the exact right set of instructions (interface) among many possibilities.</p>"},{"location":"docs/basics/intro-objpas-fpc/#29-pointers","title":"29. Pointers","text":"<p>... Avoid pointer whenever alternatives exist. If you want to learn, though, there's no silver bullet apart from: There has to be as many <code>Dispose</code> as <code>New</code>, period. </p> <p>Source: Leledumbo's reply on 'Dispose of Pointer', 2023-08-10.</p> <p>Example</p> <pre><code>program PointerExample;\n\nvar\n  ptr: ^integer;  // Declare a pointer to Integer\n  value: integer;\n\nbegin\n  New(ptr);           // Allocate memory for an Integer\n  ptr^ := 42;         // Assign value 42 to the memory location\n  value := ptr^;      // Access the value through the pointer\n\n  Writeln('Value pointed to by ptr: ', value);\n\n  Dispose(ptr);       // Free the allocated memory\nend.\n</code></pre>"},{"location":"docs/basics/intro-objpas-fpc/#safe-usage-tips","title":"Safe Usage Tips","text":"<ol> <li> <p>Always Initialize Pointers: Before using a pointer, make sure it points to valid memory. Uninitialized pointers can cause undefined behavior.</p> </li> <li> <p>Check for nil: It\u2019s good practice to check if a pointer is nil (i.e., not pointing to any memory) before using it:</p> </li> </ol> <pre><code>if ptr &lt;&gt; nil then\n  Writeln(ptr^);\n</code></pre> <ol> <li> <p>Avoid Memory Leaks: Always pair <code>New</code> with <code>Dispose</code> to prevent memory leaks. If you forget to free the allocated memory, it will not be available for other parts of your program or system.</p> </li> <li> <p>Don\u2019t Use Freed Pointers: After calling <code>Dispose</code>, the pointer still holds the address of the freed memory. Set it to <code>nil</code> to avoid accidental use:</p> </li> </ol> <pre><code>Dispose(ptr);\nptr := nil;\n</code></pre> <ol> <li>Be Cautious with Pointer Arithmetic: Although not commonly needed in high-level Pascal programming, pointer arithmetic (e.g., incrementing pointers) should be done carefully to avoid accessing invalid memory areas.</li> </ol> <p>More info? See Pointers and Memory Management.</p>"},{"location":"docs/basics/overview/","title":"Overview","text":"<p>This section contains the basics of Free Pascal; fundamental tasks to perform other core tasks in programming.</p>"},{"location":"docs/core-tasks/arrays/","title":"Arrays in Free Pascal","text":""},{"location":"docs/core-tasks/arrays/#official-docs","title":"Official docs","text":"<ul> <li>https://www.freepascal.org/docs-html/ref/refsu14.html</li> <li>https://wiki.freepascal.org/Array</li> </ul>"},{"location":"docs/core-tasks/arrays/#static-array-vs-dynamic-array","title":"Static array vs dynamic array","text":"Aspect Static Array Dynamic Array Size Flexibility Size is fixed and specified at compile time. Can grow or shrink dynamically at runtime using procedures like <code>SetLength</code>. Memory Management Memory allocation is static and determined during declaration. Managed by the compiler and runtime system, automatically allocates and deallocates memory as needed. Access Time Faster access time as elements are accessed directly using indices. Slightly slower access time compared to static arrays due to dynamic memory management. Usage Suitable when the size of the collection is known and fixed, providing efficient and direct access to elements. Ideal for situations where the size of the collection is not known beforehand or may change during program execution. Declaration E.g. <code>type staticArray: array[0..10] of integer;</code> E.g. <code>type dynamicArray: array of integer;</code> Initialisation Elements are initialised during declaration or by assigning values to each element directly. Elements can be added dynamically using <code>SetLength</code> and  by assigning values directly. Memory Efficiency Memory usage is optimised as it only allocates space for the specified number of elements. May use more memory than necessary due to potential overallocation or resizing operations. Usage Complexity Straightforward to use with fixed size and direct access, reducing complexity. Offers more flexibility but requires handling memory management and resizing operations manually. Performance Impact Static arrays generally offer better performance due to their predictable size and direct memory access. Depending on the implementation and usage patterns, dynamic arrays can incur a slight performance overhead due to dynamic memory management."},{"location":"docs/core-tasks/arrays/#what-is-an-array","title":"What is an array?","text":"<p>An array is a linear data structure concept that groups elements of the same type, stores them in contiguous and adjacent memory locations and provides random access to all of said elements by way of a linear index.</p> <p>Each element can be uniquely identified by one or more scalar values, called indices, along those dimensions.</p> <p>Quoted from Array | Free Pascal Wiki.</p>"},{"location":"docs/core-tasks/arrays/#what-is-a-static-array","title":"What is a static array?","text":"<p>A static array is an array with its range included in the array declaration. In other words, a static array has a size known or decided in advance or at compile time.</p> <p>Since the size is decided on compile, you cannot change the size of the array. Hence, static array.</p>"},{"location":"docs/core-tasks/arrays/#examples-of-static-arrays","title":"Examples of static arrays","text":"<pre><code>program StaticArrayDemo01;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes;\n\ntype\n  // Declaring a static array in the type-section.\n  TByteArray = array [1..5] of byte; // size is 5\n\nvar\n  // Creating an array var based on a type.\n  // You can assign initial values here too.\n  studentGrades: TByteArray;\n\n  // Declaring an array type in the var section.\n  multipleTen: array [0..9] of integer; // size is 10\n\n  // Declaring static array and init values in the var-section.\n  osChoices: array [1..3] of string = ('Linux', 'MacOS', 'Windows');\n\n  index: integer; // a var for loops\n\nbegin\n  // Assign a value to an array's element by using a valid index value\n  // enclosed in square brackets.\n  // Populate student grades\n  studentGrades[1] := 95;\n  studentGrades[2] := 85;\n  studentGrades[3] := 75;\n  studentGrades[4] := 55;\n  studentGrades[5] := 85;\n\n  // Populate multiple ten\n  for index := low(multipleTen) to high(multipleTen) do\n    multipleTen[index] := index * 10;\n\n  // Print the length of the arrays\n  WriteLn('The length of grades array     : ', Length(studentGrades));\n  WriteLn('The length of osChoices array  : ', Length(osChoices));\n  WriteLn('The length of multipleTen array: ', Length(multipleTen));\n\n  WriteLn('-------------------');\n\n  // Print an element from each array\n  WriteLn('Grade of student 3 in the array : ', studentGrades[3]);\n  WriteLn('First choice of OS the array    : ', osChoices[1]);\n  WriteLn('The Last multiple of 10 in array: ', high(multipleTen));\n\n  WriteLn('-------------------');\n\n  // Print all elements from each array\n  WriteLn('-- Student grades array');\n  for index := low(studentGrades) to high(studentGrades) do\n    WriteLn('Student ', index, ' scored ', studentGrades[index]);\n\n  WriteLn('-- Multiple of ten array');\n  for index := low(multipleTen) to high(multipleTen) do\n    WriteLn('Index  ', index, ' contains ', multipleTen[index]);\n\n  WriteLn('-- OS choices array');\n  for index := low(osChoices) to high(osChoices) do\n    WriteLn('OS choice no ', index, ' is ', osChoices[index]);\n\n  // Pause console\n  WriteLn('-------------------');\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>The output will be as follows.</p> <pre><code>The length of grades array     : 5\nThe length of osChoices array  : 3\nThe length of multipleTen array: 10\n-------------------\nGrade of student 3 in the array : 75\nFirst choice of OS the array    : Linux\nThe Last multiple of 10 in array: 9\n-------------------\n-- Student grades array\nStudent 1 scored 95\nStudent 2 scored 85\nStudent 3 scored 75\nStudent 4 scored 55\nStudent 5 scored 85\n-- Multiple of ten array\nIndex  0 contains 0\nIndex  1 contains 10\nIndex  2 contains 20\nIndex  3 contains 30\nIndex  4 contains 40\nIndex  5 contains 50\nIndex  6 contains 60\nIndex  7 contains 70\nIndex  8 contains 80\nIndex  9 contains 90\n-- OS choices array\nOS choice no 1 is Linux\nOS choice no 2 is MacOS\nOS choice no 3 is Windows\n-------------------\nPress enter to quit\n</code></pre> <p>Important</p> <p>The functions High and Low return the high and low bounds of the leftmost index type of the array. </p> <p>You should use them whenever possible, since it improves maintainability of your code. The use of both functions is just as efficient as using constants, because they are evaluated at compile time.</p> <p>Source: https://www.freepascal.org/docs-html/ref/refsu14.html</p>"},{"location":"docs/core-tasks/arrays/#what-is-a-dynamic-array","title":"What is a dynamic array?","text":"<p>In Free Pascal, a dynamic array is a data structure that allows for flexible sizing of arrays at runtime. It is defined as an array whose size can be adjusted dynamically during program execution. Dynamic arrays are allocated on the heap, allowing them to grow or shrink as needed, unlike static arrays whose size is fixed at compile time.</p> <p>Important</p> <p>Dynamic arrays' indices are always non-negative integers starting at zero for the first element. It is not possible to use an enumerative type or any other ordinal type as an index. The first element is always specified by an index of 0 \u2013 this cannot be changed.</p> <p>Source: https://wiki.freepascal.org/Dynamic_array</p> <p>Before using a dynamic array, you must set the length at runtime using <code>SetLength</code> procedure.</p>"},{"location":"docs/core-tasks/arrays/#example-of-dynamic-arrays","title":"Example of dynamic arrays","text":"<pre><code>program DynArrayDemo01;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\ntype\n  // Declaring a static array in the type-section.\n  TRealArray = array of real;\n\nvar\n  // Creating an array var based on a type.\n  // You can assign initial values here too.\n  dailyTemp: TRealArray;\n\n  // Declaring an array type in the var section.\n  multipleTwo: array of integer;\n\n  // Declaring an array type in the var section.\n  defenceForces: array of string = ('Navy', 'Army', 'Air Force');\n\n  tempInt, index: integer;      // variables for loops.\n  tempReal: real;               // variable for loops.\n  tempStr: string;              // a string placeholder for loops.\n\nbegin\n\n  // Setting length of dynamic arrays\n  SetLength(dailyTemp, 7);   // This array's size is 7, index 0..6\n  SetLength(multipleTwo, 5);  // This array's size is 5, index 0..4\n\n  // Populate the daily temp array\n  dailyTemp[0] := 30.1;\n  dailyTemp[1] := 25.5;\n  dailyTemp[2] := 28.7;\n  dailyTemp[3] := 29.1;\n  dailyTemp[4] := 28.8;\n  dailyTemp[5] := 28.5;\n  dailyTemp[6] := 27.2;\n\n  // Populate the int array with multiples of two\n  for index := low(multipleTwo) to high(multipleTwo) do\n    multipleTwo[index] := index * 2;\n\n  // Print the length of the arrays\n  WriteLn('The length of dailyTemp array    : ', Length(dailyTemp));\n  WriteLn('The length of multipleTwo array  : ', Length(multipleTwo));\n  WriteLn('The length of defenceForces array: ', Length(defenceForces));\n\n  WriteLn('-------------------');\n\n  // Print an element from each array\n  WriteLn('Last temp recorded in the array          : ', high(dailyTemp));\n  WriteLn('Second number in multipleTwo array       : ', multipleTwo[1];\n  WriteLn('The third item in the defenceForces array: ', defenceForces[2]);\n\n  WriteLn('-------------------');\n\n  WriteLn('-- Printing the real array');\n\n  // Print the real array\n  for index := 0 to high(dailyTemp) do\n  begin\n    // Option 1\n    // WriteLn('Temp day ', (index + 1), ' is ', dailyTemp[index]:0:2);\n    // Option 2\n    WriteLn(Format('The temp for day %d is %2f.', [index, dailyTemp[index]]));\n  end;\n\n  WriteLn('-- Printing the integer array');\n\n  // Print the integer array\n  for tempInt in multipleTwo do\n    WriteLn(tempInt);\n\n  WriteLn('-- Printing the string array');\n\n  // Print the string array\n  for tempStr in defenceForces do\n    WriteLn(tempStr);\n\n  // Pause console\n  WriteLn('-------------------');\n  WriteLn('Press enter to quit');\n  ReadLn;\nend.\n</code></pre> <p>Output</p> <pre><code>The length of dailyTemp array    : 7\nThe length of multipleTwo array  : 5\nThe length of defenceForces array: 3\n-------------------\nLast temp recorded in the array          : 6\nSecond number in multipleTwo array       : 2\nThe third item in the defenceForces array: Air Force\n-------------------\n-- Printing the real array\nThe temp for day 0 is 30.10.\nThe temp for day 1 is 25.50.\nThe temp for day 2 is 28.70.\nThe temp for day 3 is 29.10.\nThe temp for day 4 is 28.80.\nThe temp for day 5 is 28.50.\nThe temp for day 6 is 27.20.\n-- Printing the integer array\n0\n2\n4\n6\n8\n-- Printing the string array\nNavy\nArmy\nAir Force\n-------------------\nPress enter to quit\n</code></pre>"},{"location":"docs/core-tasks/arrays/#should-i-declare-arrays-in-the-type-or-in-the-var-section","title":"Should I declare arrays in the <code>type</code> or in the <code>var</code> section?","text":"<p>While it is possible to declare arrays in the <code>var</code> section for simplicity or quick one-time use, leveraging the <code>type</code> section for array declarations offers benefits in terms of Readability code structure, maintainability, and readability in larger and more complex Pascal programs.</p>"},{"location":"docs/core-tasks/arrays/#pros-of-declaring-in-var-section","title":"Pros of declaring in <code>var</code> section","text":"<ul> <li> <p>Simplicity and Convenience: Declaring dynamic arrays directly in the var section can be more convenient for quick one-time use or when you need a simple array without the need for a custom type.</p> </li> <li> <p>Less Overhead: For smaller programs or cases where the array is used only within a limited scope, declaring dynamic arrays in the var section can reduce the overhead of creating custom types.</p> </li> </ul>"},{"location":"docs/core-tasks/arrays/#pros-of-declaring-in-the-type-section","title":"Pros of declaring in the <code>type</code> section","text":"<ul> <li> <p>Code Readability: Placing dynamic array declarations in the type section enhances code readability by clearly defining custom array types for reuse throughout the program.</p> </li> <li> <p>Reusability: Defining dynamic array types in the type section promotes code reusability and consistency, allowing you to use the same array type in multiple parts of your program.</p> </li> <li> <p>Type Safety: By declaring dynamic array types in the type section, you enforce type safety and ensure that variables declared using these types are checked for compatibility at compile time.</p> </li> <li> <p>Encapsulation: Encapsulating dynamic array definitions within named types offers a level of abstraction, hiding implementation details and preventing unintended modifications to the array structure.</p> </li> </ul>"},{"location":"docs/core-tasks/arrays/#recommendations","title":"Recommendations","text":"<ul> <li> <p>For larger programs: In larger programs or when working with complex data structures, it is beneficial to declare dynamic arrays in the <code>type</code> section to promote code organization, maintainability, and consistency.</p> </li> <li> <p>For quick prototyping or small programs: In smaller programs or for quick prototyping where simplicity is priority, declaring dynamic arrays in the <code>var</code> section may be more practical.</p> </li> </ul>"},{"location":"docs/core-tasks/arrays/#which-one-should-i-use-static-or-dynamic-array","title":"Which one should I use? Static or dynamic array?","text":""},{"location":"docs/core-tasks/arrays/#if-you-know-the-size-at-compile-time-static-array","title":"If you know the size at compile time - static array","text":"<p>Here is an example of creating a static array and sorting the elements as well.</p> <p>The creation of the list is at line 13.</p> <pre><code>program StaticArrayExample;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Generics.Collections;\n\ntype\n  strListHelper = specialize TArrayHelper&lt;string&gt;;\n\nvar\n  // Declaring a list of 6 elements\n  strList: array[0..5] of string = ('Zero', 'Twenty', 'Thirty', 'Forty', 'Sixty', 'Fifty');\n  minVal, maxVal: string;\n  i: integer;\n\nbegin\n  // Printing out length\n  WriteLn('The length is ', Length(strList));\n\n  // Printing out list\n  WriteLn('-- Original list ---');\n  for i := 0 to High(strList) do WriteLn(strList[i]);\n\n  // Modifying the first element\n  // strList[0] will become 'Zero One'\n  strList[0] := strList[0] + ' One';\n\n  // Sorting ascending by default using TArrayHelper&lt;T&gt;\n  WriteLn('-- Sorting list ---');\n  strListHelper.Sort(strList);\n\n  // Printing out the modified list\n  WriteLn('-- Sorted list ---');\n  for i := 0 to High(strList) do WriteLn(strList[i]);\n\n  // Pausing console, user can continue by pressing enter key\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/arrays/#if-you-know-the-size-only-at-runtime-dynamic-array","title":"If you know the size only at runtime - dynamic array","text":"<p>Here is an example using a dynamic array and sorting the elements in it.</p> <pre><code>program DynamicArrayExample;\n\n{$mode objfpc}{$H+}{$J-}\n{$modeswitch arrayoperators}\n\nuses\n  Generics.Collections;\n\ntype\n  strListHelper= specialize TArrayHelper&lt;string&gt;;\n\nvar\n  strList: array of string;\n  i: integer;\n\nbegin\n\n  // Set the length of the list\n  SetLength(strList, 3);\n\n  // Populating the content, of length 3\n  strList := ['Zero', 'Twenty', 'Thirty'];\n\n  // Append a literal array to the list\n  // Now the length is 6!\n  strList := strList + ['Forty', 'Sixty', 'Fifty'];\n\n  // Printing out length\n  WriteLn('The length is ', Length(strList));\n\n  // Printing out list\n  WriteLn('-- Original list ---');\n  for i := Low(strList) to High(strList) do WriteLn(strList[i]);\n\n  // Modifying the first element\n  // strList[0] will become 'Zero One'\n  strList[0] := strList[0] + ' One';\n\n  // Sorting the array using TArrayHelper&lt;T&gt;\n  WriteLn('-- Sorting list ---');\n  strListHelper.Sort(strList);\n\n  // Printing out the modified list\n  WriteLn('-- Sorted list ---');\n  for i := Low(strList) to High(strList) do WriteLn(strList[i]);\n\n  // Pausing console\n  // user can continue by pressing enter key\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/cmd-line-params/","title":"Command Line Parameters","text":""},{"location":"docs/core-tasks/cmd-line-params/#how-do-i-capture-command-line-arguments","title":"How do I capture command line arguments?","text":"<p>Use <code>ParamStr(n)</code> to get the n-th arguments.</p> <p>Note, <code>ParamStr(0)</code> gives you the name of the program or location where the program is invoked.</p> <p>While <code>ParamCount</code> give you the number of arguments.</p> <p>Here is an example.</p> <pre><code>program CLSimple;\n\nvar\n  i: integer;\n\nbegin\n  WriteLn('Number of command line arguments: ', ParamCount);\n\n    // Display all command line arguments\n  for i := 0 to ParamCount do\n    WriteLn('Argument ', i, ': ', ParamStr(i));\nend.\n</code></pre> <p>When you compile and run the snippet above on a CLI followed by <code>a b c</code>, you will see the list of arguments given.</p> <pre><code>$ ./CLSimple.exe a b c\nNumber of command line arguments: 3\nArgument 0: path-to-your-program/CLSimple.exe\nArgument 1: a\nArgument 2: b\nArgument 3: c\n</code></pre>"},{"location":"docs/core-tasks/cmd-line-params/#how-can-i-capture-short-options","title":"How can I capture short options?","text":"<p>Use <code>getopt</code>. See an example below.</p> <ol> <li>In <code>uses</code> section add <code>getopt</code>. Line 17.</li> <li>Create a short option string, in our example, <code>a:bcd</code>. Line 24.</li> <li>Call <code>getopt(shortOpts)</code> in a loop<ul> <li>capture and action each option</li> <li>deal with <code>?</code> and <code>:</code> (for invalid option and missing argument)</li> <li>until it returns <code>EndOfOptions</code>. Line 36-55.</li> </ul> </li> </ol> <pre><code>program GetOptSimple;\n\n// Example usage (git bash):\n\n// $ ./GetOptSimple -a \"Hello\" -b -c -d\n// $ ./GetOptSimple -a \"Hello\" -bc -d\n// $ ./GetOptSimple -a \"Hello\" -bcd\n// $ ./GetOptSimple -dcb -a \"Hello\"\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  getopts;\n\nvar\n  c: char = DEFAULT(char);\n  shortOpts: string;\n\nbegin\n\n  // If the external variable opterr is True (which is the default),\n  // getopt prints an error message.\n  // Ref: https://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html\n  //      https://www.freepascal.org/daily/doc/rtl/getopts/getopt.html\n  OptErr := False;\n\n  // Defining valid short options\n  // For example; -a requires an argument,\n  //              -b, -c and -d don't.\n  shortOpts := 'a:bcd';\n\n  repeat\n    c := getopt(shortOpts);\n    case c of\n      'a': WriteLn('Option a was set with value ', optarg);\n      'b': WriteLn('Option b was set');\n      'c': WriteLn('Option c was set');\n      'd': WriteLn('Option d was set');\n      '?', ':': begin\n        // If getopt finds an option character in argv that was not included\n        // in options, or a missing option argument,\n        //    - it returns `?` and\n        //    - sets the external variable `optopt` to the actual option character.\n        // If the first character of options is a colon (\u2018:\u2019),\n        //    - then getopt returns \u2018:\u2019 instead of \u2018?\u2019 to indicate a missing option argument.\n        // Refs\n        // - https://www.freepascal.org/docs-html/rtl/getopts/index.html\n        // - https://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html\n        if (optopt = 'a') then\n          WriteLn('Error: Option ', optopt, ' needs an argument.')\n        else\n          WriteLn('Error: Unknown option: ', optopt);\n      end;\n    end; // case\n  until c = EndOfOptions;\n\n  // The reminder, checks for non-option arguments (if any) using optind\n  if optind &lt;= paramcount then\n  begin\n    Write('Non options : ');\n    while optind &lt;= paramcount do\n    begin\n      Write(ParamStr(optind), ' ');\n      Inc(optind);\n    end;\n    WriteLn;\n  end;\n\nend.\n</code></pre>"},{"location":"docs/core-tasks/code-structure/","title":"Structuring Your Codes","text":""},{"location":"docs/core-tasks/code-structure/#structure-of-a-pascal-program","title":"Structure of a Pascal Program","text":"<p>Here is a common structure of a Pascal program.</p> <pre><code>program ProgramStructure;\n\n// Global compiler directives here\n// Ref: https://www.freepascal.org/docs-html/prog/progse3.html\n\nuses\n  // Add units here\n\nconst\n  // Add consts here\n  // Refs: https://www.freepascal.org/docs-html/ref/refse9.html#x21-200002.1\n  //       https://www.freepascal.org/docs-html/ref/refse10.html#x22-210002.2\n\nresourcestring\n  // Declare resourcestrings\n  // Ref: https://www.freepascal.org/docs-html/ref/refse11.html\n\ntype\n  // Declare types\n\nvar\n  // Declare variables, initialise when possible\n\nthreadvar\n  // Declare threadvars\n  // Variables in this section have unique values for each thread\n  // Ref: https://www.freepascal.org/docs-html/ref/refse26.html\n\n  // Define procedures and functions before the MAIN entry/block of the program\n\nbegin\n   // This is the MAIN entry/block\nend.         \n</code></pre>"},{"location":"docs/core-tasks/code-structure/#an-example-of-a-pascal-program","title":"An example of a Pascal Program","text":"<p>Here is a program example that stores student information in a record, and print it on the console.</p> <pre><code>program SimpleProgram;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nconst\n  student_id_prefix: string = 'ua-';\n\ntype\n  TStudent = record\n    studentId: string;\n    firstname: string;\n    lastname: string;\n  end;\n\n  // Prints the contents of a TStudent var\n  procedure PrintStudentInfo(student: TStudent);\n  begin\n    WriteLn(student.studentId);\n    WriteLn(student.firstname, ' ', student.lastname);\n  end;\n\nvar\n  myStudent: TStudent;\n\nbegin\n  // The Main block/entry of the program\n\n  WriteLn('Now : ', DateToStr(Now));\n\n  myStudent.firstname := 'John';\n  myStudent.lastname := 'Costco';\n  myStudent.studentId := student_id_prefix + '2227209';\n  PrintStudentInfo(myStudent);\n\n  // Pause console\n  WriteLn('Press Enter key to quit ...');\n  ReadLn();\nend.\n</code></pre> <p>The output as follows.</p> <pre><code>Now : 16/12/2023\nua-2227209\nJohn Costco\nPress Enter key to quit ...\n</code></pre>"},{"location":"docs/core-tasks/code-structure/#structure-a-unit","title":"Structure a Unit","text":"<pre><code>program UnitStructure;\n\ninterface\n\n  // This is the Public section.\n  // Variables, functions and procedures declared in this section\n  // will be accessible from the unit's caller.\n\nimplementation\n\n  // This is the Private section.\n  // Anything declared in this section will only be available to the unit.\n\ninitialization\n\n  // Optional. Code that runs when the unit gets loaded.\n  // Ref: https://www.freepascal.org/docs-html/ref/refse112.html#x233-25700016.2\n\nfinalization\n\n  // Optional. Code that runs when the program ends normally.\n  // The finalization part of the units are executed in the\n  // reverse order of the initialization execution.\n  // Ref: https://www.freepascal.org/docs-html/ref/refse112.html#x233-25700016.2\n\nend.\n</code></pre>"},{"location":"docs/core-tasks/code-structure/#an-example-of-a-unit","title":"An Example of a Unit","text":"<p>Here is an example of a simple unit for calculating the areas of a square and a circle.</p> <ol> <li>the unit has a private variable called <code>short_pi</code>, which is not available outside the unit itself.</li> <li>the unit has two public functions.</li> </ol> <pre><code>unit Areas;\n\ninterface\n\nfunction CalcAreaSquare(side: real): real;\nfunction CalcAreaCircle(radius: real): real;\n\nimplementation\n\nconst\n  shortPI: real = 3.14;\n\nfunction CalcAreaSquare(side: real): real;\nbegin\n  Result := side * side;\nend;\n\nfunction CalcAreaCircle(radius: real): real;\nbegin\n  Result := shortPI * radius * radius;\nend;\n\nend.\n</code></pre> <p>We can use this <code>Areas</code> unit as follows.</p> <pre><code>program SimpleProgramWithUnit;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  Areas;\n\nbegin\n  // Calculate area of a square\n  WriteLn('Area of 2.5cm square is ',\n          CalcAreaSquare(2.5): 0: 2,\n          ' cm\u00b2.');\n\n  // Calculate area of a circle\n  WriteLn('Area of a circle with r=2.5cm is ',\n          CalcAreaCircle(2.5):0: 2,\n          ' cm\u00b2.');\n\n  // The following WriteLn will not compile\n  // Because shortPI is declared in the private section of the Area unit\n  // WriteLn('shortPI is ', Areas.shortPI);\n\n  // Pause console\n  WriteLn('Press Enter key to exit ...');\n  ReadLn;\nend.\n</code></pre> <p>Contribution</p> <p>2024-02-08 - Gustavo 'Gus' Carreno \ud83c\uddf5\ud83c\uddf9 pointed out on the original code; it is not necessary to include the unit's name when calling a routine.</p> <p>Previously we had <code>CalcAreaCircle(2.5)</code> as <code>Areas.CalcAreaCircle(2.5)</code>.</p> <p>Anything in the <code>interface</code> section of a Unit will become global for the scope of the program/unit/dll that includes it. Hence, the code above is only <code>CalcAreaCircle(2.5)</code>.</p> <p>We only need to include the name of the unit if a naming conflict occurs.</p>"},{"location":"docs/core-tasks/dates/","title":"Dates and Times","text":"<p>Format characters</p> <p>The complete list of formatting characters can be found in <code>formatchars</code> doc.</p>"},{"location":"docs/core-tasks/dates/#how-can-i-get-current-date-and-time","title":"How can I get current date and time?","text":"<ol> <li>Add <code>sysutils</code> to the <code>uses</code> section.</li> <li>Use <code>Now</code> to get current date time.</li> </ol> <p>From here you have choices.</p> <ul> <li>You can use <code>DateToStr</code> to get only the date string from <code>Now</code>.</li> <li>You can use <code>TimeToStr</code> to get only the time string from <code>Now</code>.</li> <li>You can use <code>DateTimeToStr</code> to get the date time string from <code>Now</code>.</li> <li>You can use <code>FormatDateTime</code> to customise the date time string from <code>Now</code>.</li> </ul> <p>Here is an example.</p> <pre><code>program DateTimeCurrent;\n\nuses\n  SysUtils;\n\nbegin\n\n  // Display current date only with the default formatting\n  WriteLn('Date: ', DateToStr(Now));\n\n  // Display current time only with the default formatting\n  Writeln('Time: ', TimeToStr(Now));\n\n  // Display current timestamp with the default formatting\n  Writeln('Now is (default format): ', DateTimeToStr(Now));\n\n  // Display timestamp with custom formatting\n  Writeln('Now is (custom format) : ',\n          FormatDateTime('yyyy-mm-dd hh:nn:ss.z', Now));\n  Writeln('Now is (custom format) : ',\n          FormatDateTime('dd-mmm-yy hh:nn AM/PM', Now));\n\n  // Display timestamp in long format -- Tuesday, 9 January 2024 12:08:17 PM\n  Writeln('Now is (custom format) : ', FormatDateTime('dddddd tt', Now));\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dates/#how-to-get-unix-epoch-time","title":"How to get Unix epoch time?","text":"<ol> <li>In <code>uses</code> section add <code>SysUtils</code> and <code>DateUtils</code>.  </li> <li>Call <code>DateTimeToUnix(Now);</code>.</li> </ol> <pre><code>program DateTimeUnix;\n\nuses\n  SysUtils,\n  DateUtils;\n\nvar\n  unixTime: integer;\n\nbegin\n  unixTime := DateTimeToUnix(Now);\n  Writeln('Current time in Unix epoch time is: ', unixTime);\n\n  // Pause console;\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dates/#finding-days-or-time-between-dates","title":"Finding days or time between dates","text":"<p>You can use any of the following to find days or time between dates.</p> <ul> <li><code>YearsBetween</code> - The number of whole years between two <code>TDateTime</code> values</li> <li><code>MonthsBetween</code> - The number of whole months between two <code>TDateTime</code> values</li> <li><code>WeeksBetween</code> - The number of whole weeks between two <code>TDateTime</code> values</li> <li><code>DaysBetween</code> - Number of whole days between two <code>TDateTime</code> values.</li> <li><code>HoursBetween</code> - The number of whole hours between two <code>TDateTime</code> values.</li> <li><code>MinutesBetween</code> - The number of whole minutes between two <code>TDateTime</code> values.</li> <li><code>SecondsBetween</code> - The number of whole seconds between two <code>TDateTime</code> values.</li> <li><code>MilliSecondsBetween</code> - The number of whole milliseconds between two <code>TDateTime</code> values.</li> </ul> <p>Here is an example of using <code>SecondsBetween</code> and <code>DaysBetween</code>.</p> <pre><code>program DateTimeBetween;\n\nuses\n  SysUtils,\n  DateUtils;\n\nvar\n  diffSec, diffDay: integer;\n\nbegin\n\n  // Seconds between 2 times\n  diffSec := SecondsBetween(StrToTime('18:30'), StrToTime('07:35'));\n  WriteLn('The seconds between 18:30 and 07:35 is: ', diffSec, ' seconds');\n\n  // Days between 2 dates\n  diffDay := DaysBetween(StrToDate('09/01/2024'), StrToDate('01/01/2015'));\n  WriteLn('The days difference between 2024-01-05 and 2015-01-01 is: ', diffDay, ' days');\n\n  // Seconds between 2 dates\n  // Casting diffsec to float for nicer formatting\n  diffSec := SecondsBetween(StrToDate('09/01/2024'), StrToDate('01/01/2015'));\n  WriteLn('The seconds between 2024-01-05 and 2015-01-01 is: ', Format('%n', [diffSec + 0.0]),' seconds');\n\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dates/#simple-profiling-a-section-of-a-program","title":"Simple profiling a section of a program","text":"<ol> <li>Place the <code>GetTickCount64</code> before and after a specific section of code.</li> <li>Calculate the elapsed time in milliseconds by subtracting the initial value from the final value obtained from <code>GetTickCount64</code>.</li> </ol> <p>Warning</p> <p><code>GetTickCount64</code> returns an increasing clock tick count in milliseconds. It is useful for time measurements, but no assumptions should be made as to the interval between the ticks.</p> <p>https://www.freepascal.org/daily/doc/rtl/sysutils/gettickcount64.html</p> <p>Here is an example.</p> <pre><code>program DateTimeBenchmark;\n\nuses\n  SysUtils;\n\nvar\n  startTime, endTime: QWord;\n\nbegin\n\n  // Get start time.\n  startTime := GetTickCount64;\n\n  // Simulate a long running task\n  Sleep(1000);\n\n  // Get end time\n  endTime := GetTickCount64;\n\n  // Display time elapsed\n  Writeln('Time elapsed: ', (endTime-startTime), ' ms');\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dates/#how-can-i-compare-two-dates","title":"How can I compare two dates?","text":"<p>Use the comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>) to compare two <code>TDateTime</code> values.</p> <p>Consider the following example.</p> <pre><code>program DateTimeComparison;\n\nuses\n  SysUtils,\n  DateUtils;\n\nvar\n  surveyReleaseDate: TDateTime;\n\nbegin\n\n  // Set survey release date\n  surveyReleaseDate := StrToDate('15/12/2024');\n\n  if surveyReleaseDate &lt; Now then\n  begin\n    WriteLn('You can release survey results now');\n    WriteLn('You''re behind by ', DaysBetween(Now, surveyReleaseDate), ' days.');\n  end\n  else\n  begin\n    WriteLn('You CANNOT release survey results! Wait!');\n    WriteLn('You can release results in ', DaysBetween(Now, surveyReleaseDate), ' days.');\n  end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dates/#how-do-i-parse-a-string-date-in-dd-mmm-yy-format","title":"How do I parse a string date in dd-mmm-yy format?","text":"<p>Use <code>ScanDateTime</code> from <code>DateUtils</code>.</p> <p>Take a look at this example.</p> <pre><code>program ParseDate;\n\nuses\n  SysUtils,\n  DateUtils;\n\nvar\n  dateString: string;\n  parsedDate: TDateTime;\n\nbegin\n\n  // date to parse\n  dateString := '03-MAR-24';\n\n  // default value of parsed date. If conversion fails, use this value\n  parsedDate := Default(TDateTime);\n\n  try\n    parsedDate := ScanDateTime('dd?mmm?yy', dateString);\n    // Now dateValue contains the parsed date, else ScanDateTime will raise an exception\n\n    // Use FormatDateTime to format the parsed date as needed\n    WriteLn('Parsed date                : ', DateToStr(parsedDate));\n    WriteLn('Parsed date (custom format): ', FormatDateTime('dddddd tt', parsedDate));\n    WriteLn('Parsed date (custom format): ', FormatDateTime('yyyy-mm-dd hh:nn:ss', parsedDate));\n  except\n    on E: EConvertError do\n      WriteLn('Invalid date string');\n  end;\n\n  // Pause console\n  Readln;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/","title":"Directories, Path and Filename","text":""},{"location":"docs/core-tasks/dir-path-filename/#get-home-directory-of-current-user","title":"Get home directory of current user","text":"<p>Use <code>GetUserDir</code> from <code>SysUtils</code> unit.</p> <ol> <li>Add <code>SysUtils</code> in the uses section.</li> <li>Call <code>GetUserDir</code>.</li> </ol> <pre><code>program GetHomeDir;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  homeDir: string;\n\nbegin\n\n  // Get home dir\n  homeDir := GetUserDir;\n\n  WriteLn('THe home directory is ', homeDir);\n\n  // Pause console\n  WriteLn('Press enter to quit ...');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#create-a-directory-or-chain-of-directories","title":"Create a directory or chain of directories","text":"<p>Here is a snippet of creating a sub directory called <code>demo/ex-01</code> in the program's current directory.</p> <pre><code>program DirPathFileCreateDir;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes, SysUtils;\n\nvar\n  directoryName: string;\nbegin\n  directoryName := ConcatPaths(['demo','ex-01']);\n  if ForceDirectories(directoryName) then\n    WriteLn('Directory created successfully')\n  else\n    WriteLn('Failed to create directory');\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#create-a-directory-or-chain-of-directories-with-utf8","title":"Create a directory or chain of directories with UTF8","text":"<p>You can use <code>ForceDirectories</code> to create directories with UTF8.</p> <p>Here is a snippet of creating a sub directory called <code>demo/\u80dc\u5229</code> in the program's current directory.</p> <pre><code>program DirPathFileCreateDirUTF8;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes, \n  SysUtils;\n\nvar\n  directoryName: string;\nbegin\n  directoryName := ConcatPaths(['demo','\u80dc\u5229']);\n  if ForceDirectories(directoryName) then\n    WriteLn('Directory created successfully')\n  else\n    WriteLn('Failed to create directory');\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#check-if-a-directory-exists","title":"Check if a directory exists","text":"<p>Use <code>FileExists</code> from unit <code>SysUtils</code>.</p> <pre><code>program CheckDirExists;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nbegin\n\n  if (DirectoryExists('sub-folder/')) then\n    WriteLn('That folder exists!')\n  else\n    WriteLn('Can''t find it!');\n\n  // Pause console\n  ReadLn;\n\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#check-if-a-file-exists","title":"Check if a file exists","text":"<p>Use <code>FileExists</code> from unit <code>SysUtils</code>.</p> <pre><code>program CheckFileExists;\n\nuses\n  SysUtils;\n\nvar\n  fileName: String;\n\nbegin\n  fileName := 'hello-world.txt';\n\n  if FileExists(fileName) then\n    Writeln( fileName, ' exists.')\n  else\n    Writeln(fileName, ' does not exist.');\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#find-a-file-type-in-a-folder-findfirst","title":"Find a file type in a folder (FindFirst)","text":"<p>Here is an example searching for <code>*.csv</code> files using <code>FindFirst</code>.</p> <ol> <li>Add <code>SysUtils</code> in uses section. Line 10.</li> <li> <p>Call <code>FindFirst</code> with 3 arguments. Line 21.</p> <ul> <li>Path and a wildcard pattern.</li> <li>Attribute, use <code>faAnyFile</code>.</li> <li>Outpt TSearchRec variable to store results.</li> </ul> </li> <li> <p>If <code>FindFirst</code> returns 0, loop using <code>repeat ... until FindNext(searchResult) &lt;&gt; 0</code>. Line 23 to 31.</p> </li> <li>Lastly, free resources relating to <code>FindFirst</code> and <code>FindNext</code> using <code>FindClose</code>. Line 39.</li> </ol> <pre><code>program FindFirstSearch;\n\n{$mode objfpc}{$H+}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  searchRec: TSearchRec;\n  path: string = './sub-folder/';\n  criteria: string = '*.csv';\n  Count: integer = 0; // Optional, only if you need a count\n\nbegin\n\n  // Call FindFirst, requires 3 arguments\n  if FindFirst(path + criteria, faAnyFile, searchRec) = 0 then\n  begin\n    repeat\n      if (searchRec.Name &lt;&gt; '.') and (searchRec.Name &lt;&gt; '..') and (searchRec.Attr &lt;&gt; faDirectory) then\n      begin\n        // Optional, only if you need a count -- increase a counter\n        Inc(Count);\n        // Display files found by FindFirst\n        WriteLn(searchRec.Name);\n      end;\n    until FindNext(searchRec) &lt;&gt; 0;\n\n    // A successful FindFirst call must always be followed by a FindClose call\n    // with the same TSearchRec record. Failure to do so will result in memory leaks.\n    // If the findfirst call failed (i.e. returned a nonzero handle) there is\n    // no need to call FindClose.\n    // See https://www.freepascal.org/docs-html/3.2.2/rtl/sysutils/findfirst.html\n    FindClose(searchRec);\n  end;\n\n  // Display count of matching files\n  WriteLn(Format('Found %d files matching %s', [Count, criteria]));\n\n  // Pause console\n  WriteLn;\n  WriteLn('Press Enter key to quit');\n  ReadLn;\nend.\n</code></pre> <p>References</p> <ul> <li>https://www.freepascal.org/docs-html/3.2.2/rtl/sysutils/findfirst.html.</li> <li>https://www.freepascal.org/docs-html/3.2.2/rtl/sysutils/findnext.html</li> <li>https://www.freepascal.org/docs-html/3.2.2/rtl/sysutils/findclose.html</li> </ul>"},{"location":"docs/core-tasks/dir-path-filename/#find-multiple-file-types-in-a-folder-findfirst","title":"Find multiple file types in a folder (FindFirst)","text":"<p>See the snippet below, which looks for <code>*.csv</code> and <code>*.txt</code> files.</p> <p>I added <code>IsFileNameMatching</code> to match <code>searchRec.Name</code> against a regex experssion. Line 13-34.</p> <ol> <li>When calling <code>FindFirst</code> use <code>*</code> or <code>*.*</code>. The Regex will do the filtering. Line 44.</li> <li>In the <code>repeat ... until FindNext(searchRec) &lt;&gt; 0</code> loop, simply match <code>searchRec.Name</code> against a regular expression. That's it. Line 49.</li> <li>Call <code>FindClose</code> to release resources used by <code>FindFirst</code> and <code>FindNext</code>. Line 59. </li> </ol> <pre><code>program FindFirstSearchRegex;\n\n{$mode objfpc}{$H+}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  RegExpr;\n\n  // A function for matching filename against a regex pattern\n  function IsFileNameMatching(const fileName: string; const regexPattern: string): boolean;\n  var\n    regex: TRegExpr;\n  begin\n    regex := TRegExpr.Create;\n    try\n      // Set the regex to case-insensitive\n      regex.ModifierI := True;\n      // Apply the regex pattern\n      regex.Expression := regexPattern;\n\n      // Check for a match\n      if regex.Exec(filename) then\n        Result := True\n      else\n        Result := False;\n    finally\n      // Free TRegExpr\n      regex.Free;\n    end;\n  end;\n\nvar\n  searchRec: TSearchRec;\n  path: string = './sub-folder/';\n  regexExpression: string = '(.csv|.txt)';\n  Count: integer = 0; // Optional, only if you need a count\n\nbegin\n  // Call FindFirst, append *.* to path\n  if FindFirst(path + '*.*', faAnyFile, searchRec) = 0 then\n  begin\n    repeat\n      if (searchRec.Name &lt;&gt; '.') and (searchRec.Name &lt;&gt; '..') and (searchRec.Attr &lt;&gt; faDirectory) then\n      begin\n        if IsFileNameMatching(searchRec.Name, regexExpression) then\n        begin\n          // Optional, only if you need a count -- increase a counter\n          Inc(Count);\n          // Display files found by FindFirst\n          WriteLn(searchRec.Name);\n        end;\n      end;\n    until FindNext(searchRec) &lt;&gt; 0;\n    // MUST FREE RESOURCES relating to FindFirst and FindNext\n    FindClose(searchRec);\n  end;\n\n  // Display count of matching files\n  WriteLn(Format('Found %d files matching %s', [Count, regexExpression]));\n\n  // Pause console\n  WriteLn;\n  WriteLn('Press Enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#find-a-file-type-in-a-folder-and-store-in-an-array-findfirst","title":"Find a file type in a folder and store in an array (FindFirst)","text":"<p>It is pretty straightforward. </p> <p>See the snippet below that looks for <code>*.csv</code> in a folder and store the names of <code>*.csv</code>  files in an <code>array of string</code>.</p> <ol> <li>Add <code>SysUtils</code> in the uses. Line 10.</li> <li>Call the <code>FindFirst</code>. Line 22.</li> <li> <p>Store files found into an array in the in the <code>repeat ... until FindNext(searchRec) &lt;&gt; 0</code> loop. Line 27-32.</p> <ul> <li>Set the new length of the array.</li> <li>Assign the <code>searchRec.Name</code> into the new index.</li> <li>Increment counter to set the new length in the next loop.</li> </ul> </li> <li> <p>Lastly, free resources relating to <code>FindFirst</code> and <code>FindNext</code> using <code>FindClose</code>. Line 36.</p> </li> </ol> <pre><code>program FindFirstSearchStoreArray;\n\n{$mode objfpc}{$H+}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  searchRec: TSearchRec;\n  path: string = './sub-folder/';\n  criteria: string = '*.csv';\n  filesFound: array of string;\n  fileCount: integer = 0;\n  i: integer;\n\nbegin\n  // Call FindFirst, append wildcard pattern to path\n  if FindFirst(path + criteria, faAnyFile, searchRec) = 0 then\n  begin\n    repeat\n      if (searchRec.Name &lt;&gt; '.') and (searchRec.Name &lt;&gt; '..') and (searchRec.Attr &lt;&gt; faDirectory) then\n      begin\n        // Set length the array of string\n        SetLength(filesFound, fileCount + 1);\n        // Add file name from searchRec into this array\n        filesFound[fileCount] := searchRec.Name;\n        // Increment file counter\n        Inc(fileCount);\n      end;\n    until FindNext(searchRec) &lt;&gt; 0;\n    // MUST RELEASE RESOURCES relating to FindFirst and FindNext\n    FindClose(searchRec);\n  end;\n\n  // Display count of matching files\n  WriteLn(Format('Found %d files matching %s', [Length(filesFound), criteria]));\n\n  // Display all files\n  for i := 0 to High(filesFound) do WriteLn(filesFound[i]);\n\n  // Pause console\n  WriteLn;\n  WriteLn('Press Enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#find-multiple-file-types-and-store-in-an-array-findfirst","title":"Find multiple file types and store in an array (FindFirst)","text":"<p>Straightforwrd, simply by extending from the previous snippet we can achieve this.</p> <ol> <li>When calling <code>FindFirst</code> use <code>*</code> or <code>*.*</code>. The Regex will do the filtering. Line 46.</li> <li>Do <code>SetLength</code> and add <code>searchRec.Name</code> into array if <code>IsFileNameMatching(searchRec.Name, regexExpression)</code> returns <code>True</code>. Line 53-63.</li> <li>Call <code>FindClose(searchRec)</code> at the end of <code>FindNext(searchRec)</code> to avoid memory leaks. Line 67.</li> </ol> <pre><code>program FindFirstSearchRegexStoreInArray;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  RegExpr;\n\n  // A function for matching filename against a regex pattern\n  function IsFileNameMatching(const fileName: string; const regexPattern: string): boolean;\n  var\n    regex: TRegExpr;\n  begin\n    regex := TRegExpr.Create;\n    try\n      // Set the regex to case-insensitive\n      regex.ModifierI := True;\n      // Apply the regex pattern\n      regex.Expression := regexPattern;\n\n      // Check for a match\n      if regex.Exec(filename) then\n        Result := True\n      else\n        Result := False;\n    finally\n      // Free TRegExpr\n      regex.Free;\n    end;\n  end;\n\nvar\n  searchRec: TSearchRec;\n  path: string = './sub-folder/';\n  regexExpression: string = '(.csv|.txt)';\n  filesFound:array of string;\n  fileCount: integer = 0;\n  i: integer;\n\nbegin\n  // Call FindFirst, append *.* to path\n  if FindFirst(path + '*.*', faAnyFile, searchRec) = 0 then\n  begin\n    repeat\n      // Skipping `.`, `..` and directories\n      if (searchRec.Name &lt;&gt; '.') and (searchRec.Name &lt;&gt; '..') and (searchRec.Attr &lt;&gt; faDirectory) then\n      begin\n        // Matching result against a regex expression\n        if IsFileNameMatching(searchRec.Name, regexExpression) then\n        begin\n          // Set length the array of string\n          SetLength(filesFound, fileCount + 1);\n          // Add file name from searchRec into this array\n          filesFound[fileCount] := searchRec.Name;\n          // Increment file counter\n          Inc(fileCount);\n          // Display files found by FindFirst\n          WriteLn(searchRec.Name);\n        end;\n      end;\n    until FindNext(searchRec) &lt;&gt; 0;\n    // MUST FREE RESOURCES relating to FindFirst and FindNext\n    FindClose(searchRec);\n  end;\n\n  // Display count of matching files\n  WriteLn(Format('Found %d files matching %s', [Length(filesFound), regexExpression]));\n\n  // Pause console\n  WriteLn;\n  WriteLn('Press Enter key to quit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#find-multiple-file-types-recursively-findfirst","title":"Find multiple file types recursively (FindFirst)","text":"<p>See an example below, using <code>TRegExpr</code> and <code>FindFirst</code>.</p> <p>It may seem complicated, however, the algorithm in <code>SearchFiles</code> is pretty straightforward.</p> <ol> <li>Call <code>FindFirst</code> using <code>*</code> or <code>*.*</code>. The Regex will do the filtering.</li> <li> <p>In the <code>repeat ... until FindNext(searchResult) &lt;&gt; 0</code> loop;</p> <ul> <li>Check if the current <code>searchRec.name</code> it is a folder. <ul> <li>If yes, call this function, along with the name of the found folder, <code>path + searchRec.Name</code>.</li> <li>If not, use <code>IsFileNameMatching</code> to match filename against a regex expression.</li> </ul> </li> </ul> </li> <li> <p>Lastly, call <code>FindClose(searchRec)</code>.</p> </li> </ol> <pre><code>program FindFirstSearchRecursive;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  RegExpr;\n\n  // A function for matching filename against a regex pattern\n  function IsFileNameMatching(const fileName: string; const regexPattern: string): boolean;\n  var\n    regex: TRegExpr;\n  begin\n    regex := TRegExpr.Create;\n    try\n      // Set the regex to case-insensitive\n      regex.ModifierI := True;\n      // Apply the regex pattern\n      regex.Expression := regexPattern;\n\n      // Check for a match\n      if regex.Exec(filename) then\n        Result := True\n      else\n        Result := False;\n    finally\n      // Free TRegExpr\n      regex.Free;\n    end;\n  end;\n\n  // A recursive search function using FindFirst and Regex\n  procedure SearchFiles(const path: string; const regexPattern: string);\n  var\n    searchRec: TSearchRec;\n  begin\n    if FindFirst(path + '*.*', faAnyFile, searchRec) = 0 then\n    begin\n      repeat\n        if (searchRec.Name &lt;&gt; '.') and (searchRec.Name &lt;&gt; '..') then\n        begin\n          // If searchRec.Name is a directory, then call this function recursively\n          if (searchRec.Attr and faDirectory) = faDirectory then\n          begin\n            // If found a directory, perform search on that directory\n            SearchFiles(path + searchRec.Name + PathDelim, regexPattern);\n          end\n          else\n            // If searchRec.Name is not a directory, check if the file matches regex pattern\n          begin\n            if IsFileNameMatching(path + searchRec.Name, regexPattern) then\n              // If it matches regex expression, display name\n              WriteLn(path + searchRec.Name);\n          end;\n        end;\n      until FindNext(searchRec) &lt;&gt; 0;\n      // MUST RELEASE resources relating to FindFirst and FindNext\n      FindClose(searchRec);\n    end;\n  end;\n\nvar\n  path: string = './sub-folder/';\n  regexPattern: string = '(.csv|.xlsx)';\n\nbegin\n  // Display files in a path, recursively, using a regex pattern\n  SearchFiles(path, regexPattern);\n\n  // Pause Console\n  WriteLn('Press Enter key to Exit');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/dir-path-filename/#find-multiple-file-types-recursively-lazutils-package-the-most-straightforward-of-all","title":"Find multiple file types recursively (LazUtils package - The most straightforward of all)","text":"<p>You can use FindAllFiles from <code>FileUtil</code> unit.</p> <p>To use this unit, you must add <code>LazUtils</code> package from the <code>Project Inspector -&gt; Required Packages</code>.</p> <p></p> <p>Here is an example. This program looks for <code>csv</code> and <code>xslx</code> files in a sub-folder.</p> <ol> <li>Add <code>FileUtil</code> in the uses section.</li> <li> <p>Invoke the <code>FindAllFiles</code> and save the output into a <code>TStringList</code> variable. You don't need to instantiate the <code>TStringList</code> object separately; <code>FindAllFiles</code> handles it automatically. When calling this function, make sure to provide the following:</p> <ul> <li>The path to be searched.</li> <li>The types of files to be searched.</li> <li>Specify whether the search should be recursive.</li> </ul> </li> <li> <p>Lastly, free the <code>TStringList</code>.</p> </li> </ol> <pre><code>program ListAllFiles;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  FileUtil, // Add LazUtils in Project Inspector -&gt; Required Packages first\n  SysUtils;\n\nvar\n  searchResults: TStringList;\n  path: string = './sub-folder/';\n  criteria: string = '*.csv;*.xlsx';\n  isRecursive: boolean = True;\n  item: string;\n\nbegin\n\n  // Call FindAllFiles, no need to create TStringList manually\n  searchResults := FindAllFiles(path, criteria, isRecursive);\n  try\n    // Print number of files found\n    WriteLn(Format('Found %d files', [searchResults.Count]));\n\n    // Display results, if any\n    if searchResults.Count &gt; 0 then\n      for item in searchResults do WriteLn(item);\n\n  finally\n    // Free the TStringList\n    searchResults.Free;\n  end;\n\n  // Pause console\n  WriteLn;\n  WriteLn('Press Enter key to exit ...');\n  ReadLn;\nend.\n</code></pre> <p>References</p> <ul> <li>https://lazarus-ccr.sourceforge.io/docs/lazutils/fileutil/findallfiles.html</li> <li>https://www.tweaking4all.com/forum/delphi-lazarus-free-pascal/lazarus-find-all-files-in-a-directory-and-subdirectories-matching-criteria/</li> </ul>"},{"location":"docs/core-tasks/exception-try-blocks/","title":"Exceptions","text":""},{"location":"docs/core-tasks/exception-try-blocks/#when-do-i-use-tryfinally-blocks","title":"When do I use <code>try...finally</code> blocks?","text":"<p>Use them for the following tasks.</p> <ul> <li>clean up resources or <code>Free</code> memory within a block that allocates memory, or</li> <li>close files in case an exception occured.</li> </ul>"},{"location":"docs/core-tasks/exception-try-blocks/#when-do-i-use-tryexception-blocks","title":"When do I use <code>try...exception</code> blocks?","text":"<p>Use them to catch exceptions and provide a means to recover in the code.</p>"},{"location":"docs/core-tasks/exception-try-blocks/#can-i-nest-exception-handling","title":"Can I nest exception handling?","text":"<p>Yes you can. See Language Reference 17.4.</p> <p>Here is an example. The snippet below has one outer <code>try...except</code> that can catch any error from <code>TFileStream</code> or <code>TStreamReader</code>.</p> <pre><code>program ReadTextFile;\n\nuses\n  Classes, SysUtils, streamex;\n\n// Procedure to read a text file\nprocedure ReadTextFile(const filename: string);\nvar\n  fileStream: TFileStream;\n  inputReader: TStreamReader;\n  line: string;\nbegin\n  try\n    fileStream := TFileStream.Create(filename, fmOpenRead);\n    try\n      inputReader := TStreamReader.Create(fileStream);\n      try\n        while not inputReader.EOF do\n        begin\n          line := inputReader.ReadLine;\n          WriteLn(line);\n        end;\n      finally\n        inputReader.Free;\n      end;\n    finally\n      fileStream.Free;\n    end;\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end;\nend;\n\nbegin\n\n  // Read a file and print to std out\n  ReadTextFile('cupcake-ipsum.txt');\nend.\n</code></pre>"},{"location":"docs/core-tasks/exception-try-blocks/#how-can-i-make-a-routine-with-nested-tryfinally-blocks-in-a-tryexcept-block-more-readable","title":"How can I make a routine with nested <code>try...finally</code> blocks in a <code>try...except</code> block more readable?","text":"<p>Tip</p> <p>..  your first goal ... to achieve a working solution, then you can think about how to make it pretty.</p> <p>- NiteHawk (Unofficial Free Pascal Discord Server)</p> <p>Short answer. Split your routine into sub-routines. Let the the last/outmost <code>try...except</code> block handle any uncaught exceptions.</p> <p>Better answer. Consider the snippet of <code>program ReadTextFile;</code> from the previous question, and the following tips from Unofficial Free Pascal Discord.</p> <p>Tip - making your code readble</p> <p>... Why not make it work with either a stream or a filename, using \"method\" overloading? The filename based version would create a corresponding stream and make use of the other variant, to avoid code duplication and improve readability.</p> <p>-NiteHawk (Free Pascal Discord Server)</p> <p>Tip - The Beauty of exceptions</p> <p>As for exception handling: The \"beauty\" of exceptions is that they trickle down the call chain until they finally get handled somewhere. That's why it makes sense to handle \"low-level\" stuff like an unconditional (= irrespective of error state) <code>Free</code> within the blocks that allocated memory. </p> <p>... I tend to handle everything else at the \"outmost\" level possible/desirable. The code below has one outer <code>try</code>..<code>except</code> that is supposed to catch any error, be it from <code>ReadTextFile(filename: string)</code> (e.g. non-existing file), or the actual stream reader.</p> <p>-NiteHawk (Free Pascal Discord Server)</p> <pre><code>program ReadTextFileOverloading;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Classes, StreamEx, SysUtils;\n\n// Procedure to read a text file from stream\nprocedure ReadTextFile(const AStream: TStream); override;\nvar\n  inputReader: TStreamReader;\n  line: string;\nbegin\n  inputReader := TStreamReader.Create(AStream);\n  try\n    while not inputReader.EOF do\n    begin\n      line := inputReader.ReadLine;\n      WriteLn(line);\n    end;\n  finally\n    inputReader.Free;\n  end;\nend;\n\n// Procedure to read a text file by file name\nprocedure ReadTextFile(const filename: string); override;\nvar\n  fileStream: TFileStream;\nbegin\n  fileStream := TFileStream.Create(filename, fmOpenRead);\n  try\n    ReadTextFile(fileStream);\n  finally\n    fileStream.Free;\n  end;\nend;\n\n// MAIN\nbegin\n  try\n    ReadTextFile('ikel.pas');\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end;\nend.\n</code></pre>"},{"location":"docs/core-tasks/exception-try-blocks/#where-can-i-get-more-info-on-handling-exceptions","title":"Where can I get more info on handling exceptions?","text":"<p>The Free Pascal wiki has an article on it: Exception.</p>"},{"location":"docs/core-tasks/file-handling-ii/","title":"File Handling II","text":"<p>More snippets on handling files using Free Pascal.</p>"},{"location":"docs/core-tasks/file-handling-ii/#listing-specific-columns-in-a-csv-file-tcsvdataset","title":"Listing specific columns in a CSV file - TCSVDataSet","text":"<p>Here is an example of reading first two columns in a CSV file using <code>TCSVDataset</code>.</p> <pre><code>program TCSVDatasetGetSpecificCols;\n\n{\n An example of listing the content of first two columns in a CSV file\n using TCSVDataset.\n}\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  streamex,\n  bufstream,\n  csvdataset;\n\n  // A routine to list first two columns of a CSV file\n  procedure ReadCSV(filename: string;\n                    delimiter: char = ',';\n                    isFirstRowFieldName: boolean = False);\n  var\n    fileStream: TFileStream;\n    buffStream: TReadBufStream;\n    csvDataset: TCSVDataset;\n    lineNo: int64;\n  begin\n    fileStream := TFileStream.Create(filename, fmOpenRead);\n    try\n      buffStream := TReadBufStream.Create(fileStream, 65536);\n      try\n        csvDataset := TCSVDataset.Create(nil);\n        try\n\n          // Assign a valid delimiter\n          csvDataset.CSVOptions.Delimiter := delimiter;\n\n          // Is the first line field names?\n          // If yes, first row will be excluded when listing rows\n          csvDataset.CSVOptions.FirstLineAsFieldNames := isFirstRowFieldName;\n\n          // Load CSV from the stream\n          csvDataset.LoadFromCSVStream(buffStream);\n\n          // Move to first record\n          csvDataset.First;\n\n          lineNo := 1;\n\n          while not csvDataset.EOF do\n          begin\n            // Get the values of the first two fields here and list them.\n            WriteLn(Format('row %d: %s, %s',\n                           [lineNo,\n                            csvDataset.Fields[0].AsString,\n                            csvDataset.Fields[1].AsString]));\n\n            // Move to next\n            csvDataset.Next;\n\n            // Increment line no\n            lineNo := lineNo + 1;\n          end;\n\n        finally\n          csvDataset.Free;\n        end;\n      finally\n        buffStream.Free;\n      end;\n    finally\n    end;\n    fileStream.Free;\n  end;\n\nvar\n  filename: string;\n\nbegin\n\n  filename := ParamStr(1);\n  if not FileExists(filename) then\n  begin\n    WriteLn('Cannot find file.');\n    Exit;\n  end;\n\n  ReadCSV(filename, ';', False);\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling-ii/#listing-specific-columns-in-a-csv-file-tcsvdocument","title":"Listing specific columns in a CSV file - TCSVDocument","text":"<p>Here is an example of reading first two columns in a CSV file using <code>TCSVDocument</code>.</p> <pre><code>program TCSVDocumentGetSpecificCols;\n\n\n{\n An example of listing the content of first two columns in a CSV file\n using TCSVDocument.\n}\n\n{$mode objfpc}{$H+}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  csvdocument,\n  streamex,\n  bufstream;\n\n  procedure ReadCSV(filename: string; delimiter: char);\n  var\n    fileStream: TFileStream;\n    buffStream: TReadBufStream;\n    csvReader: TCSVDocument;\n    index, totalLines: int64;\n  begin\n    totalLines := 0;\n    fileStream := TFileStream.Create(filename, fmOpenRead);\n    try\n      buffStream := TReadBufStream.Create(fileStream, 65536);\n      try\n        csvReader := TCSVDocument.Create;\n        try\n          // Assign a delimiter\n          csvReader.Delimiter := delimiter;\n\n          // Assign a source stream.\n          csvReader.LoadFromStream(buffStream, 65536);\n\n          // Get total lines for iteration.\n          totalLines := csvReader.RowCount;\n\n          // Print the values of first two columns from the CSV file.\n          for index := 0 to totalLines-1 do\n          begin\n            WriteLn(Format('row %d: %s, %s', [(index + 1),\n                                              csvReader.Cells[0, index],\n                                              csvReader.Cells[1, index]]));\n          end;\n\n        finally\n          csvReader.Free;\n        end;\n      finally\n        buffStream.Free;\n      end;\n    finally\n    end;\n    fileStream.Free;\n  end;\n\nvar\n  filename: string;\n\nbegin\n  filename := ParamStr(1);\n  if not FileExists(filename) then\n  begin\n    WriteLn('Cannot find file.');\n    Exit;\n  end;\n\n  ReadCSV(filename, ';');\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling-ii/#split-text-file-into-chunks-of-1-mbytes-tfilestream","title":"Split text file into chunks of 1 Mbytes - TFileStream","text":"<p>This snippet splits a large text file into smaller chunks without breaking lines or paragraphs. Here's a summary of the program's functionality:</p> <ul> <li>Procedure <code>SaveChunkToFile</code>: Handles creating new files for each chunk and writing the chunk data to these files.</li> <li>Constants and Variables:<ul> <li><code>defaultChunkSize</code>: The size of each chunk, set to 1 MB.</li> <li><code>fileStream</code>: Used to read from the input file.</li> <li><code>buffer</code>: A memory buffer to hold chunk data.</li> <li><code>bytesRead</code>, <code>totalBytesRead</code>, <code>chunkSize</code>, <code>lineBreakPos</code>, <code>chunkIndex</code>: Variables to track file reading and processing.</li> </ul> </li> <li>Main Logic:<ul> <li>The program checks if the input file exists.</li> <li>It reads the file in chunks, finds the last newline in each chunk, adjusts the file pointer if necessary, and writes each chunk to a new file.</li> <li>The loop continues until the entire text file is processed.</li> </ul> </li> </ul> <pre><code>program TFileStreamSplitFile;\n\n{\n This program splits a text file based on a chunkSize.\n The algorithm ensures it won't split the text in the middle of a line/paragraph.\n\n 1. Open the file and allocate memory bufers for reading chunks of data.\n\n 2. Read the file in chunks and locate the last `\\n` character in the chunk.\n    Once it locates the last `\\n` in the chunk, move the file pointer back to include\n    that byte and any preceding bytes of the partial line in the next chunk's read operation.\n\n 3. Repeat - read and parse the remainder.\n\n 4. Once parsing is complete, close the file and free any allocated memory (to prevent memory leaks).\n}\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  SysUtils,\n  Classes,\n  bufstream;\n\n  procedure SaveChunkToFile(const filename: string; const chunkData: pansichar;\n  const dataSize: integer; const chunkIndex: integer);\n  var\n    chunkFile: TFileStream;\n  begin\n    // Create a new file for the chunk\n    chunkFile := TFileStream.Create(filename + '-chunk-' + IntToStr(ChunkIndex) +\n      '.txt', fmCreate);\n    try\n      // Write the chunk data to the chunk file\n      chunkFile.WriteBuffer(chunkData^, dataSize);\n    finally\n      chunkFile.Free;\n    end;\n  end;\n\nconst\n  defaultChunkSize: integer = 1048576; // 1 MB in bytes\n\nvar\n  fileStream: TFileStream;\n  buffer: pansichar;\n  bytesRead, totalBytesRead, chunkSize, lineBreakPos, chunkIndex: int64;\n\nbegin\n\n  if not FileExists(ParamStr(1)) then\n  begin\n    WriteLn('Please spefcify a valid text file.');\n    Exit;\n  end;\n\n  chunkSize := defaultChunkSize * 1;\n\n  // Open the file for reading\n  fileStream := TFileStream.Create(ParamStr(1), fmOpenRead);\n  try\n    // Allocate memory buffer for reading chunks\n    // Ref: https://www.freepascal.org/docs-html/rtl/system/getmem.html\n    GetMem(buffer, chunkSize);\n    try\n      totalBytesRead := 0;\n      chunkIndex := 0;\n\n      // Read and parse chunks of data until EOF\n      while totalBytesRead &lt; fileStream.Size do\n      begin\n        bytesRead := fileStream.Read(buffer^, chunkSize);\n        Inc(totalBytesRead, bytesRead);\n\n        // Find the position of the last newline character in the chunk\n        lineBreakPos := BytesRead;\n        while (lineBreakPos &gt; 0) and (Buffer[lineBreakPos - 1] &lt;&gt; #10) do\n          Dec(lineBreakPos);\n\n        { Now, must ensure that if the last byte read in the current chunk\n          is not a newline character, the file pointer is moved back to include\n          that byte and any preceding bytes of the partial line in the next\n          chunk's read operation.\n\n          Also, no need to update the BytesRead variable in this context because\n          it represents the actual number of bytes read from the file, including\n          any partial line that may have been included due to moving the file\n          pointer back.\n          Ref: https://www.freepascal.org/docs-html/rtl/classes/tstream.seek.html}\n        if lineBreakPos &lt; bytesRead then\n          fileStream.Seek(-(bytesRead - lineBreakPos), soCurrent);\n\n        // Write the chunk data to a file using the separate procedure\n        SaveChunkToFile('output', buffer, lineBreakPos, chunkIndex);\n\n        // Display user feedback\n        WriteLn('Chunk ', chunkIndex, ', Total bytes read:', IntToStr(totalBytesRead));\n\n        // Increase chunk index - a counter\n        Inc(chunkIndex);\n      end;\n    finally\n      // Free the memory buffer\n      FreeMem(buffer);\n    end;\n  finally\n    // Close the file\n    fileStream.Free;\n  end;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/","title":"File Handling I","text":"<p>This page deals mostly with creating, reading and appending plain text files in Free Pascal.</p> <p>Note</p> <p>The community page - File Handling in Free Pascal - gives a general overview on handling file on various use cases. There are good tips too. For example, using <code>AssignFile</code> and <code>try..except</code>, copying file, etc. </p>"},{"location":"docs/core-tasks/file-handling/#writing-a-new-text-file","title":"Writing a new text file","text":"<p>There are many ways to do this;</p> <ol> <li>The classic style (using the File Handling Functions) and </li> <li> <p>The object style, including:</p> <ul> <li><code>TFileStream</code>.</li> <li><code>TStringList</code> and</li> </ul> </li> </ol>"},{"location":"docs/core-tasks/file-handling/#new-text-file-classic","title":"New text file - Classic","text":"<p>See the snippet below. It uses <code>SysUtil</code> for catching errors during opening and writing file.</p> <ol> <li>Use <code>AssignFile</code> to assign a text file to a file type <code>TextFile</code>. Line 14.</li> <li>Use <code>Rewrite</code> to open file for writing (and create if doesn't exists). Line 19.</li> <li>Add text using the assigned file type and <code>WriteLn</code>. Line 22.</li> <li>Close the file with <code>CloseFile</code> in the <code>try..finally</code> block. Line 31.</li> </ol> <p>[When saving file the classic way] you should always strive to have a <code>try..finally</code> outside the <code>try..except</code>.</p> <p>-Gustavo 'Gus' Carreno</p> <pre><code>program ClassicNewTextFile;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils;\n\nvar\n  textFile: System.TextFile;\n\nbegin\n    try\n      // Set the name of the file that will be created\n      AssignFile(textFile, 'output_file.txt');\n\n      // Enclose in try/except block to handle errors\n      try\n        // Create (if not found) and open the file for writing\n        Rewrite(textFile);\n\n        // Adding text\n        WriteLn(textFile, 'Hello Text!');\n\n      except\n        // Catch error here\n        on E: EInOutError do\n          WriteLn('Error occurred. Details: ', E.ClassName, '/', E.Message);\n      end;\n    finally\n      // Close file\n      CloseFile(textFile);\n    end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre> <p>Overly verbose with <code>try...finally</code>? It can be written as follows too.</p> <pre><code>program ClassicNewTextFileSimple;\n\n{$mode objfpc}{$H+}{$J-}\n\nvar\n  textFile: System.TextFile;\n\nbegin\n  AssignFile(textFile, 'output_file.txt');\n  ReWrite(textFile);\n  WriteLn(textFile, 'This is a new line');\n  CloseFile(textFile);\nend.\n</code></pre> <p>Warning</p> <p>But what will happen if the file if locked by another process? </p> <p>What will happen when the file accidentally got deleted before closing it?</p> <p>Boom! It will crash.</p> <p>I'd prefer to handle error gracefully. Hence, I like the first snippet better.</p>"},{"location":"docs/core-tasks/file-handling/#new-text-file-classic-alt","title":"New text file - Classic alt","text":"<p>You can streamline the process of writing text to a file by refactoring the lines into a procedure.</p> <p>Here is an example. </p> <ul> <li>The lines that write text is refactored into a procedure. See line 9-36.</li> <li>Now, writing a text into a file is in a line. See line 41.</li> </ul> <pre><code>program ClassicNewTextFileOrganised;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils;\n\n  // Write or append a text to a file\n  procedure WriteTextToFile(fileName: string; stringText: string;);\n  var\n    textFile: System.TextFile;\n  begin\n    try \n      // Set the name of the file that will be created\n      AssignFile(textFile, fileName);\n\n      // Enclose in try/except block to handle errors\n      try\n        // Create (if not found) and open the file for writing\n        Rewrite(textFile);\n\n        // Adding text\n        WriteLn(textFile, stringText);\n\n      except\n        // Catch error here\n        on E: EInOutError do\n          WriteLn('Error occurred. Details: ', E.ClassName, '/', E.Message);\n      end;\n    finally\n      // Close file\n      CloseFile(textFile);\n    end;\n  end;\n\nbegin\n\n  // Write a text to a file\n  WriteTextToFile('hello-text.txt', 'Hello There! How are you?');\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#new-text-file-tfilestream","title":"New text file - <code>TFileStream</code>","text":"<p>For writing text into a new file using Object style;</p> <ol> <li>create a new file; <code>TFileStream.Create(fileName, fmCreate);</code>. Line 14.</li> <li>set the current position in the stream as 0; <code>TFileStream.Position := 0;</code>. Line 17.</li> <li>write using <code>TFileStream.Write(stringText, Length(stringText));</code> Line 18.</li> <li><code>Free</code> the <code>TFileStream</code> object from memory. Lines 22.</li> </ol> <pre><code>program TFileStreamNewTextFile;\n\nuses\n  Classes, SysUtils;\n\nvar\n  text: string = 'QILT Surveys';\n  filename :String = 'hello-text.txt';\n  fileStream: TFileStream;\n  size: longint;\n\nbegin\n  // Create a TFileStream object\n  fileStream := TFileStream.Create(filename, fmCreate);\n  try\n    // set position at the beginning of file\n    fileStream.Position := 0;\n    // Write text into the file\n    size := fileStream.Write(text[1], Length(text));\n    // Show confirmation\n    Writeln(Format('Created %s. %d bytes written.', [filename, size]));\n  finally\n    // Free TFileStream object\n    fileStream.Free;\n  end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#new-text-file-tfilestream-alt","title":"New text file - <code>TFileStream</code> (alt)","text":"<p>This example is the previous snippet wrapped in a <code>procedure</code>.</p> <pre><code>program TFileStreamNewTextFileOrganised;\n\nuses\n  Classes, SysUtils;\n\n  // Write text into a new file\n  procedure WriteStreamToFile(fileName: string; text: string);\n  var\n    fileStream: TFileStream;\n    size: longint;\n  begin\n    fileStream := TFileStream.Create(fileName, fmCreate);\n    try\n      // set position at the beginning og file\n      fileStream.Position := 0;\n      // Write text into the file\n      size := fileStream.Write(text[1], Length(text));\n      // Show confirmation\n      Writeln(Format('Created %s. %d bytes written.', [filename, size]));\n    finally\n      // Free TFileStream object\n      fileStream.Free;\n    end;\n  end;\n\nvar\n  myText: string = 'QILT Surveys';\n  filename :String = 'hello-text.txt';\n\nbegin\n\n  WriteStreamToFile(filename, myText);\n\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#new-text-file-tsringlist","title":"New text file - <code>TSringList</code>","text":"<ol> <li>Create the <code>TStringList</code> object. Line 18.</li> <li>Use the <code>Add</code> method to add text or lines. Line 21-22.</li> <li>Use <code>SaveToFile</code> to save your <code>TStringList</code> into a text file. Line 25.</li> <li>Remember to <code>Free</code> the resources. Line 28.</li> </ol> <pre><code>program TStringListNewTextFile;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes;\n\nvar\n  textFileName: string = 'hello-text.txt';\n  stringList: TStringList;\n\nbegin\n\n  // Create TStringList object\n  stringList := TStringList.Create;\n  try\n    // Add lines\n    stringList.Add('Hello Line 1!');\n    stringList.Add('Hello Line 2!');\n\n    // Save to a file\n    stringList.SaveToFile(textFileName);\n  finally\n    // Free object\n    stringList.Free;\n  end;\n\n  // Pause Console\n  WriteLn('Press Enter key to exit ...');\n  ReadLn;\n\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#create-a-blank-text-file","title":"Create a blank text file","text":""},{"location":"docs/core-tasks/file-handling/#blank-text-file-classic","title":"Blank text file - Classic","text":"<p>Here is an example.</p> <ol> <li>Use <code>AssignFile</code> to assign a text file to a file type <code>TextFile</code>. Line 13.</li> <li>Use <code>Rewrite</code> to open file for writing (and create if doesn't exists). Line 18.</li> <li>Close the file with <code>CloseFile</code>. Line 21.</li> </ol> <pre><code>program ClassicCreateBlankTextFile;\n\nuses\n  Classes,\n  SysUtils;\n\nvar\n  filename: string = 'hello-text.txt';\n  textFile: System.TextFile;\n\nbegin\n  // Set the name of the file that will be created\n  AssignFile(textFile, filename);\n\n  // Enclose in try/except block to handle errors\n  try\n    // Open the file for writing (it will create it file doesn't exist)\n    ReWrite(textFile);\n\n    // Close file\n    CloseFile(textFile);\n\n    // Show a confirmation\n    WriteLn('Created a new blank file');\n\n  except\n    // Catch error here\n    on E: EInOutError do\n      WriteLn('Error occurred. Details: ', E.ClassName, '/', E.Message);\n  end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#blank-text-file-tfilestream","title":"Blank text file - <code>TFileStream</code>","text":"<p>Quite straightforward.</p> <ol> <li>create a new file; <code>TFileStream.Create(fileName, fmCreate);</code>. Line 15.</li> <li><code>Free</code> the <code>TFileStream</code> object from memory. Lines 21.</li> </ol> <pre><code>program TFileStreamCreateBlankTextFile;\n\nuses\n  Classes, SysUtils;\n\nvar\n  fileName: String;\n  fileStream: TFileStream;\n\nbegin\n  fileName := 'hello-text.txt';\n\n  try\n    // Create a new file without writing anyting into it\n    fileStream := TFileStream.Create(fileName, fmCreate);\n\n    // Show a confirmation\n    Writeln('Created a blank file: ', fileName);\n  finally\n    // Free resources\n    fileStream.Free;\n  end;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#blank-text-file-tstringlist","title":"Blank text file - <code>TStringList</code>","text":"<p>See the snippet below.</p> <ol> <li>Create the <code>TStringList</code> object. Line 18.</li> <li>Use <code>SaveToFile</code> to save your <code>TStringList</code> into a text file. Line 22.</li> <li>Remember to <code>Free</code> the resources. Line 25.</li> </ol> <pre><code>program TStringListBlankFIle;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes;\n\nvar\n  textFileName: string = 'hello-text.txt';\n  stringList: TStringList;\n\nbegin\n\n  // Create TStringList object\n  stringList := TStringList.Create;\n  try\n\n    // Save to a file\n    stringList.SaveToFile(textFileName);\n  finally\n    // Free object\n    stringList.Free;\n  end;\n\n  // Pause Console\n  WriteLn('Press Enter key to exit ...');\n  ReadLn;\n\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#append-to-an-existing-text-file","title":"Append to an existing text file","text":""},{"location":"docs/core-tasks/file-handling/#append-a-text-file-classic","title":"Append a text file - Classic","text":"<p>See an example below. The program will create a new file if the file for appending is not found.</p> <ol> <li> <p><code>AssignFile</code> and <code>CloseFile</code> is in outer <code>try..finally</code> block. This ensures the file will be closed whenever an IO error occured.</p> <ul> <li>Assign a string filename to a text file variable. Line 47.</li> <li>Remember to <code>CloseFile</code> after appending. Line 66.</li> </ul> </li> <li> <p>Appending text is inside the inner <code>try..except</code> block.</p> <ul> <li>Use <code>Append</code> to open the file in append mode. Line 52.</li> <li>Use <code>WriteLn</code> to add new text into the existing file. Line 55.</li> </ul> </li> </ol> <pre><code>program ClassicAppendTextFile;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  SysUtils;\n\n  // Create a new file, the classical way\n  procedure CreateNewFile(filename: string);\n  var\n    textFile: System.TextFile;\n  begin\n    // Set the name of the file that will be created\n    AssignFile(textFile, filename);\n\n    // Enclose in try/except block to handle errors\n    try\n      // Open the file for writing (it will create it file doesn't exist)\n      ReWrite(textFile);\n\n      // Close file\n      CloseFile(textFile);\n\n      // Show a confirmation\n      WriteLn(Format('Created a new file: ''%s''', [filename]));\n\n    except\n      // Catch error here\n      on E: EInOutError do\n        WriteLn('Error occurred. Details: ', E.ClassName, '/', E.Message);\n    end;\n  end;\n\nvar\n  filename: string = 'hello-text.txt';\n  textFile: System.TextFile;\n\nbegin\n\n  // First of all, check if the input file exists.\n  // If not, create a new text file\n  if not FileExists(filename) then\n    CreateNewFile(filename);\n\n  try\n    // Set filename to a file\n    AssignFile(textFile, filename);\n\n    // Enclose in try/except block to handle errors\n    try\n      // Open a file for appending.\n      Append(textFile);\n\n      // Adding text\n      WriteLn(textFile, 'New Line!');\n      WriteLn(textFile, 'New Line!');\n\n    except\n      // Catch error here\n      on E: EInOutError do\n        WriteLn('Error occurred. Details: ', E.ClassName, '/', E.Message);\n    end;\n\n  finally\n    // Close file\n    CloseFile(textFile);\n  end;\n\n  // Pause console\n  WriteLn('Press Enter key to quit.');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#append-a-text-file-tfilestream","title":"Append a text file - <code>TFileStream</code>","text":"<p>Quite straightforward. Remember to free <code>TFileStream</code> when done.</p> <p>See the snippet below.</p> <ol> <li> <p>Does the file  exist? </p> <ul> <li>If yes, create <code>TFileStream</code> in append mode using <code>TFileStream.Create(filename, fmOpenWrite or fmShareDenyNone)</code>. Line 23.</li> <li>If not, create <code>TFileStream</code> using <code>fmCreate</code> mode to create the new file; <code>TFileStream.Create(filename, fmCreate);</code>. Line 26.</li> </ul> </li> <li> <p>Set position to the end of the file. Line 31.</p> </li> <li>Add new text using <code>fileStream.Write</code>. Line 34.</li> <li>Free <code>TFileStream</code> object. Line 39.</li> </ol> <pre><code>program TFileStreamAppendTextFile;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  filename: string = 'hello-text.txt';\n  fileStream: TFileStream;\n  size: longint;\n  newText: string;\n\nbegin\n\n  // First, does the file exist?\n  if FileExists(fileName) then\n    // If yes, open the file in append mode.\n    fileStream := TFileStream.Create(filename, fmOpenWrite or fmShareDenyNone)\n  else\n    // If not, create a a new file.\n    fileStream := TFileStream.Create(filename, fmCreate);\n\n  // Next, start appending.\n  try\n    // set position at the end of the file\n    fileStream.Seek(0, soFromEnd);\n    // Write text into the file\n    newText := LineEnding + 'A new line!';\n    size := fileStream.Write(newText[1], Length(newText));\n    // Show confirmation\n    Writeln(Format('Appended %s. %d bytes written.', [filename, size]));\n  finally\n    // Free TFileStream object\n    fileStream.Free;\n  end;\n\n  // Pause console\n  WriteLn('Press Enter to quit.');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#append-a-text-file-tstringlist","title":"Append a text file - <code>TStringList</code>","text":"<p>The example below starts by checking if the file exists. If the files doesn't exists, exit program early.</p> <ol> <li>Create a <code>TStringList</code> object if the text file exists. Line 28.</li> <li>Load the existing text into a <code>TStringList</code> object. Line 31.</li> <li>Add new text into the <code>TStringList</code> object. Line 34-35.</li> <li>Save the appended <code>TStringList</code> into the existing file. Line 38.</li> <li>Free resources. Line 43.</li> </ol> <pre><code>program TStringListAppend;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  filename: string = 'hello-text.txt';\n  text: TStringList;\n\nbegin\n\n  // First of all, check if the input file exists.\n  // It not, exit program early.\n  if not FileExists(fileName) then\n  begin\n    WriteLn(Format('File %s does not exist. Press Enter to quit.', [filename]));\n    ReadLn;\n    Exit;\n  end;\n\n  // If file exists, create a TStringList object\n  text := TStringList.Create;\n  try\n    // Read an existing file into TStringList object\n    text.LoadFromFile(filename);\n\n    // Append more text\n    text.Add('New line!');\n    text.Add('New line!');\n\n    // Save the appended TStringList file\n    text.SaveToFile(filename);\n    WriteLn(Format('Saved to %s.', [filename]));\n\n  finally\n    // Free object\n    text.Free;\n  end;\n\n  // Pause Console\n  WriteLn('Press Enter to exit.');\n  ReadLn;\n\nend.\n</code></pre> <p>Warning</p> <p>A <code>TStringList</code> is very easy to use, but I wouldn't recommend it for a log file that gets updated very often. It is slow (because the entire file needs to be rewritten when appending just a single line) and it causes unnecessary writes on a ssd drive.</p> <p>Sebastian Z, Aug 12, 2018 at 20:56</p> <p>Source: https://stackoverflow.com/a/51808874/1179312</p>"},{"location":"docs/core-tasks/file-handling/#read-a-text-file","title":"Read a text file","text":""},{"location":"docs/core-tasks/file-handling/#read-a-text-file-classic","title":"Read a text file - Classic","text":"<p>The snippet below will quit if the file to read is not found.</p> <ol> <li>Assign a file to read into a <code>TextFile</code> variable. Line 24.</li> <li> <p>Within the <code>try..catch</code> do the following:</p> <ul> <li>Open the file for reading. Line 29.</li> <li>Use a while loop to read the file one line at a time. Line 32-36.</li> <li>Use close the file after reading it. Line 39.</li> </ul> </li> </ol> <pre><code>program ClassicReadTextFile;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  filename: string = 'cake-ipsum.txt';\n  textFile: System.TextFile;\n  line: string;\n\nbegin\n\n  // Provide user feedback\n  WriteLn(Format('Reading ''%s''', [filename]));\n  WriteLn('--------------------');\n\n  // Assign filename to a TextFile variable - set the name of the file for reading\n  AssignFile(textFile, filename);\n\n  // Perform the read operation in a try..except block to handle errors gracefully\n  try\n    // Open the file for reading\n    Reset(textFile);\n\n    // Keep reading lines until the end of the file is reached\n    while not EOF(textFile) do\n    begin\n      ReadLn(textFile, line);\n      WriteLn(line);\n    end;\n\n    // Close the file\n    CloseFile(textFile);\n\n  except\n    on E: Exception do\n      WriteLn('File handling error occurred. Details: ', E.Message);\n  end;\n\n  // Pause console\n  WriteLn('--------------------');\n  WriteLn('Press Enter to quit.');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#read-a-text-file-tfilestream","title":"Read a text file - <code>TFileStream</code>","text":"<p>See the snippet below as example.</p> <ol> <li>Create a <code>TFileStream</code> to open a text file for reading. Line 17.</li> <li>Create a <code>StreamReader</code> to read the text file. Line 19. </li> <li>Use the <code>while not TStreamReader.eof</code> to read the text file line by line. Line 23-28.</li> <li><code>Free</code> resources when done.</li> </ol> <p>To gracefully handle error during open and read operations, an outer <code>try..except</code> is in place.</p> <pre><code>program TStreamReaderReadFile;\n\nuses\n  Classes,\n  SysUtils,\n  streamex;\n\nvar\n  reader: TStreamReader;\n  fileStream: TFileStream;\n  line, filename:string;\n  i: integer;\nbegin\n  // filename to read\n  filename:= 'cake-ipsum-.txt';\n  try\n    fileStream := TFileStream.Create(filename, fmOpenRead);\n    try\n      reader := TStreamReader.Create(fileStream);\n      try\n        // Set line counter to 1\n        i := 1;\n        while not reader.EOF do\n        begin\n          line := reader.ReadLine;\n          WriteLn(Format('line %d is: %s', [i, line]));\n          i := i + 1;\n        end;\n      finally\n        reader.Free;\n      end;\n    finally\n      fileStream.Free;\n    end;\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#make-the-tfilestream-and-tstreamreader-code-more-readable","title":"Make the <code>TFileStream</code> and <code>TStreamReader</code> code more readable","text":"<p>The nested <code>try..free</code> blocks in the <code>try..except</code> might be difficult to read. But the code works, right?</p> <p>Here is a better strategy.</p> <ul> <li>The inner <code>try..free</code> blocks are now in separate procedures.</li> <li>The outer <code>try..except</code> can now catch exceptions from procedures.</li> </ul> <pre><code>program TStreamReaderReadFileTidy;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Classes,\n  SysUtils,\n  streamex;\n\n  // Read a stream of string line by line\n  procedure ReadTextFile(const fileStream: TStream);\n  var\n    reader: TStreamReader;\n    i: integer;\n    line: string;\n  begin\n    reader := TStreamReader.Create(fileStream);\n    try\n      // Set line counter to 1\n      i := 1;\n      while not reader.EOF do\n      begin\n        line := reader.ReadLine;\n        WriteLn(Format('line %d: %s', [i, line]));\n        i := i + 1;\n      end;\n    finally\n      reader.Free;\n    end;\n  end;\n\n  // Open a file for reading, and pass the stream to TStreamReader for reading.\n  procedure ReadTextFile(const filename: string);\n  var\n    fileStream: TFileStream;\n  begin\n    fileStream := TFileStream.Create(filename, fmOpenRead);\n    try\n      ReadTextFile(fileStream);\n    finally\n      fileStream.Free;\n    end;\n  end;\n\nvar\n  filename: string;\n\nbegin\n  // filename to read\n  filename := 'cake-ipsum.txt';\n  try\n    ReadTextFile(filename);\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#read-a-text-file-tbufferedfilestream","title":"Read a text file - <code>TBufferedFileStream</code>","text":"<p>The snippet below was adapted from one of Stephen Ball's articles, Faster filestream with TBufferedFilestream.</p> <p>The structure is similar to reading a text file using TFileStream, but here, we use <code>TBufferedFileStream</code>.</p> <ol> <li>In the <code>uses</code> section, add <code>streamex</code> and <code>buffstream</code>. Line 11, 12.</li> <li>Create a <code>TBufferedFileStream</code> to open a text file for reading. Line 30.</li> <li>Create a <code>TStreamReader</code> to read the stream. Line 32.</li> <li> <p>Use the <code>while not TStreamReader.EOF</code> to keep on reading data until there is no more data to read. Line 34-41.</p> <ul> <li>This part sequentially reads through a text file, checking each character one by one. </li> <li>It combines these characters into lines by joining them together until it finds a newline character, which indicates the end of a line. </li> <li>Once a complete line is formed, the snippet prints it out using the <code>WriteLn</code> function.</li> </ul> </li> <li> <p>Finally, <code>Free</code> the <code>TStreamReader</code> first and <code>TBufferedFileStream</code> last. Line 43 and 46.</p> </li> </ol> <p>There is an outer <code>try..except</code> is in place to handle error during open and read operations.</p> <pre><code>program TBufferedFileStreamReadFile;\n\n{$mode objfpc}{$H+}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  streamex,\n  bufstream;\n\nvar\n  fStream: TBufferedFileStream;\n  sReader: TStreamReader;\n  line: string;\n  Count: int64 = 0;\n\nbegin\n\n  if Length(ParamStr(1)) &lt; 1 then\n  begin\n    WriteLn('Please provide a valid input file.');\n    Exit;\n  end;\n\n  try\n    // Create TBufferedFileStream object\n    fStream := TBufferedFileStream.Create(ParamStr(1), fmOpenRead);\n    try\n      sReader := TStreamReader.Create(fStream);\n      try\n        // Keep on reading until there is no more data to read\n        Count := 0;\n        while not sReader.EOF do\n        begin\n          line := sReader.ReadLine;\n          Inc(Count);\n          WriteLn('Line ', IntToStr(Count), ' : ', line);\n        end;\n      finally\n        sReader.Free;\n      end;\n    finally\n      fStream.Free;\n    end;\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#read-a-text-file-tstringlist","title":"Read a text file - <code>TStringList</code>","text":"<p>Here is a snippet.</p> <ol> <li>Instantiate a <code>TStringList</code> object on line 27.</li> <li>Within the <code>try..finally</code> block, load text into a <code>TStringList</code> object on line 32.</li> <li>Use a loop to access the contents of the <code>TStringList</code> on lines 35-36.</li> <li>Release the <code>TStringList</code> object on line 40.</li> <li>Enclose the algorithm in a <code>try..except</code> block to handle exceptions when opening or reading the file.</li> </ol> <pre><code>program TStringListReadTextFile;\n\n{$mode objfpc}{$H+}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nvar\n  filename: string = 'cake-ipsum.txt';\n  stringList: TStringList;\n  line: string;\n\n// Main block\nbegin\n\n  // Provide user feedback\n  WriteLn(Format('Reading ''%s''', [filename]));\n  WriteLn('--------------------');\n\n  // Start try..except\n  try\n    // Create the TSTringList object\n    stringList := TStringList.Create;\n\n    // Start try..finally\n    try\n      // Read the file into a TStringList\n      stringList.LoadFromFile(filename);\n\n      // Use for loop to read the content of the stringList\n      for line in stringList do\n        WriteLn(line);\n\n    finally\n      // Free object from memory\n      stringList.Free;\n    end;\n\n  except\n    on E: Exception do\n      WriteLn('File handling error occurred. Details: ', E.Message);\n  end; // end of try..except\n\n  // Pause console\n  WriteLn('--------------------');\n  WriteLn('Press Enter key to quit.');\n  ReadLn;\n\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#count-lines-in-a-text-file","title":"Count lines in a text file","text":""},{"location":"docs/core-tasks/file-handling/#count-lines-classic","title":"Count lines - Classic","text":"<p>The snippet below will quit if the file to read is not found.</p> <ol> <li>Assign a file to read into a <code>TextFile</code> variable. Line 37.</li> <li>Open the file for reading. Line 42.</li> <li>Assign a buffer to reduce disk IO. Line 44.</li> <li> <p>Within the <code>try..catch</code> do the following:</p> <ul> <li>Use a while loop to read the file one line at a time. Line 47-51.</li> <li>Use close the file after reading it. Line 54.</li> </ul> </li> </ol> <pre><code>program ClassicCountLine;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils;\n\nconst\n  BUFFER_SIZE = 131072;\n\nvar\n  filename: string;\n  textFile: System.TextFile;\n  buffer: array [0..BUFFER_SIZE - 1] of char;\n  line: string;\n  total: int64;\n\nbegin\n  // Get filename\n  filename := ParamStr(1);\n\n  // Do we have a valid input file?\n  if not FileExists(filename) then\n  begin\n    WriteLn('Please specify a valid input file.');\n    Exit;\n  end;\n\n  // Reset total\n  total := 0;\n\n  // Assign filename to a TextFile variable - set the name of the file for reading\n  AssignFile(textFile, filename);\n\n  // Perform the read operation in a try..except block to handle errors gracefully\n  try\n    // Open the file for reading\n    Reset(textFile);\n    // Set buffer\n    SetTextBuf(textFile, buffer);\n\n    // Keep reading lines until the end of the file is reached\n    while not EOF(textFile) do\n    begin\n      ReadLn(textFile, line);\n      total := total + 1;\n    end;\n\n    // Close the file\n    CloseFile(textFile);\n\n    // User feedback\n    WriteLn('Total number of lines: ', IntToStr(total));\n\n  except\n    on E: Exception do\n      WriteLn('File handling error occurred. Details: ', E.Message);\n  end;\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#count-lines-buffered-tfilestream","title":"Count lines - Buffered <code>TFileStream</code>","text":"<p>The snippet below count the occurances of <code>#10</code> in a file using buffered <code>TFileStream</code>.</p> <ol> <li>In the <code>uses</code> section, add <code>bufstream</code>. Line 11.</li> <li>Specify a buffer. Line 20.</li> <li>Create a <code>TFileStream</code> to open a text file for reading. Line 40.</li> <li>Do the line counting inside the <code>repeat..until bytesRead = 0</code> loop. Line 42-52.</li> </ol> <ul> <li>Read a chunk of bytes into a buffer</li> <li>Count number of lines in the chunk and repeat until no more bytes to read. </li> </ul> <ol> <li><code>Free</code> resources when done. Line 54.</li> </ol> <pre><code>program TBufferedFileStreamCount;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  streamex;\n\nconst\n  BufferSize = 131072; // Adjust buffer size as needed\n\nvar\n  filename: string;\n  fStream: TFileStream;\n  total: int64;\n  buffer: array[0..BufferSize - 1] of char;\n  bytesRead: integer;\n  i: integer;\n\nbegin\n  // Get filename\n  filename := ParamStr(1);\n\n  // Do we have a valid input file?\n  if not FileExists(filename) then\n  begin\n    WriteLn('Please specify a valid input file.');\n    Exit;\n  end;\n\n  // Reset total\n  total := 0;\n\n  // try - except block start\n  try\n    fStream := TFileStream.Create(filename, fmOpenRead or fmShareDenyWrite);\n    try\n      repeat\n        bytesRead := fStream.Read(buffer[0], BufferSize);\n        i := 0;\n        while i &lt; bytesRead do\n        begin\n          // Count lines in the buffer\n          if buffer[i] = #10 then\n            total := total + 1;\n          Inc(i);\n        end;\n      until bytesRead = 0;\n    finally\n      fStream.Free;\n    end;\n\n    // User feedback\n    WriteLn('Total lines:', IntToStr(total));\n\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end; // try - except block ends\nend.\n</code></pre>"},{"location":"docs/core-tasks/file-handling/#count-lines-tstreamreader","title":"Count lines - <code>TStreamReader</code>","text":"<p>The structure is similar to reading a text file using TFileStream.</p> <p>Here is the snippet that counts the number of line by parsing the stream line by line.</p> <ol> <li>In the <code>uses</code> section, add <code>streamex</code>. Line 11.</li> <li>Create a <code>TFileStream</code> to open a text file for reading. Line 36.</li> <li>Create a <code>TStreamReader</code> to read line by line. Line 38.</li> <li>Do the line counting inside the <code>while not fReader.EOF do</code> loop. Line 40-48.</li> <li><code>Free</code> resources when done. Line 50 and 53.</li> </ol> <pre><code>program TStreamReaderCount;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  streamex;\n\nvar\n  filename: string;\n  fStream: TFileStream;\n  fReader: TStreamReader;\n  total: int64;\n  line: string;\n\nbegin\n  // Get filename\n  filename := ParamStr(1);\n\n  // Do we have a valid input file?\n  if not FileExists(filename) then\n  begin\n    WriteLn('Please specify a valid input file.');\n    Exit;\n  end;\n\n  // Reset total\n  total := 0;\n\n  // try - except block start\n  try\n    fStream := TFileStream.Create(filename, fmOpenRead or fmShareDenyWrite);\n    try\n      fReader := TStreamReader.Create(fStream, 131072, False);\n      try\n        while not fReader.EOF do\n        begin\n          // Read line\n          line := fReader.ReadLine;\n          // Process line here if needed\n          // ....\n          // Increase counter\n          total := total + 1;\n        end;\n      finally\n        fReader.Free;\n      end;\n    finally\n      fStream.Free;\n    end;\n\n    // User feedback\n    WriteLn('Total line is: ', IntToStr(total));\n\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end; // try - except block ends\nend.\n</code></pre>"},{"location":"docs/core-tasks/funcs-procs/","title":"Functions and Procedure","text":""},{"location":"docs/core-tasks/funcs-procs/#can-a-routine-receive-a-pointer-to-the-passed-variable","title":"Can a routine receive a pointer to the passed variable?","text":"<p>Yes. Use the <code>var</code> parameter modifier. </p> <p>The procedure gets a pointer to the variable that was passed, and uses this pointer to access the variable\u2019s value. From this, it follows that any changes made to the parameter, will propagate back to the calling block.</p> <p>FPC Language Reference 14.4.2.</p> <p>Here is an example.</p> <pre><code>program ParamModifierVar;\n\nuses\n  sysutils;\n\nprocedure AddFour(var input: integer);\nbegin\n  input := input + 4; // this line modifies the value of passed variable\nend;\n\nvar\n  myNumber: Integer = 10;\n\nbegin\n  WriteLn('myNumber is ... ', myNumber); // the value will be 10\n  AddFour(myNumber);                     // call the procedure\n  WriteLn('myNumber is ... ', myNumber); // the value will be 14\n  ReadLn;\nend. \n</code></pre>"},{"location":"docs/core-tasks/funcs-procs/#how-to-ensure-a-passed-parameter-wont-be-changed-inside-a-routine","title":"How to ensure a passed parameter won't be changed inside a routine?","text":"<ol> <li> <p>Use <code>const</code>.</p> <ul> <li>Note. The compiler decides if the parameter will be passed by value or by reference.</li> </ul> </li> <li> <p>Alternatively, use <code>constref</code>.</p> <ul> <li>Note. This parameter is the same as <code>const</code>. Plus, it also tells the compiler that the value should be passed by reference, like a <code>var</code> parameter.</li> </ul> </li> </ol> <p>Here is an example.</p> <pre><code>program ParamModifierConst;\n\nfunction CalcAreaCircle(const radius: Real): Real;\nbegin\n\n  // Argument 'radius' has a const modifier.\n  // Hence, it is not possible to re-assign it another value.\n  // Uncommenting the following line may lead to a compile error.\n  // radius:=radius*2;\n  Result:= Pi * radius * radius;\nend;\n\nvar\n  myRadius:Real = 3.0;\n  area:Real = 0.0;\n\nbegin\n  area := CalcAreaCircle(myRadius);\n  WriteLn('The radius is ', myRadius:0:2);\n  WriteLn('The area of the circle is ', area:0:2);\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/immutability/","title":"Immutability","text":""},{"location":"docs/core-tasks/immutability/#how-do-i-make-const-variables-constant","title":"How do I make <code>const</code> variables constant?","text":"<p>Add a global directive <code>{$J-}</code> to your main pascal file.</p>"},{"location":"docs/core-tasks/immutability/#why-is-const-section-writeable-in-by-default","title":"Why is <code>const</code> section writeable in by default?","text":"<p>In Turbo Pascal 7.0, you could only assign values in the <code>const</code> section, not in <code>var</code> section.</p> <p>As the official docs mentions, by default <code>const</code> is writeable (that is <code>{$J+}</code>) to keep Turbo Pascal compatibility.</p> <p>It's a relic of old Delphi and Object Pascal and thus <code>{$J+}</code> is the default to allow old programs to compile, but it isn't required anymore</p> <p>chsh -s /usr/bin/pwsh \u2014 13/12/2023 12:09</p> <p>Consider the following program. By the default <code>{$J+}</code>, you can change the gravity of the Earth, with the gravity of the Moon!</p> <pre><code>program Immutability;\n\n{$mode objfpc}{$H+}\n\nconst\n  gravityEarth:Real = 9.81;\n\nbegin\n  gravityEarth := 1.625; // Look, we are on the moon.\n  WriteLn('The gravity on the Earth is ', gravityEarth:0:2);\nend.\n</code></pre> <p>To make <code>const</code> variables behaving like <code>const</code> variables in modern programming languages, use <code>{$J-}</code></p> <pre><code>program Immutability;\n\n{$mode objfpc}{$H+}{$J-}\n\nconst\n  gravityEarth:Real = 9.81;\n\nbegin\n  // With {$J-}, the following line will not compile\n  // gravityEarth := 1.625;\n  WriteLn('The gravity on the Earth is ', gravityEarth:0:2);\nend.\n</code></pre>"},{"location":"docs/core-tasks/lazarus-ide/","title":"Post-Install","text":""},{"location":"docs/core-tasks/lazarus-ide/#change-the-header-style-of-the-panels","title":"Change the header style of the panels","text":"<ol> <li>Go to Tool -&gt; Options ....</li> <li>Click on Docking/Achordocking item on the left side and set a Header Style (see the screenshot below).</li> </ol> <p>Hit the Apply button to see how the Header Style looks on the IDE.</p> <p>Hit the OK button to save the settings.</p>"},{"location":"docs/core-tasks/lazarus-ide/#prevent-the-caret-from-moving-past-end-of-line","title":"Prevent the caret from moving past end of line","text":"<ol> <li>Go to Tools -&gt; Options ... -&gt; Editor (left hand side)</li> <li>Uncheck Allow caret to move past the end of line.</li> </ol>"},{"location":"docs/core-tasks/lazarus-ide/#show-hint-and-completion-boxes-sooner","title":"Show hint and completion boxes sooner","text":"<ol> <li>Go to Tools -&gt; Options ... -&gt; Editor (left hand side)</li> <li>Set shorter values for <ul> <li>Delay for Delay for completion box </li> <li>Delay for hints.</li> </ul> </li> </ol>"},{"location":"docs/core-tasks/lazarus-ide/#format-code","title":"Format code","text":"<p>Hit Ctrl+D on the code window.</p>"},{"location":"docs/core-tasks/lazarus-ide/#setup-a-debugger-in-lazarus","title":"Setup a debugger in Lazarus","text":"<p>Citing from https://wiki.lazarus.freepascal.org/DWARF</p> <p>For GDB \"DWARFv2 with sets\" is the best option. Testing shows that, if using other (v3 and up) DWARF (as generated by FPC) then GDB is more likely to crash.</p> <p>debugger may not be able to distinguish between PChar and AnsiString All identifiers (e.g. field-names) returned by the debugger are upper-cased ... other diffs</p> <p>DWARF 2 (the one without \"with sets\") does not display sets \"type TMySet = set of (v1,v2,v3)\" correctly.</p>"},{"location":"docs/core-tasks/lazarus-ide/#compile-and-run","title":"Compile and run","text":"<p>You have choices. Pick one.</p> <ol> <li> <p>Use F9 to compile (as necessary) and run with the debugger. The debugger notifies of any exceptions in a pop-up.</p> </li> <li> <p>Use Shift+Ctrl+F9 to compile (as necessary) and run without the debugger.</p> </li> <li> <p>Use Ctrl+F9 if you'd like to compile without running it in the IDE. You will run the executable manually via a CLI.</p> </li> </ol>"},{"location":"docs/core-tasks/lists/","title":"Building and Processing Lists","text":""},{"location":"docs/core-tasks/lists/#what-is-a-list","title":"What is a list?","text":"<p>Think of it as a higher-level construct than a static or dynamic array.</p> <p>Higher-level constructs:</p> <ul> <li>Abstract away lower-level details, allowing developers to work with more generalised and easier-to-use interfaces.</li> <li>Reduce the amount of manual code a developer needs to write.</li> </ul>"},{"location":"docs/core-tasks/lists/#why-do-we-want-to-use-lists","title":"Why do we want to use lists?","text":"<p>Well, conveniences.</p> <ul> <li>You may need to change the length of your lists often at run-time.</li> <li>You may need your lists for more than just storing and retreival (sort and search).</li> <li>Etc.</li> </ul> <p>Here is a brief comparison between <code>array of string</code> and <code>TStringList</code> (https://wiki.freepascal.org/TStringList-TStrings_Tutorial).</p> Operation array of string TStringList Variable declaration <code>stringList: array of string;</code> <code>stringList: TStringList;</code> Initialization implicit constructor <code>stringList := TStringList.Create;</code> Set size <code>SetLength(StringList, X);</code> <code>stringList.Size := n;</code> Get size <code>n := Length(stringList);</code> <code>n := stringList.Count;</code> Add item <code>SetLength(stringList, Length(stringList) + 1); stringList[Length(stringList) - 1] := x;</code> <code>stringList.Add(x);</code> Delete item <code>for i := index to Length(stringList) - 2 do stringList[i] := stringList[i + 1]; SetLength(stringList, Length(stringList) - 1);</code> <code>stringList.Delete(index);</code> Remove all items <code>SetLength(stringList, 0);</code> <code>stringList.Clear;</code> Finalisation <code>implicit destructor</code> <code>stringList.Free;</code>"},{"location":"docs/core-tasks/lists/#how-can-i-make-a-list-of-string-and-sort-it","title":"How can I make a list of string and sort it?","text":"<p>Use <code>TStringList</code>. See the recipe below.</p> <ol> <li>Create a var of  <code>TStringList</code>. Line 9.</li> <li>Create the <code>TStringList</code>. Line 16.</li> <li>Append items.</li> <li><code>Sort</code> it. Line 33.</li> <li>Finally, <code>Free</code> the <code>TStringList</code>. Line 63.</li> </ol> <pre><code>program StringList;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Classes;\n\nvar\n  myStringList: TStringList;\n  stringIndex: integer;\n  i: integer;\n\nbegin\n\n  // Allocate a memory for this list\n  myStringList := TStringList.Create;\n  try\n    // Add items into the list\n    myStringList.Add('cc');\n    myStringList.Add('aa');\n    myStringList.Add('bb');\n\n    // Insert at index-n, 0-indexed\n    myStringList.Insert(0, 'zero');\n\n    // Remove item at index-n\n    myStringList.Delete(0);\n\n    // Append an array of string\n    myStringList.AddStrings(['yy', 'zz - last one']);\n\n    // Sort list\n    myStringList.Sort;\n\n    // Find an exact match string, case insensitive, un-sorted\n    // A sorted TStringlist has myStringList.Sorted:=True;\n    stringIndex := myStringList.IndexOf('yy');\n    if stringIndex &gt;= 0 then\n    begin\n      WriteLn('Found yy at index: ', stringIndex);\n    end;\n\n    // Iteration for partial string mathching\n    for i := 0 to myStringList.Count - 1 do\n    begin\n      if Pos('last one', myStringList[i]) &gt; 0 then\n      begin\n        // String found at index \"i\"\n        WriteLn('Found ''last one'' at index: ', i);\n        Break; // Exit the loop if a match is found\n      end;\n    end;\n\n    // Iterate through the list\n    for i := 0 to myStringList.Count - 1 do\n      Writeln(myStringList[i]);\n\n    // Clear the list, size of the list will be 0\n    myStringList.Clear;\n\n  finally\n    // Free the list\n    myStringList.Free;\n  end;\n\n  // Pause Console\n  Readln;\n\nend.\n</code></pre>"},{"location":"docs/core-tasks/lists/#is-there-a-tintegerlist","title":"Is there a <code>TIntegerList</code>?","text":"<p>No. Make your own type.</p>"},{"location":"docs/core-tasks/lists/#using-genericscollections-unit","title":"Using <code>Generics.Collections</code> unit","text":""},{"location":"docs/core-tasks/lists/#how-do-i-make-a-list-of-integer-and-sort-it","title":"How do I make a list of integer and sort it?","text":"<p>Here is an example.</p> <ol> <li>Use <code>Generics.Collections.TList</code> to create <code>TIntegerList</code>.</li> <li>Declare type <code>TIntegerList = specialize TList&lt;integer&gt;;</code>. Line 11.</li> <li>Create a new variable using the new list type - line 14.</li> <li>In the main <code>begin..end</code> block, allocate memory for the list. Line 19.</li> <li>Populate the list. Line 22-24.</li> <li>Call <code>Sort</code>. Line 30</li> <li>Lastly, free it. Line 44.</li> </ol> <pre><code>program SimpleIntegerList;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Math,\n  Generics.Defaults,\n  Generics.Collections;\n\ntype\n  TIntegerList = specialize TList&lt;integer&gt;;\n\nvar\n  myIntList: TIntegerList;\n  i: integer;\n\nbegin\n  // Create a new generic list\n  myIntList := TIntegerList.Create;\n  try\n    // Add some elements to the list, use Add or AddRange (append)\n    myIntList.Add(0);\n    myIntList.Add(1);\n    myIntList.AddRange([9, 8, 7, 6, 5]);\n\n    // Access the n-th element, 0-indexed\n    WriteLn('The 3rd item is: ', myIntList[2]);\n\n    // Sorting it ascending\n    myIntList.Sort;\n\n    // Iterate through the list\n    for i := 0 to myIntList.Count - 1 do\n      Writeln(myIntList[i]);\n\n    // Get the mean\n    WriteLn('The mean is: ', Math.Mean(myIntList.ToArray): 0: 2);\n\n    // Empty the list\n    myIntList.Clear;\n\n  finally\n    // Free the memory used by the list\n    myIntList.Free;\n  end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/lists/#how-to-create-a-custom-comparer-for-tlistt-list","title":"How to create a custom comparer for <code>TList&lt;T&gt;</code> list?","text":"<p>Here is an example of sorting <code>TList&lt;TStudent&gt;</code> by name and by age.</p> <ul> <li>Set a custom comparer for <code>TList&lt;TStudent&gt;</code>. See line 36.</li> <li>Define comparison functions. See line 39-49.</li> <li>Lastly, call the Sort using the comparison function. See line 75 and 83.</li> </ul> <pre><code>program TListCustomComparison;\n\n{$mode objfpc}{$H+}{$J-}{$modeSwitch advancedRecords}\n\nuses\n  Generics.Defaults,\n  Generics.Collections,\n  SysUtils,\n  Math;\n\ntype\n  TStudent = record\n  var\n    Name: string;\n    age: byte;\n    location: string;\n  public\n    constructor Create(newName: string; newAge: byte; newLocation: string);\n    function ToString: string;\n  end;\n\n  constructor TStudent.Create(newName: string; newAge: byte; newLocation: string);\n  begin\n    self.Name := newName;\n    self.age := newAge;\n    self.location := newLocation;\n  end;\n\n  function TStudent.ToString: string;\n  begin\n    Result := 'Row data: ' + self.Name + ' ' + IntToStr(self.age) + ' ' + self.location;\n  end;\n\ntype\n  TStudentList = specialize TList&lt;TStudent&gt;;\n  TStudentListComparer = specialize TComparer&lt;TStudent&gt;;\n\n\n  // Custom comparison function for sorting by name - ascending\n  function CompareName(constref LeftItem, RightItem: TStudent): integer;\n  begin\n    Result := CompareStr(LeftItem.Name, RightItem.Name);\n  end;\n\n  // Custom comparison function for sorting by age - ascending\n  function CompareAge(constref LeftItem, RightItem: TStudent): integer;\n  begin\n    Result := CompareValue(LeftItem.age, RightItem.age);\n  end;\n\nvar\n  studentList: TStudentList;\n  i: integer;\n\nbegin\n  // Create a new generic list\n  studentList := TStudentList.Create;\n  try\n    // Add some elements to the list by using Add or AddRange\n    studentList.Add(TStudent.Create('Asher Mo', 10, 'Sydney'));\n    studentList.AddRange(\n      [TStudent.Create('Kezia Mo', 10, 'Sydney'),\n      TStudent.Create('Irene Mo', 11, 'Sydney'),\n      TStudent.Create('Jonah Mo', 12, 'Sydney'),\n      TStudent.Create('Bob Yell', 13, 'Melbourne'),\n      TStudent.Create('Luke Earthwalker', 9, 'Canberra')]\n      );\n\n    // Printing list on console\n    WriteLn('-- Original list ------');\n    for i := 0 to studentList.Count - 1 do\n      Writeln(studentList[i].ToString);\n\n    // Sort by TStudent.name\n    studentList.Sort(TStudentListComparer.construct(@CompareName));\n\n    // Iterate through the list\n    WriteLn('-- Sorted by name ------');\n    for i := 0 to studentList.Count - 1 do\n      Writeln(studentList[i].ToString);\n\n    // Sort by TStudent.age\n    studentList.Sort(TStudentListComparer.construct(@CompareAge));\n\n    // Iterate through the list\n    WriteLn('-- Sorted by age ------');\n    for i := 0 to studentList.Count - 1 do\n      Writeln(studentList[i].ToString);\n\n  finally\n    // Free the memory used by the list\n    studentList.Free;\n\n  end;\n\n  // Pausing console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/lists/#using-fgl-unit","title":"Using <code>fgl</code> unit","text":""},{"location":"docs/core-tasks/lists/#how-do-i-build-a-list-of-integer-using-fgl-and-sort-it","title":"How do I build a list of integer using <code>fgl</code> and sort it?","text":"<p>See the snippet below.</p> <ol> <li>In the uses section, add <code>fgl</code>. Line 6.</li> <li>Create a list type using <code>specialize TFPGList&lt;integer&gt;s</code>. Line 10.</li> <li>Create a integer comparer function for sorting. Line 13-16.</li> <li>Create a new var using the new type. Line 23.</li> <li>Add items using <code>Add()</code>. Line 26.</li> <li>Sort list using <code>Sort(@TCompareFunc)</code>. Line 35.</li> <li>Release the memory using <code>Free()</code>. Line Line 43.</li> </ol> <pre><code>program FGLIntegerList;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  fgl,\n  Math;\n\ntype\n  TIntegerList = specialize TFPGList&lt;integer&gt;;\n\n  // Comparer function for sorting list\n  function CompareInt(const left, right: integer): integer;\n  begin\n    Result := CompareValue(left, right);\n  end;\n\nvar\n  myIntList: TIntegerList;\n  i: integer;\n\nbegin\n  myIntList := TIntegerList.Create;\n  try\n    // Adding integers to the list\n    myIntList.Add(444);\n    myIntList.Add(222);\n    myIntList.Add(333);\n\n    // Printing list\n    Writeln('-- Original list ----------');\n    for i := 0 to myIntList.Count - 1 do WriteLn(myIntList[i]);\n\n    // Sorting\n    myIntList.Sort(@CompareInt);\n\n    // Printing list\n    Writeln('-- Sorted list ------------');\n    for i := 0 to myIntList.Count - 1 do WriteLn(myIntList[i]);\n\n  finally\n    // Freeing the list when done\n    myIntList.Free;\n  end;\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/lists/#how-do-you-append-two-tfpglistinteger-lists","title":"How do you append two <code>TFPGList&lt;Integer&gt;</code> lists?","text":"<p>Use <code>AddList()</code>. Here is an example.</p> <pre><code>program AppendFPGList;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  fgl,\n  Math;\n\ntype\n  TIntegerList = specialize TFPGList&lt;integer&gt;;\n\nvar\n  myIntList1, myIntList2: TIntegerList;\n  i: integer;\n\nbegin\n  myIntList1 := TIntegerList.Create;\n  myIntList2 := TIntegerList.Create;\n\n  // Adding integers to the lists\n  myIntList1.Add(1);\n  myIntList1.Add(2);\n  myIntList2.Add(3);\n  myIntList2.Add(4);\n\n  myIntList1.AddList(myIntList2);\n\n  // Printing the first list\n  WriteLn('The content of myIntList1 is now:');\n  for i := 0 to myIntList1.Count - 1 do\n  begin\n    WriteLn(myIntList1[i]);\n  end;\n\n  // Freeing the lists when done\n  myIntList2.Free;\n  myIntList1.Free;\n\n  ReadLn;\nend. \n</code></pre>"},{"location":"docs/core-tasks/lists/#when-building-a-list-which-unit-is-preferable-to-use-fgl-or-genericscollections","title":"When building a list, which unit is preferable to use: <code>fgl</code> or <code>Generics.Collections</code>?","text":"<p>Consider this answer from PascalDragon, March 22, 2020, 12:55 pm.</p> <p>Just to clear these up as well:</p> <ul> <li><code>fgl</code> is a unit of generic types distributed with FPC that is smaller than <code>Generics.Collections</code> and has some restrictions and the performance might be worse; however it can be more easily be used where size of the binary is a concern</li> <li><code>Generics.Collections</code> is the name of the Delphi-compatible generic collection types (list, dictionary, etc.) which is rather powerful and performant; this is part of FPC 3.2.0 and newer ...</li> </ul> <p>Source: https://forum.lazarus.freepascal.org/index.php?topic=48988.0</p>"},{"location":"docs/core-tasks/lists/#external-usinglgenerics-unit","title":"External - Using<code>LGenerics</code> unit","text":"<p>Before trying out snippet in this section, make sure you have installed <code>LGenerics</code> via the <code>Online Package Manager (OPM)</code> in Lazarus IDE.</p>"},{"location":"docs/core-tasks/lists/#creating-a-list-of-integer-using-lgenerics","title":"Creating a list of integer using <code>LGenerics</code>","text":"<ol> <li>In <code>uses</code> add <code>lgVector</code>.</li> <li>Create a new type based on <code>TGVector&lt;T&gt;</code>.</li> <li>Declare a <code>var</code> to use this new list type.</li> <li>Create a new instance of the new list for use. The constructor takes an array. See line 18.</li> <li>Lastly, don't forget to <code>Free</code> your memory as shown in line 33.</li> </ol> <pre><code>program LGIntegerList;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Classes,\n  lgVector;\n\ntype\n  TIntVector = specialize TGVector&lt;integer&gt;;\n\nvar\n  myInteger: TIntVector;\n  i: integer;\n\nbegin\n  // Creating a new instance\n  myInteger := TIntVector.Create([11, 33, 22, 55, 44, 66]);\n  try\n    // Adding numbers\n    myInteger.Add(1);\n    myInteger.Add(10);\n    myInteger.Add(100);\n\n    // Printing list\n    for i := 0 to myInteger.Count - 1 do\n    begin\n      WriteLn(myInteger[i]);\n    end;\n\n  finally\n    // Releasing resource\n    myInteger.Free;\n  end;\n\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/lists/#can-i-sort-a-tgvectorinteger-list","title":"Can I sort a <code>TGVector&lt;integer&gt;</code> list?","text":"<p>Easy. Follow the step below if your integer list is <code>TGVector&lt;integer&gt;</code>.</p> <ol> <li>Add <code>lgUtils</code> to the <code>uses</code> section.</li> <li>Add <code>TIntOrdHelper = specialize TGOrdVectorHelper&lt;integer&gt;;</code> in the <code>type</code> section.</li> </ol> <p>That's it. </p> <p>To sort, use the <code>TIntOrdHelper.Sort()</code> or <code>TIntOrdHelper.RadixSort()</code> methods.</p> <p>See the following example.</p> <pre><code>program LGIntegerListSort;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Classes,\n  lgVector,\n  lgUtils;\n\ntype\n  TIntVector = specialize TGVector&lt;integer&gt;;\n  TIntOrdHelper = specialize TGOrdVectorHelper&lt;integer&gt;;\n\nvar\n  myInteger: TIntVector;\n  i: integer;\n\nbegin\n  // Creating a new instance of TGVector&lt;integer&gt;\n  myInteger := TIntVector.Create([11, 33, 22, 55, 44, 66]);\n  try\n    // Adding numbers\n    myInteger.Add(1);\n    myInteger.Add(10);\n    myInteger.Add(100);\n\n    // Printing list\n    WriteLn('--original');\n    for i := 0 to myInteger.Count - 1 do\n    begin\n      WriteLn(myInteger[i]);\n    end;\n\n    // Sorting descending using .Sort()\n    TIntOrdHelper.Sort(myInteger, TSortOrder.soDesc);\n\n    // Printing sorted list\n    WriteLn('--sorted desc');\n    for i := 0 to myInteger.Count - 1 do\n    begin\n      WriteLn(myInteger[i]);\n    end;\n\n    // Sorting ascending using .RadixSort()\n    TIntOrdHelper.RadixSort(myInteger, TSortOrder.soAsc);\n\n    // Printing sorted list\n    WriteLn('--sorted asc');\n    for i := 0 to myInteger.Count - 1 do\n    begin\n      WriteLn(myInteger[i]);\n    end;\n\n  finally\n    myInteger.Free;\n  end;\n\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/loops/","title":"Loops","text":""},{"location":"docs/core-tasks/loops/#what-are-the-loops-in-free-pascal","title":"What are the loops in Free Pascal?","text":"<ol> <li>For Loop.</li> </ol> <pre><code>for counter := initial_value to final_value do\nbegin\n  // code to run\nend;\n</code></pre> <p>Remarks</p> <ul> <li>Free Pascal calculates the upper bound once before setting the counter variable.</li> <li>You can't change the value of a loop variable inside the loop.</li> <li>The loop variable's value is unclear after the loop ends or if the loop doesn't run. If the loop stops early due to an exception, break, or goto statement, the variable keeps its last value.</li> <li>If you're using nested procedures, the loop variable must be a local variable. Using a loop variable outside the nested procedure will cause a compiler error, but using a global variable is allowed.</li> </ul> <p>Adapted from https://www.freepascal.org/docs-html/ref/refsu58.html#x168-19200013.2.4</p> <ol> <li>For-In Loop.</li> </ol> <pre><code>for item in collection do\nbegin\n  // code to run\nend;\n</code></pre> <ol> <li>While Loop.</li> </ol> <pre><code>while condition do\nbegin\n  // code to run\nend;\n</code></pre> <ol> <li>Repeat Until Loop.</li> </ol> <pre><code>repeat\n  // code to run\nuntil condition;\n</code></pre> <ol> <li>Nested Loops.</li> </ol> <pre><code>// Basically, a loop inside another loop\n// A simple example (among many others)\n\nfor counter_a := initial_value_a to final_value_a do\n  for counter_b := initial_value_b to final_value_b do\n  begin\n    // code to run\n  end;\n</code></pre>"},{"location":"docs/core-tasks/loops/#examples","title":"Examples","text":"<p>The snippet below demonstrates different types of loops in Free Pascal.</p> <pre><code>program Loops;\n\n  {$mode objfpc}{$H+}{$J-}\n\nvar\n  intArray: array [0..2] of integer = (10, 20, 30);\n  strArray: array of string = ('Apple', 'Banana', 'Cirtus');\n  i, j: integer; // vars for iteration\n  item: string; // var for iterating a collection of string\n  c: char = char(0);\nbegin\n\n  // 1a. For Loop -------------------------------\n  for i := 0 to 2 do\n  begin\n    WriteLn('For Loop: Value of i is ', intArray[i]);\n  end;\n\n  WriteLn('--------------------');\n\n  // 1b. For Loop using low &amp; high --------------\n  for i := low(intArray) to high(intArray) do\n  begin\n    WriteLn('For Loop with low &amp; high: ', intArray[i]);\n  end;\n\n  WriteLn('--------------------');\n\n  //2a. For-In Loop -----------------------------\n  for i in intArray do\n  begin\n    WriteLn('For-In Loop - integer: ', i);\n  end;\n\n  //2b. For-In Loop -----------------------------\n  for item in strArray do\n  begin\n    WriteLn('For-In Loop - string: ', item);\n  end;\n\n  WriteLn('--------------------');\n\n  // 3. While Loop ------------------------------\n  j := 0;\n  while j &lt;= 5 do\n  begin\n    WriteLn('While Loop from 0 until 5: ', j);\n    Inc(j);\n  end;\n\n  WriteLn('--------------------');\n\n  // 4. Repeat Until Loop -----------------------\n  repeat\n    Write('Repeat Until Loop: What is the next letter after ''a''? ');\n    ReadLn(c);\n  until c = 'b';\n  WriteLn('Yes, b is the correct answer');\n\n  WriteLn('--------------------');\n\n  // 5. An example of a Nested Loops\n  for item in strArray do\n    for i := low(intArray) to high(intArray) do\n    begin\n      Writeln('Nested Loops: For ', item, ', You can buy in pack of ', intArray[i]);\n    end;\n\n  WriteLn('--------------------');\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre> <p>If you run the program, the output would be as follows (with <code>b</code> to answer the question in the Repeat Until loop).</p> <pre><code>For Loop: Value of i is 10\nFor Loop: Value of i is 20\nFor Loop: Value of i is 30\n--------------------\nFor Loop with low &amp; high: 10\nFor Loop with low &amp; high: 20\nFor Loop with low &amp; high: 30\n--------------------\nFor-In Loop - integer: 10\nFor-In Loop - integer: 20\nFor-In Loop - integer: 30\nFor-In Loop - string: Apple\nFor-In Loop - string: Banana\nFor-In Loop - string: Cirtus\n--------------------\nWhile Loop from 0 until 5: 0\nWhile Loop from 0 until 5: 1\nWhile Loop from 0 until 5: 2\nWhile Loop from 0 until 5: 3\nWhile Loop from 0 until 5: 4\nWhile Loop from 0 until 5: 5\n--------------------\nRepeat Until Loop: What is the next letter after 'a'? b\nYes, b is the correct answer\n--------------------\nNested Loops: For Apple, You can buy in pack of 10\nNested Loops: For Apple, You can buy in pack of 20\nNested Loops: For Apple, You can buy in pack of 30\nNested Loops: For Banana, You can buy in pack of 10\nNested Loops: For Banana, You can buy in pack of 20\nNested Loops: For Banana, You can buy in pack of 30\nNested Loops: For Cirtus, You can buy in pack of 10\nNested Loops: For Cirtus, You can buy in pack of 20\nNested Loops: For Cirtus, You can buy in pack of 30\n--------------------\n</code></pre>"},{"location":"docs/core-tasks/loops/#what-are-best-use-cases-for-each-loop","title":"What are best use cases for each loop?","text":""},{"location":"docs/core-tasks/loops/#for-loop","title":"For Loop","text":"<p>Best for:</p> <ul> <li>Iterating a block of code over a fixed number of times.</li> <li>Keeping track of loop counter.</li> </ul> <p>For examples:</p> <ul> <li>Reading and processing all elements in a fixed-size array.</li> <li>Copying N files from one location to another.</li> </ul>"},{"location":"docs/core-tasks/loops/#for-in-loop","title":"For-In Loop","text":"<p>Best for:</p> <ul> <li>Looping through collections, arrays, or enumerable types without manual indexing.</li> <li>Iterating tasks without a loop counter.</li> </ul> <p>Examples:</p> <ul> <li>Printing all names in a list of people.</li> <li>Checking if an object exists in an collection.</li> </ul>"},{"location":"docs/core-tasks/loops/#while-loop","title":"While Loop","text":"<p>Best for:</p> <ul> <li>Repeating a block of code as long as a condition remains true, without knowing the exact number of repetitions in advance.</li> </ul> <p>Examples:</p> <ul> <li>Reading user input until they enter a specific value.</li> <li>Reading command line options until no more options are found.</li> </ul>"},{"location":"docs/core-tasks/loops/#repeat-until-loop","title":"Repeat Until Loop","text":"<p>Best for:</p> <ul> <li>Like While Loop, but ensuring execution of a block of code at least once, even if the initial condition is false.</li> </ul> <p>Examples:</p> <ul> <li>A login system that repeatedly requests credentials until authentication is successful.</li> <li>Reading a CSV file while ensuring that specific columns are present before processing its contents.</li> </ul>"},{"location":"docs/core-tasks/loops/#nested-loops","title":"Nested Loops","text":"<p>Best for:</p> <ul> <li>Working with N-dimensional arrays or collections.</li> <li>Generating patterns based on multiple arrays.</li> </ul> <p>Examples:</p> <ul> <li>Populating a 3x3 array of integer.</li> <li>Finding possible combination of words between N array of strings.</li> </ul>"},{"location":"docs/core-tasks/numbers/","title":"Numbers","text":"<p>Random generator</p> <p>FPC 3.2.2 uses a Mersenne twister generate random numbers.</p> <p>As for trunk (2023-01-01) FPC uses Xoshiro128</p> <p>Reason? Xoshiro128 is faster, has a much smaller memory footprint and generates better random numbers.</p> <p>git: 91cf1774</p>"},{"location":"docs/core-tasks/numbers/#how-to-generate-a-random-number","title":"How to generate a random number?","text":"<p>Call <code>Randomize</code> once, then use <code>Random()</code> function.</p> <pre><code>program RandomNumberSimple;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Math;\n\nvar\n  i: integer;\n\nbegin\n\n  // Init the random number generator.\n  Randomize;\n\n  // Generate a random number betwen 0 to 100\n  i := Random(101);\n  WriteLn(i);\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/numbers/#how-to-generate-a-random-number-integer-between-2-numbers","title":"How to generate a random number (Integer) between 2 numbers?","text":"<p>You can write a function as follows.</p> <pre><code>function RandomBetween(min, max: integer): integer;\nbegin\n  Result:= Random(max - min + 1) + min;\nend;\n</code></pre> <p>Here is the full example.</p> <pre><code>program RandomNumberBetween;\n\nfunction RandomBetween(const min, max: integer): integer;\nbegin\n  Result:= Random(max - min + 1) + min;\nend;\n\nvar\n  randomNumber: integer;\n  min, max: integer;\n\nbegin\n  min := 1;\n  max := 10;\n\n  // Initialise the randeom number generator\n  Randomize;\n\n  randomNumber := RandomBetween(2, 10);\n\n  WriteLn('Random number between ', min, ' and ', max, ' is: ', randomNumber);\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/numbers/#how-to-generate-a-random-numbers-between-2-real-numbers","title":"How to generate a random numbers between 2 real numbers?","text":"<p>You can use the function below to get a real number between 2 numbers.</p> <pre><code>function RandomNumberBetween(const min, max: real): real;\nbegin\n  Result := Random * (max - min) + min;\nend;\n</code></pre> <p>Here is the full example.</p> <pre><code>program RandomRealNumberBetween;\n\nfunction RandomNumberBetween(const min, max: real): real;\nbegin\n  Result := Random * (max - min) + min;\nend;\n\nvar\n  randomRealNumber: real;\n  min, max: real;\n\nbegin\n  min := 1.0;\n  max := 10.0;\n\n  // Initialise random number generator\n  Randomize;\n\n  // Get a random (real) number between min and max\n  randomRealNumber := RandomNumberBetween(min, max);\n\n  WriteLn('Random real number between ', min: 0: 6, ' and ', max: 0: 6, ' is: ', randomRealNumber: 0: 6);\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/numbers/#how-to-generate-a-series-of-random-real-numbers","title":"How to generate a series of random real numbers?","text":"<p>You can use <code>TGVector</code> and <code>function RandomNumberBetween(const min, max: real): real;</code> mentioned in the previous section.</p> <ol> <li>Create a new <code>type</code> to contain a list of real numbers (line 15).</li> <li>Create a new <code>var</code> based on the <code>type</code> and allocate  (line 22).</li> <li>Initialise the random number generator (line 27).</li> <li>Initialise the new list (line 30).</li> <li>Populate the list using a <code>for</code> loop (line 34-38).</li> <li>Free allocated memory for the list (line 54).</li> </ol> <pre><code>program RandomRealNumberList;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Math, lgVector;\n\nfunction RandomNumberBetween(const min, max: real): real;\nbegin\n  Result := Random * (max - min) + min;\nend;\n\ntype\n  // Create a list of real (double)\n  TRealList = specialize TGVector&lt;real&gt;;\n\nconst\n  noSample: integer = 250;\n\nvar\n  i: integer;\n  realList: TRealList;\n\nbegin\n  // Randomize initializes the random number generator by assigning a value\n  // to Randseed, which is computed based on the system clock.\n  Randomize;\n\n  // Init the real list\n  realList := TRealList.Create;\n  try\n\n    // Populating the list with random real numbers\n    WriteLn('-- Populating the list --------------------------------');\n    for i := 0 to noSample do\n    begin\n      realList.Add(RandomNumberBetween(1, 100));\n    end;\n\n    // Displaying the content of the list\n    WriteLn('-- Content of list, showing up to 4 decimals ----------');\n    for i := 0 to realList.Count - 1 do\n    begin\n      Write(realList[i]: 0: 4, ' ');\n    end;\n    WriteLn;\n\n    // Displaying the mean\n    WriteLn('-- The mean, up to 4 decimals, is ---------------------');\n    WriteLn(Math.Mean(realList.ToArray): 0: 4);\n\n  finally\n    // Free allocated resources for list\n    realList.Free;\n  end;\n\n  ReadLn;\nend.\n</code></pre> <p>Alternatively, you can use <code>array of real</code> too.</p> <p>Here is an example.</p> <pre><code>program RandomRealNumberListv2;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  Math;\n\nfunction RandomNumberBetween(const min, max: real): real;\nbegin\n  Result := Random * (max - min) + min;\nend;\n\nconst\n  noSample: integer = 250;\n\nvar\n  i: integer;\n  realList: array of real;\n\nbegin\n  // Randomize initializes the random number generator by assigning a value\n  // to Randseed, which is computed based on the system clock.\n  Randomize;\n\n  // Set size of the dynamic array\n  SetLength(realList, noSample);\n\n  // Populating the list with random real numbers\n  WriteLn('-- Populating the list --------------------------------');\n  for i := low(realList) to high(realList) do\n  begin\n    realList[i] := RandomNumberBetween(1, 100);\n  end;\n\n  // Displaying the content of the list\n  WriteLn('-- Content of list, showing up to 4 decimals ----------');\n  for i := 0 to high(realList) do\n  begin\n    Write(realList[i]: 0: 4, ' ');\n  end;\n\n  WriteLn;\n\n  // Displaying the mean\n  WriteLn('-- The mean, up to 4 decimals, is ---------------------');\n  WriteLn(Math.Mean(realList): 0: 4);\n\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/overview/","title":"Core Tasks","text":"<p>This section has recipes for doing core tasks using Free Pascal and Lazarus.</p> <p>Important</p> <p>This section assumes you have correctly set up the Free Pascal Compiler and the Lazarus IDE for your OS.</p> <p>Choose a topic from the left sidebar.</p>"},{"location":"docs/core-tasks/regex/","title":"Regex","text":""},{"location":"docs/core-tasks/regex/#match-a-filename-using-regex","title":"Match a filename using regex","text":"<p>Here is an example of using <code>TRegExpr</code> and <code>\\w*.txt$</code> to match <code>*.txt</code> files.</p> <ol> <li>In <code>uses</code> section add <code>RegExpr</code>. Line 11.</li> <li>Create the <code>TRegExpr</code> object Line 20.</li> <li>Enable case insensitive flag. Line 23. </li> <li>Apply the regex expression. Line 25.</li> <li>Use <code>TRegExpr.Exec</code> to find a match in the input string. Line 27.</li> <li><code>Free</code> the <code>TRegExpr</code> object at the end. Line 33.</li> </ol> <p><pre><code>program MatchingFilename;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  RegExpr;\n\nvar\n  regex: TRegExpr;\n  regexPattern: string = '\\w*.txt$';\n  filename: string = 'hello-text.txt';\n\nbegin\n  // Create TRegExpr\n  regex := TRegExpr.Create;\n  try\n    // Set the regex to case-insensitive\n    regex.ModifierI := True;\n    // Apply the regex pattern\n    regex.Expression := regexPattern;\n    // Check for a match\n    if regex.Exec(filename) then\n      WriteLn(Format('''%s'' matches %s!', [regexPattern, filename]))\n    else\n      WriteLn(Format('''%s'' does not match %s!', [regexPattern, filename]));\n  finally\n    // Free TRegExpr\n    regex.Free;\n  end;\n\n  // Pause console\n  WriteLn('Press Enter key to exit ...');\n  ReadLn;\nend.\n</code></pre> For more info check https://regex.sorokin.engineer/en/latest/tregexpr.html.</p>"},{"location":"docs/core-tasks/regex/#match-a-filename-using-regex-alt","title":"Match a filename using regex (Alt)","text":"<p>If you find the previous snippet to be untidy, you have the option to encapsulate the regular expression matching within a function. See the snippet below, line 13-33.</p> <p>See the snippet below, matching a filename using a regex is now a one liner. Line 40.</p> <pre><code>program MatchingFilenameAlt;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  RegExpr;\n\n  // A function for matching filename against a regex pattern\n  function IsFileNameMatching(const fileName: string; const regexPattern: string): boolean;\n  var\n    regex: TRegExpr;\n  begin\n    regex := TRegExpr.Create;\n    try\n      // Set the regex to case-insensitive\n      regex.ModifierI := True;\n      // Apply the regex pattern\n      regex.Expression := regexPattern;\n      // Check for a match\n      if regex.Exec(filename) then\n        Result := True\n      else\n        Result := False;\n    finally\n      // Free TRegExpr\n      regex.Free;\n    end;\n  end;\n\nvar\n  regexPattern: string = '\\w*.txt$';\n  filename: string = 'hello-text.txt';\n\nbegin\n  if IsFileNameMatching(filename, regexPattern) then\n    WriteLn(Format('%s matches %s!', [regexPattern, filename]))\n  else\n    WriteLn(Format('%s does not match %s!', [regexPattern, filename]));\n\n  //Pause console\n  WriteLn('Press Enter kay to exit ...');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/regex/#match-a-string-using-regex-and-print-out-all-matches","title":"Match a string using regex and print out all matches","text":"<p>Here is an example of using <code>TRegExpr</code> to find and print out matches, where the user specify the regex as a command line argument.</p> <p>The program will keep on asking for an input string until a match is found.</p> <ol> <li>In <code>uses</code> section add <code>RegExpr</code>. Line 21.</li> <li>Create the <code>TRegExpr</code> object using <code>ParamStr(1)</code> as the expression to evaluate. Line 33.</li> <li>Enable case insensitive flag. Line 36. </li> <li>Use <code>Exec</code> to find a match in the input string. Line 43.</li> <li>If input is found use while loop to get the values in <code>re.Matches[i]</code>. Line 48-53.</li> <li><code>Free</code> the <code>TRegExpr</code> object at the end. Line 60.</li> </ol> <pre><code>program RegexExample;\n\n// Program will quit when you give a text input matching regex pattern\n// in the program's argument.\n\n// For example.\n// $ RegexExample.exe \"(\\d{1,4})[-/.](\\d{1,2}|[a-zA-Z]{3,})[-/.](\\d{1,4})\"\n\n// Enter a text:24-Mar-2024\n// Matches!\n// Note! Match[0] is the entire match!\n// Match 0 : 24-Mar-2024\n// Match 1 : 24\n// Match 2 : Mar\n// Match 3 : 2024\n// $\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  RegExpr;\n\nvar\n  re: TRegExpr;\n  input: string;\n  i: integer;\nbegin\n\n  // If user input is '', exit program\n  if ParamStr(1) = '' then Exit;\n\n  // Create the regex object using first argument of the program\n  re := TRegExpr.Create(ParamStr(1));\n  try\n    // Set regex flag to case-insensitive\n    re.ModifierI := True;\n    // Keep on asking the user until there is a match\n    repeat\n      WriteLn;\n      Write('Enter a text:');\n      ReadLn(input);\n      // If there is a match, and match[0] (global) is not '', show all matches\n      if re.Exec(input) and (re.Match[0] &lt;&gt; '') then\n      begin\n        WriteLn('Matches!');\n        WriteLn('Note! Match[0] is the entire match!');\n        // Loop through matches using re.Matches[i]\n        i := 0;\n        while re.Match[i] &lt;&gt; '' do\n        begin\n          WriteLn('Match ', i, ' : ', re.Match[i]);\n          Inc(i);\n        end;\n      end\n      else\n        WriteLn('No match, try again.');\n    until re.Match[0] &lt;&gt; '';\n  finally\n    // Free TRegExpr object\n    re.Free;\n  end;\nend.\n</code></pre> <p>You can find the latest doc of TRegExpr here: https://regex.sorokin.engineer/en/latest/.</p>"},{"location":"docs/core-tasks/regex/#how-can-i-replace-date-separators-with-question-marks","title":"How can I replace date separators with question marks?","text":"<p>See the example below. The algorithm is encapsulated in <code>ReplaceDateSeparatorWithQMark</code>.</p> <ol> <li>Create an instance of TRegExpr. Line 17.</li> <li>Create a regex to capture date, month and year in common formats; <code>d</code>, <code>dd</code>, <code>m</code>, <code>mm</code>, <code>mmm</code>, <code>yy</code> and <code>yyyy</code> format, in any order. Line 20. </li> <li>Use <code>TRegExpr.Replace</code> on a date string to capture potential (1)date, (2)month and (3)year groups, and put <code>?</code> between them. Also, return the result to function caller. Line 26.</li> <li><code>Free</code> the <code>TRegExpr</code> object. Line 28.</li> </ol> <pre><code>program ReplaceDateSeparators;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  RegExpr,\n  SysUtils;\n\n  function ReplaceDateSeparatorWithQMark(dateString: string): string;\n  var\n    re: TRegExpr;\n  begin\n    re := TRegExpr.Create;\n    try\n      // A regex to capture common date formats: dd.mm.yyyy, yyyy.mm.dd, dd.mmm.yy\n      re.Expression := '(\\d{1,4})[-/.](\\d{1,2}|[a-zA-Z]{3,})[-/.](\\d{1,4})';\n\n      // The next line does 3 tasks.\n      // 1. Capture date, month and year groups\n      // 2. Construct a date string and using `?` as separators\n      // 3. And return the result to function caller\n      Result := re.Replace(dateString, '$1?$2?$3', True);\n    finally\n      re.Free;\n    end;\n  end;\n\nvar\n  dateInput1: string = '24-Mar-24';\n  dateInput2: string = '24/03/24';\n  dateInput3: string = '2024/03/24';\n\nbegin\n  try\n    WriteLn(ReplaceDateSeparatorWithQMark(dateInput1));\n    WriteLn(ReplaceDateSeparatorWithQMark(dateInput2));\n    WriteLn(ReplaceDateSeparatorWithQMark(dateInput3));\n  except\n    on E: Exception do\n      WriteLn('Error: ' + E.Message);\n  end;\n  // Pause Console\n  ReadLn;\n\nend.\n</code></pre> <p>If you run the snippet above, the output would be as follows.</p> <pre><code>24?Mar?24\n24?03?24\n2024?03?24\n</code></pre>"},{"location":"docs/core-tasks/regex/#why-would-you-convert-date-separators-to-question-marks","title":"Why would you convert date separators to question marks?","text":"<ol> <li>I needed it as a Regex practice.</li> <li>I need it when I work with <code>ScanDateTime</code>, as <code>?</code> will match any character in the input string.</li> </ol>"},{"location":"docs/core-tasks/regex/#how-do-i-use-tregexpr-in-a-gui-application","title":"How do I use TRegExpr in a GUI application?","text":"<p>Micha\u00ebl Van Canneyt has written a concise example: Using Regular Explession.</p>"},{"location":"docs/core-tasks/strings/","title":"Strings","text":""},{"location":"docs/core-tasks/strings/#what-is-a-string","title":"What is a <code>String</code>?","text":"<p>Depending on compiler setting, a <code>String</code> in FPC is an alias for;</p> <ul> <li><code>ShortString</code> (fixed 255 length),</li> <li><code>AnsiString</code> (variable length) or</li> <li><code>UnicodeString</code> (UTF16).</li> </ul> <p>When <code>{$H+}</code> is not specified, or <code>{$H-}</code>, <code>String</code> is an alias for <code>ShortString</code>.</p> <p>Any <code>ShortString</code> have a maximum length of 255 characters with the implicit codepage <code>CP_ACP</code>. Short strings are always assumed to use the system code page.</p> <p>When <code>{$H+}</code> is specified, <code>String</code> is an alias for <code>AnsiString</code>.</p> <p>Any <code>String</code> is essentially an <code>AnsiString</code> with the <code>DefaultSystemCodePage</code> declared in it; <code>AnsiString(CP_ACP)</code>. And if the default system code page is <code>65001</code>, then any <code>String</code> is <code>UTF-8</code>. </p> <p>With <code>{$mode delpiunicode}</code> switch, <code>string</code> is an alias for <code>Unicodestring</code> string.</p> <p>Commonly on Windows, the system code page is <code>1252</code>. If the system code page is <code>1252</code>, then any <code>String</code> is <code>1252</code>.</p> <p>Refs:</p> <ul> <li>What is a <code>String</code>?</li> <li>https://forum.lazarus.freepascal.org/index.php?topic=58131.0</li> </ul>"},{"location":"docs/core-tasks/strings/#display-utf-8-on-a-console","title":"Display UTF-8 on a console","text":"<pre><code>begin\n  WriteLn('\u52e4\u594b,\u52e4\u52c9\u306b\u306a\u308b,\ubd80\uc9c0\ub7f0\ud558\ub2e4!\ud83d\udc4d');\n  WriteLn('Press Enter key to exit');\n  ReadLn;\nend.                                 \n</code></pre> <p>Alternatively, you can assign your UTF-8 test to a <code>string</code> variable.</p> <pre><code>var\n  s: string = '\u52e4\u594b,\u52e4\u52c9\u306b\u306a\u308b,\ubd80\uc9c0\ub7f0\ud558\ub2e4!\ud83d\udc4d';\n\nbegin\n  WriteLn(s);\nend.                        \n</code></pre> <p>Note</p> <p>If you see garbage characters on console;</p> <ol> <li>your console might not support code page 65001, or</li> <li>your windows does not support UTF on API level (only read/write file in UTF-8)</li> </ol> <p>See this answer from StackOverflow on how to enable code page 65001 on your console.</p> <p>Warning</p> <p>The same answer from StackOverflow also shows how to enable UTF-8 on Windows (system-wide). </p> <p>DO NOT MISS the caveat section and comments in from that answer.</p> <p>Enabling UTF-8 system-wide on Windows is currently in beta and could lead to unintended system-wide side effects.</p> <p>Refs:</p> <ul> <li>https://wiki.freepascal.org/FPC_Unicode_support#Code_pages</li> <li>https://stackoverflow.com/a/57134096</li> <li>https://superuser.com/a/1435645</li> </ul>"},{"location":"docs/core-tasks/strings/#what-is-my-systems-default-codepage","title":"What is my system's default codepage?","text":"<p>See https://www.freepascal.org/docs-html/rtl/system/defaultsystemcodepage.html</p> <pre><code>begin\n  WriteLn(DefaultSystemCodePage); \nend.                                 \n</code></pre> <p>If it says <code>65001</code>, then you should be able to see UTF-8 characters on the console.</p>"},{"location":"docs/core-tasks/strings/#remove-trailing-chars-at-the-end-of-a-string","title":"Remove trailing chars at the end of a string","text":"<p>Contribution</p> <p>Gustavo 'Gus' Carreno, from the Unofficial Free Pascal Discord server, shared a neat trick to remove trailing characters by using <code>SetLength(str, length(str) - n);</code>.</p> <p>Let's say you have a loop that append strings with trailing characters at the end.</p> <p>One way to remove trailing characters is use a flag to inside the <code>for</code> loop. The logic would be: do not add commas or spaces if we are at the end of the loop.</p> <p>A simpler way is to use <code>SetLength(str, length(str) - n_chars_to_remove);</code>.</p> <p>See the example below. </p> <ol> <li>The <code>for</code> loop completes a sentence with a comma and a space at the end. Line 19-20.</li> <li>The trick; <code>SetLength(line, length(line) - 2);</code> removes the last 2 chars from the end of the sentence. Line 29.</li> </ol> <pre><code>program RemoveTrailingChars;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes;\n\nvar\n  cities: array of string = ('Sydney', 'Melbourne', 'Surabaya', 'Malang');\n  city, line: string;\n\nbegin\n\n  // Building a sentence using the array of string.\n  line := 'I have been to the following cities: ';\n  for city in cities do\n    line := line + city + ', ';\n\n  // Now, line has a trailing comma and a space at the end.\n  WriteLn(line);\n\n  // Here is a trick to remove additional characters at the end of a string\n  // by Gustavo 'Gus' Carreno,  2024-03-16 @ 14:42.\n  // Simply use SetLength(str, length(str) - n_chars_to_remove);\n  // Source: https://discord.com/channels/570025060312547359/896807098518732901/1218403991092985877\n  SetLength(line, length(line) - 2);\n\n  // Finally, just add a dot.\n  line := line + '.';\n  WriteLn(line);\n\n  // Pause console\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/core-tasks/zip-and-unzip/","title":"Zip and Unzip Files","text":"<p>Note</p> <p>Visit the official docs for more info.</p> <ul> <li>https://wiki.lazarus.freepascal.org/paszlib</li> <li>https://www.freepascal.org/docs-html/fcl/zipper/index.html</li> </ul>"},{"location":"docs/core-tasks/zip-and-unzip/#zip-files-simple","title":"Zip Files - Simple","text":"<pre><code>program ZipEx01;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  zipper;\n\nvar\n  zip: TZipper;\n\nbegin\n  zip := TZipper.Create;\n  try\n    zip.FileName := 'simple.zip';\n    zip.Entries.AddFileEntry('file1.txt');\n    zip.Entries.AddFileEntry('file2.txt');\n    zip.ZipAllFiles;\n  finally\n    zip.Free;\n  end;\n  WriteLn('File zipped successfully.');\nend.\n</code></pre>"},{"location":"docs/core-tasks/zip-and-unzip/#zip-files-command-line-input","title":"Zip Files - Command Line Input","text":"<p>Note</p> <p>The following example was adapted from the official doc: https://wiki.lazarus.freepascal.org/paszlib.</p> <pre><code>program ZipEx02;\n\n{$mode objfpc}{$H+}{$J-}\n\n// Usage:\n// ZipEx02 newzip.zip file1.txt file2.txt\n\nuses\n  Zipper;\n\nvar\n  zip: TZipper;\n  index: integer;\n\nbegin\n  zip := TZipper.Create;\n  try\n    // Define the file name of the zip file to be created\n    zip.FileName := ParamStr(1);\n    for index := 2 to ParamCount do\n      // First argument: the names of the files to be included in the zip\n      // Second argument: the name of the file as it appears in the zip and\n      // later in the file system after unzipping\n      zip.Entries.AddFileEntry(ParamStr(index), ParamStr(index));\n    // Execute the zipping operation and write the zip file.\n    zip.ZipAllFiles;\n  finally\n    zip.Free;\n  end;\nend.\n</code></pre> <p>Usage</p> <pre><code>$ ./ZipEx02.exe newzip.zip file1.txt file2.txt\n</code></pre>"},{"location":"docs/core-tasks/zip-and-unzip/#unzip-a-zip-file","title":"Unzip a Zip File","text":"<pre><code>program UnzipEx01;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  zipper;\n\nvar\n  unZip: TUnZipper;\n\nbegin\n  unZip := TUnZipper.Create;\n  try\n    unZip.FileName := 'simple.zip';\n    unZip.OutputPath := 'output_folder';\n    unZip.UnZipAllFiles;\n  finally\n    unZip.Free;\n  end;\n  WriteLn('File unzipped successfully.');\nend.\n</code></pre>"},{"location":"docs/external-systems/overview/","title":"External Systems","text":"<p>This section has recipes on interacting with outside worlds using Free Pascal and Lazarus.</p> <p>Important</p> <p>This section assumes you have correctly set up the Free Pascal Compiler and the Lazarus IDE for your OS.</p> <p>Choose a topic from the left sidebar.</p>"},{"location":"docs/external-systems/parsing-json/","title":"Parsing JSON","text":"<p>Since many services use JSON for exchanging information, wouldn't it be nice to know how to do this in Free Pascal and Lazarus?</p>"},{"location":"docs/external-systems/parsing-json/#how-do-i-make-a-get-request","title":"How do I make a GET request?","text":"<p>Note</p> <p>The snippet below is based on a fine tutorial by Marcus Fernstr\u00f6m.</p> <p>Watch the detailed explanation by Marcus on YouTube; Learn how to consume JSON data in Free Pascal</p> <p>Here is an example on making a GET request of JSON data and displaying it on console.</p> <ol> <li>In <code>uses</code> add <code>opensslsockets</code> and <code>fphttpclient</code> for making the GET request. Line 11-12.</li> <li>Set two variables. Line 16-17.<ul> <li>One for the URL. Here I use <code>https://dummyjson.com/users?limit=3</code>.</li> <li>One for the response of the GET request.</li> </ul> </li> <li>Make the GET request by using <code>TFPHTTPClient.SimpleGet(url)</code>. Line 22.</li> <li>Print result on console. Line 25.</li> </ol> <pre><code>program GetRequest;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  // For making web requests\n  opensslsockets,\n  fphttpclient;\n\n\nvar\n  url: string = 'https://dummyjson.com/users?limit=3'; // endpoint to get JSON mock data\n  rawJson: string; // a var to store raw JSON data\n\nbegin\n  // Get the raw JSON data\n  WriteLn('Contacting ', url, ' ...');\n  rawJson := TFPHTTPClient.SimpleGet(url);\n\n  // Display JSON on console\n  WriteLn(rawJson);\n\n  // Pause console\n  WriteLn('Press enter key to exit...');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/external-systems/parsing-json/#how-do-i-parse-json-from-dummyjsonorg","title":"How do I parse JSON from <code>dummyjson.org</code>?","text":"<p>Note</p> <p>Again, the snippet below is based on a fine tutorial by Marcus Fernstr\u00f6m.</p> <p>Watch the detailed explanation by Marcus on YouTube; Learn how to consume JSON data in Free Pascal</p> <p>Here is the breakdown of the example below.</p> <ol> <li>Add necessary units for making the GET requests and parsing JSON data. Line 10-15.</li> <li>Setup variables for receiving and processing the JSON data. Line 19-22.<ul> <li>A <code>string</code> to store raw JSON data.</li> <li>A <code>TJSONArray</code> for storing an array of JSON objects.</li> <li>A <code>TJSONEnum</code> for looping JSON arrays.</li> <li>A <code>TJSONObject</code> for manipulating a JSON object.</li> </ul> </li> <li>Make the GET request and store the raw JSON response. Line 27.</li> <li>Retrieve the array as TJSONArray. Line 33.<ul> <li>Convert the raw <code>JSON</code> data to <code>TJSONData</code>,</li> <li>find data called \"<code>users</code>\" (a JSON array as per dummyjson's specs) and</li> <li>Lastly, cast as <code>TJSONArray</code>.</li> </ul> </li> <li>Use the <code>TJSONEnum</code> var to loop through the JSON array. Line 36.</li> <li>To use the JSON  object in the loop, cast the <code>TJSONEnum .value</code>, which is <code>TJSONData</code> to <code>TJSONObject</code>. Line 39.</li> <li>Once you've obtained the JSONObject, use <code>FindPath</code> to get value based on a key or a path.</li> </ol> <pre><code>program ParseJSON;\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cthreads,\n  {$ENDIF}\n  Classes,\n  // For web requests\n  opensslsockets,\n  fphttpclient,\n  // For parsing JSON data\n  fpjson,\n  jsonparser;\n\nvar\n  url: string = 'https://dummyjson.com/users?limit=3'; // endpoint to get JSON mock data\n  rawJson: string;       // a var to store the raw JSON data\n  arrayJson: TJSONArray; // a var for storing an array of JSON objects\n  enumJson: TJSONEnum;   // an enum type for looping JSON arrays\n  objJson: TJSONObject;  // a var for manipulating a JSON object\n\nbegin\n  // Get the raw JSON data\n  WriteLn('Contacting ', url, ' ...');\n  rawJson := TFPHTTPClient.SimpleGet(url);\n\n  // Next, get the users array as TJSONArray;\n  // 1. convert the raw JSON data to TJSONData,\n  // 2. find data called \"users\" (a JSON array as per dummyjson's structure) and\n  // 3. cast as TJSONArray\n  arrayJson := TJSONArray(GetJSON(rawJson).FindPath('users'));\n\n  // Loop using the TJSONEnum\n  for enumJson in arrayJson do\n  begin\n    // Cast the enum value (TJSONData) to TJSONObject\n    objJson := TJSONObject(enumJson.Value);\n\n    // Output values based on keys/paths using `TJSONObject.FindPath('a_key')`\n    WriteLn('id   : ', objJson.FindPath('id').AsString);\n    WriteLn('name : ', objJson.FindPath('firstName').AsString, ' ', objJson.FindPath('lastName').AsString);\n    WriteLn('phone: ', objJson.FindPath('phone').AsString);\n    WriteLn('city : ', objJson.FindPath('address.city').AsString);\n    WriteLn('state: ', objJson.FindPath('address.state').AsString);\n    WriteLn('---');\n  end;\n\n  // Pause console\n  WriteLn('Press enter key to exit...');\n  ReadLn;\nend.\n</code></pre>"},{"location":"docs/external-systems/parsing-json/#why-do-we-use-getjsonrawjsonfindpathusers-to-get-the-array","title":"Why do we use <code>GetJSON(rawJson).FindPath('users')</code> to get the array?","text":"<p>As per the specs of <code>https://dummyjson.com/users?limit=3</code>, the array of users is in <code>users</code>. Here is an response example from the <code>/users?limit=3</code> endpoint.</p> <pre><code>{\n  \"users\": [\n    {\n      \"id\": 1,\n      \"firstName\": \"Terry\",\n      \"lastName\": \"Medhurst\",\n      \"maidenName\": \"Smitham\",\n      \"age\": 50,\n      \"gender\": \"male\",\n      \"email\": \"atuny0@sohu.com\",\n      \"phone\": \"+63 791 675 8914\",\n      \"username\": \"atuny0\",\n      \"password\": \"9uQFF1Lh\",\n      \"birthDate\": \"2000-12-25\",\n      \"image\": \"https://robohash.org/Terry.png?set=set4\",\n      \"bloodGroup\": \"A-\",\n      \"height\": 189,\n      \"weight\": 75.4,\n      \"eyeColor\": \"Green\",\n      \"hair\": {\n        \"color\": \"Black\",\n        \"type\": \"Strands\"\n      },\n      \"domain\": \"slashdot.org\",\n      \"ip\": \"117.29.86.254\",\n      \"address\": {\n        \"address\": \"1745 T Street Southeast\",\n        \"city\": \"Washington\",\n        \"coordinates\": {\n          \"lat\": 38.867033,\n          \"lng\": -76.979235\n        },\n        \"postalCode\": \"20020\",\n        \"state\": \"DC\"\n      },\n      \"macAddress\": \"13:69:BA:56:A3:74\",\n      \"university\": \"Capitol University\",\n      \"bank\": {\n        \"cardExpire\": \"06/22\",\n        \"cardNumber\": \"50380955204220685\",\n        \"cardType\": \"maestro\",\n        \"currency\": \"Peso\",\n        \"iban\": \"NO17 0695 2754 967\"\n      },\n      \"company\": {\n        \"address\": {\n          \"address\": \"629 Debbie Drive\",\n          \"city\": \"Nashville\",\n          \"coordinates\": {\n            \"lat\": 36.208114,\n            \"lng\": -86.58621199999999\n          },\n          \"postalCode\": \"37076\",\n          \"state\": \"TN\"\n        },\n        \"department\": \"Marketing\",\n        \"name\": \"Blanda-O'Keefe\",\n        \"title\": \"Help Desk Operator\"\n      },\n      \"ein\": \"20-9487066\",\n      \"ssn\": \"661-64-2976\",\n      \"userAgent\": \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/12.0.702.0 Safari/534.24\",\n      \"crypto\": {\n        \"coin\": \"Bitcoin\",\n        \"wallet\": \"0xb9fc2fe63b2a6c003f1c324c3bfa53259162181a\",\n        \"network\": \"Ethereum (ERC20)\"\n      }\n    },\n    {\n      \"id\": 2,\n      \"firstName\": \"Sheldon\",\n      \"lastName\": \"Quigley\",\n      \"maidenName\": \"Cole\",\n      \"age\": 28,\n      \"gender\": \"male\",\n      \"email\": \"hbingley1@plala.or.jp\",\n      \"phone\": \"+7 813 117 7139\",\n      \"username\": \"hbingley1\",\n      \"password\": \"CQutx25i8r\",\n      \"birthDate\": \"2003-08-02\",\n      \"image\": \"https://robohash.org/Sheldon.png?set=set4\",\n      \"bloodGroup\": \"O+\",\n      \"height\": 187,\n      \"weight\": 74,\n      \"eyeColor\": \"Brown\",\n      \"hair\": {\n        \"color\": \"Blond\",\n        \"type\": \"Curly\"\n      },\n      \"domain\": \"51.la\",\n      \"ip\": \"253.240.20.181\",\n      \"address\": {\n        \"address\": \"6007 Applegate Lane\",\n        \"city\": \"Louisville\",\n        \"coordinates\": {\n          \"lat\": 38.1343013,\n          \"lng\": -85.6498512\n        },\n        \"postalCode\": \"40219\",\n        \"state\": \"KY\"\n      },\n      \"macAddress\": \"13:F1:00:DA:A4:12\",\n      \"university\": \"Stavropol State Technical University\",\n      \"bank\": {\n        \"cardExpire\": \"10/23\",\n        \"cardNumber\": \"5355920631952404\",\n        \"cardType\": \"mastercard\",\n        \"currency\": \"Ruble\",\n        \"iban\": \"MD63 L6YC 8YH4 QVQB XHIK MTML\"\n      },\n      \"company\": {\n        \"address\": {\n          \"address\": \"8821 West Myrtle Avenue\",\n          \"city\": \"Glendale\",\n          \"coordinates\": {\n            \"lat\": 33.5404296,\n            \"lng\": -112.2488391\n          },\n          \"postalCode\": \"85305\",\n          \"state\": \"AZ\"\n        },\n        \"department\": \"Services\",\n        \"name\": \"Aufderhar-Cronin\",\n        \"title\": \"Senior Cost Accountant\"\n      },\n      \"ein\": \"52-5262907\",\n      \"ssn\": \"447-08-9217\",\n      \"userAgent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/11.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30\",\n      \"crypto\": {\n        \"coin\": \"Bitcoin\",\n        \"wallet\": \"0xb9fc2fe63b2a6c003f1c324c3bfa53259162181a\",\n        \"network\": \"Ethereum (ERC20)\"\n      }\n    },\n    {\n      \"id\": 3,\n      \"firstName\": \"Terrill\",\n      \"lastName\": \"Hills\",\n      \"maidenName\": \"Hoeger\",\n      \"age\": 38,\n      \"gender\": \"male\",\n      \"email\": \"rshawe2@51.la\",\n      \"phone\": \"+63 739 292 7942\",\n      \"username\": \"rshawe2\",\n      \"password\": \"OWsTbMUgFc\",\n      \"birthDate\": \"1992-12-30\",\n      \"image\": \"https://robohash.org/Terrill.png?set=set4\",\n      \"bloodGroup\": \"A-\",\n      \"height\": 200,\n      \"weight\": 105.3,\n      \"eyeColor\": \"Gray\",\n      \"hair\": {\n        \"color\": \"Blond\",\n        \"type\": \"Very curly\"\n      },\n      \"domain\": \"earthlink.net\",\n      \"ip\": \"205.226.160.3\",\n      \"address\": {\n        \"address\": \"560 Penstock Drive\",\n        \"city\": \"Grass Valley\",\n        \"coordinates\": {\n          \"lat\": 39.213076,\n          \"lng\": -121.077583\n        },\n        \"postalCode\": \"95945\",\n        \"state\": \"CA\"\n      },\n      \"macAddress\": \"F2:88:58:64:F7:76\",\n      \"university\": \"University of Cagayan Valley\",\n      \"bank\": {\n        \"cardExpire\": \"10/23\",\n        \"cardNumber\": \"3586082982526703\",\n        \"cardType\": \"jcb\",\n        \"currency\": \"Peso\",\n        \"iban\": \"AT24 1095 9625 1434 9703\"\n      },\n      \"company\": {\n        \"address\": {\n          \"address\": \"18 Densmore Drive\",\n          \"city\": \"Essex\",\n          \"coordinates\": {\n            \"lat\": 44.492953,\n            \"lng\": -73.101883\n          },\n          \"postalCode\": \"05452\",\n          \"state\": \"VT\"\n        },\n        \"department\": \"Marketing\",\n        \"name\": \"Lindgren LLC\",\n        \"title\": \"Mechanical Systems Engineer\"\n      },\n      \"ein\": \"48-3951994\",\n      \"ssn\": \"633-89-1926\",\n      \"userAgent\": \"Mozilla/5.0 (Windows NT 6.2; Win64; x64; rv:21.0.0) Gecko/20121011 Firefox/21.0.0\",\n      \"crypto\": {\n        \"coin\": \"Bitcoin\",\n        \"wallet\": \"0xb9fc4b4b855bc44eb30d5e36fd18f491f44a15b7\",\n        \"network\": \"Ethereum (ERC20)\"\n      }\n    }\n  ],\n  \"total\": 100,\n  \"skip\": 0,\n  \"limit\": 3\n}\n</code></pre>"},{"location":"docs/external-systems/webserver/","title":"Webserver","text":""},{"location":"docs/external-systems/webserver/#a-simple-rest-apis-returning-json-and-html-contents","title":"A simple REST APIs returning JSON and HTML contents","text":"<p>Have a look at the example below, based on a tutorial by Marcus Fernstr\u00f6m.</p> <p>The program creates a basic REST APIs with three routes.</p> <ul> <li><code>/api/timestamp</code> to give current timestamp in JSON.</li> <li><code>/api/greet/:name</code> to return a specified <code>name</code> in JSON.</li> <li><code>/404</code> for handling everything else.</li> </ul> <p>Here is the breakdown.</p> <ol> <li>In the <code>unit</code>, add <code>fphttpapp</code>, <code>HTTPDefs</code>, <code>httproute</code>, <code>fpjson</code> and <code>jsonparser</code>. Line 16-20.</li> <li>Setup port no and enable multi-threading to process incoming http requests. Line 77-78.</li> <li>Register routes and set <code>/404</code> as the default route. Line 81-83.</li> <li>Define procedures to handle the routes. Line 23-67.</li> <li>Initialise and run. Line 86-88. </li> </ol> <pre><code>program SimpleApiWebserver;\n\n// References:\n//  - https://medium.com/@marcusfernstrm/create-rest-apis-with-freepascal-441e4aa447b7\n//  - https://www.youtube.com/watch?v=9N0cxI1Hp0U\n//  - https://wiki.lazarus.freepascal.org/fpWeb_Tutorial#webserver-example\n\n{$mode objfpc}{$H+}{$J-}\n\nuses\n  {$IFDEF UNIX}\n  cmem, cthreads,\n  {$ENDIF}\n  Classes,\n  SysUtils,\n  fphttpapp,\n  HTTPDefs,\n  httproute,\n  fpjson,\n  jsonparser;\n\n  // Endpoint for getting the current timestamp\n  procedure TimestampEndPoint(aRequest: TRequest; aResponse: TResponse);\n  var\n    json: TJSONObject;\n  begin\n    json := TJSONObject.Create;\n    try\n      json.Strings['timestamp'] := FormatDateTime('yyyy-mm-dd hh:nn:ss.z', Now);\n      aResponse.Content := json.AsJSON;\n      aResponse.Code := 200;\n      aResponse.ContentType := 'application/json';\n      aResponse.ContentLength := Length(aResponse.Content);\n      aResponse.SendContent;\n    finally\n      json.Free;\n    end;\n\n  end;\n\n  // An endpoint accepting a variable\n  procedure GreetEndpoint(aRequest: TRequest; aResponse: TResponse);\n  var\n    json: TJSONObject;\n  begin\n    json := TJSONObject.Create;\n    try\n      json.Strings['message'] := 'Hello, ' + aRequest.RouteParams['name'];\n      aResponse.Content := json.AsJSON;\n      aResponse.Code := 200;\n      aResponse.ContentType := 'application/json';\n      aResponse.ContentLength := Length(aResponse.Content);\n      aResponse.SendContent;\n    finally\n      json.Free;\n    end;\n  end;\n\n  // An endpoint to handle unknown requests\n  procedure ErrorEndPoint(aRequest: TRequest; aResponse: TResponse);\n  begin\n    aResponse.Content := '&lt;h1&gt;404!&lt;/h1&gt;&lt;h3&gt;How did you get here?&lt;/h3&gt;';\n    aResponse.Code := 404;\n    aResponse.ContentType := 'text/html';\n    aResponse.ContentLength := Length(aResponse.Content);\n    aResponse.SendContent;\n  end;\n\n\nconst\n  port: integer = 8080;\n  isThreaded: boolean = True;\n\nbegin\n\n  // Set port no &amp; enable multi-threading to handle http requests\n  Application.Port := port;\n  Application.Threaded := isThreaded;\n\n  // Setup routes\n  HTTPRouter.RegisterRoute('/api/timestamp', rmGet, @TimestampEndPoint);\n  HTTPRouter.RegisterRoute('/api/greet/:name', rmGet, @GreetEndpoint);\n  HTTPRouter.RegisterRoute('/404', rmGet, @ErrorEndPoint, True); // Set as the default endpoint\n\n  // Initialise and run, with a message\n  Application.Initialize;\n  WriteLn('== Server is running on port ', port, ' ===');\n  Application.Run;\n\nend.\n</code></pre> <p>How to use</p> <ul> <li>Run the program.</li> <li>To get the current timestamp, put into your browser: <code>http://127.0.0.1:8080/api/timestamp</code>.</li> <li>To get a greeting in json, put into your browser: <code>http://127.0.0.1:8080/api/greet/Jonathan</code>.</li> <li>Non-matching endpoints will get you to: <code>http://127.0.0.1:8080/404</code>.</li> </ul> <p>References</p> <ul> <li>https://medium.com/@marcusfernstrm/create-rest-apis-with-freepascal-441e4aa447b7</li> <li>https://www.youtube.com/watch?v=9N0cxI1Hp0U</li> <li>https://wiki.lazarus.freepascal.org/fpWeb_Tutorial#webserver-example</li> </ul>"},{"location":"docs/resources/docs-sites/","title":"Relevant Documents and Sites","text":""},{"location":"docs/resources/docs-sites/#more-snippets","title":"More Snippets!","text":"<ul> <li>Gitlab <code>lazarus/examples</code>. There are more snippets (gems) in the example folder of Lazarus installation. You can access them online too.</li> <li>Github gcarreno/TestThreading. Example of how to use the Class TThread and all of the threading tools available with Free Pascal.</li> </ul>"},{"location":"docs/resources/docs-sites/#articles-and-ebooks-suitable-for-beginners","title":"Articles and eBooks - suitable for beginners","text":"<ul> <li><code>#fpc</code> <code>#lazarus</code> Free Pascal and Lazarus - A textbook on programming by Alekseev E.R., Chesnokova O.V., Kucher T.V, 2021.</li> <li><code>#fpc</code> <code>#lazarus</code> Introduction to the Lazarus IDE by Lazar Hristov, 2024.</li> <li><code>#fpc</code> Free Pascal From Square One by Jeff Duntemann, 2024.</li> <li><code>#lazarus</code> Laz Planet Tutorials</li> <li><code>#fpc</code> Tao Yue's Pascal Tutorial, also available on Free Pascal's wiki.</li> <li><code>#fpc</code> Tutorials Point's Pascal Tutorial</li> </ul>"},{"location":"docs/resources/docs-sites/#articles-for-experienced","title":"Articles for experienced","text":"<ul> <li><code>#fpc</code> Modern Object Pascal Introduction for Programmers</li> <li><code>#fpc</code> Pascal cheat sheet from learnxinyminutes.com.</li> <li><code>#fpc</code> Pascal Programming idioms from programming-idioms.org.</li> <li><code>#fpc</code> <code>#lazarus</code> 5-part SQLdb tutorial<ul> <li>0 - Database set-up</li> <li>1 - Getting started</li> <li>2 - Editing</li> <li>3 - Queries</li> <li>4 - Data modules</li> </ul> </li> <li><code>#fpc</code> <code>#lazarus</code> Working with SQLite3 database using SQLdb components</li> </ul>"},{"location":"docs/resources/docs-sites/#the-official-free-pascal-resources","title":"The Official Free Pascal Resources","text":"<p>The latest documents are available from Free Pascal site and GitLab FPC Documentation repo.</p> <ul> <li>FPC User's guide (PDF)</li> <li>FPC Programmer's guide (PDF) </li> <li>FPC Language reference guide (PDF) </li> <li>Run-Time Library (RTL) units reference manual (PDF) </li> <li>Free Component Library (FCL) units reference manual (PDF) </li> <li>Free Component Library (FCL) Resource units reference manual (PDF) </li> <li>fpdoc documentation tool reference manual (PDF) </li> <li>Reference chart with all compiler options and switches (PDF) </li> </ul> <p>These were prepared and written by experienced folks. Hence, it might be a bit too technicals for some readers. Do make efforts and you will find gems in them.</p>"},{"location":"docs/resources/docs-sites/#the-official-lazarus-ide-resources","title":"The Official Lazarus IDE Resources","text":"<ul> <li>See Lazarus' wiki for various docs on installation, IDE, tools, LCL, Components and other topics.</li> <li>Working with Lazarus and databases - https://wiki.freepascal.org/Databases</li> </ul> <p>Documentation is converted to html from xml files - xml files are created using FPDoc Editor: https://wiki.freepascal.org/FPDoc_Editor. All xml files with documentation can be found here: https://gitlab.com/freepascal.org/lazarus/lazarus/-/tree/main/docs/xml</p> <p>If you want to modify the conversion to html start with: https://gitlab.com/freepascal.org/lazarus/lazarus/-/tree/main/docs/html</p> <p>Quoted from paweld \ud83c\uddf5\ud83c\uddf1 \u2014 19/11/2023 21:53</p>"},{"location":"docs/resources/fpc-laz-packages/","title":"Packages","text":""},{"location":"docs/resources/fpc-laz-packages/#what-are-packages","title":"What are Packages?","text":"<p>Basically, packages are add-ons you can install to add or modify functionalities of your programs or the Lazarus IDE.</p> <p>There are various kinds of packages for Free Pascal &amp; Lazarus IDE. The following is a summary from https://wiki.freepascal.org/packages(disambiguation)</p> <p>Packages have different meanings FPC &amp; Lazarus projects.</p> <p>Types of packages:</p> <ul> <li>Lazarus Runtime Packages adds a dependency on a runtime package and Lazarus adds the files to the search path.</li> <li>Lazarus (IDE)Packages is bundled with IDE and can be installed via main menu: <code>Package -&gt; Install/Uninstall Packages..</code>.</li> <li>Lazarus Designtime Packages register themselves in the IDE, e.g. designtime editor components for the object inspector. These may contain runtime-only units.</li> </ul>"},{"location":"docs/resources/fpc-laz-packages/#package-managers","title":"Package Managers","text":"<ul> <li>Online Package Manager(GUI) - https://wiki.freepascal.org/Online_Package_Manager</li> <li>fpcupdeluxe(GUI) - https://github.com/LongDirtyAnimAlf/fpcupdeluxe/releases</li> <li>LazarusPackageManager(CLI) - https://github.com/Warfley/LazarusPackageManager</li> </ul>"},{"location":"docs/resources/fpc-laz-packages/#a-lib-i-need-is-not-in-my-fav-package-manager-what-can-i-do","title":"A lib I need is not in my fav package manager, what can I do?","text":"<ol> <li>Contact the package manager maintaners to add, or</li> <li>Download the lib and get FPC (via Lazarus GUI) to include the location of your downloaded lib.</li> </ol>"},{"location":"docs/resources/fpc-laz-packages/#fpc-lazarus-packages","title":"FPC &amp; Lazarus Packages","text":"<p>Note</p> <p>I only listed packages that are relevant for my projects and works with Free Pascal and Lazarus IDE. </p> <p>There are more packages (and visual components) out there than listed here. </p> <ul> <li>https://github.com/Fr0sT-Brutal/awesome-pascal</li> <li>https://wiki.freepascal.org/Components_and_Code_examples#Default_components_provided_by_Lazarus</li> <li>https://wiki.freepascal.org/Package_List</li> <li>https://wiki.freepascal.org/Category:Libraries</li> <li>https://packages.lazarus-ide.org</li> <li>BeniBella's collection - https://www.benibela.de/sources_en.html#top</li> <li>Check the forums and discord channel too.</li> </ul>"},{"location":"docs/resources/fpc-laz-packages/#lgenerics-by-avk","title":"LGenerics by avk","text":"<p><code>#generics</code></p> <p>A Generics library with tons of goodies by A.Koverdyaev(avk).</p>"},{"location":"docs/resources/fpc-laz-packages/#arrayhelper-by-willi-commer","title":"ArrayHelper by Willi Commer","text":"<p><code>#array-helper</code></p> <p>Delphi class helper for TArray with functions like Add, Delete, IndexOf, Map, etc. Includes examples and testing. Extends TArray with functions similar to TList or TStrings for easier memory management. Introduces TArrayRecord to use dynamic arrays like objects without the need for a final Free call.</p>"},{"location":"docs/resources/fpc-laz-packages/#ezthreads","title":"ezthreads","text":"<p>a simple and safe way to work with threads</p> <p>To request features or report a bug, open a github issue with details/steps to reproduce.</p> <p>General questions can be asked in Discussions</p>"},{"location":"docs/resources/fpc-laz-packages/#indy","title":"Indy","text":"<p><code>#network</code></p> <p>Indy -- Internet Direct -- is a well-known internet component suite for Delphi, C++Builder, and Free Pascal providing both low-level support (TCP, UDP, raw sockets) and over a 120 higher level protocols (SMTP, POP3, NNT, HTTP, FTP) for building both client and server applications.</p>"},{"location":"docs/resources/fpc-laz-packages/#zeoslib","title":"ZeosLib","text":"<p><code>#lazarus</code> <code>#database</code></p> <p>The ZeosLib is a set of database components for MySQL, MariaDB, PostgreSQL, Interbase, Firebird, MS SQL Server, SAP Adaptive Server Enterprise and Adaptive Server Anywhere (previously Sybase), Oracle and SQLite for Delphi, FreePascal/Lazarus and C++ Builder.</p>"},{"location":"docs/resources/fpc-laz-packages/#mormot2","title":"mORMot2","text":"<p><code>#database</code></p> <p>Synopse mORMot 2 is an Open Source Client-Server ORM SOA MVC framework for Delphi 7 up to Delphi 11 Alexandria and FPC 3.2/trunk, targeting Windows/Linux/BSD/MacOS for servers, and any platform for clients (including mobile or AJAX).</p>"},{"location":"docs/resources/fpc-laz-packages/#fundamentals-5","title":"Fundamentals 5","text":"<p><code>#utils</code></p> <p>Fundamentals 5 is a library for Delphi and Free Pascal. This library can help with the following tasks.</p> <ul> <li>String, DateTime and dynamic array routines</li> <li>Unicode routines</li> <li>Hash (e.g. SHA256, SHA512, SHA1, SHA256, MD5)</li> <li>Integer (e.g. Word128, Word256, Int128, Int256)</li> <li>Huge Word, Huge Integer</li> <li>Decimal (Decimal32, Decimal64, Decimal128, HugeDecimal and signed decimals)</li> <li>Random number generators</li> <li>Cryptographic (Symmetric: AES, DES, RC2, RC4; Asymmetric: RSA, Diffie-Hellman, Elliptic Curve)</li> <li>Data structures (array, dictionary and map classes)</li> <li>Mathematics (Rational number, complex number, vector, matrix, statistics)</li> <li>JSON parser</li> <li>Google protocol buffer parser, utilities and Pascal code generator</li> <li>Socket library (cross platform - Windows, Linux, OSX, iOS, Android)</li> <li>TLS Client</li> <li>TLS Server</li> <li>TCP Client</li> <li>TCP Server</li> <li>HTTP Client</li> <li>HTTP Server</li> <li>HTML Parser</li> <li>XML Parser</li> </ul>"},{"location":"docs/resources/fpc-laz-packages/#atsynedit","title":"ATSynEdit","text":"<p><code>#lazarus</code> <code>#visual-component</code></p> <p>ATSynEdit is Multi-line editor control for Lazarus, which was made by Alexey Torgashin as an alternative to SynEdit. It is not based on SynEdit, it has totally different structure.</p>"},{"location":"docs/resources/fpc-laz-packages/#libraries-by-benjamin-rosseaux-bero1985","title":"Libraries by Benjamin Rosseaux (Bero1985)","text":"<p>A collection of useful libraries in Object Pascal by Benjamin Rosseaux.</p> <ul> <li>PasMP: A parallel-processing library to enhance performance in multi-core processor environments.</li> <li>FLRE: FLRE (Fast Light Regular Expressions), a fast and efficient regular expression library implemented in Object Pascal, focusing on core features and optimized for speed.</li> <li>PasJSON: A JSON parser and writer for Pascal, vital for modern data interchange and web development.</li> <li>PUCU: The Pascal UniCode Utils Library, enhancing Unicode support within Pascal projects.</li> <li>And others.</li> </ul> <p>See the full list on BeRo1985's Github page.</p>"},{"location":"docs/resources/fpc-laz-packages/#libraries-by-benito-van-der-zander-benibella","title":"Libraries by Benito van der Zander (benibella)","text":"<ul> <li> <p>Internet Tools: This package provides standard conformant XPath 2.0, XQuery 1.0 and XPath/XQuery 3.0 interpreters with extensions for - among others - JSONiq, pattern matching, CSS and HTML; as well as functions to perform HTTP/S requests on Windows/Linux/MacOSX/Android, an XSLT-inspired webscraping language, and an auto update class. See the internettools documentation or a short overview.</p> </li> <li> <p>BBUtils: These units consist of important low-level functions missing in FreePascal. For example:</p> <ul> <li>String and array view for efficient processing of slices of a string or array.</li> <li>Various array functions (add, delete, search, prealloc, ...) and array lists.</li> <li>Various string functions (pchar/ansistring, compare, split, search, convert html entities, ...). string builder for fast construction of strings.</li> <li>Various date/time parsing/formatting functions, supporting years before 0 and after 65535, and timezones</li> <li>Mathematical functions (gcd, primes, Bernoulli statistics, prime/euler-phi sieve...)</li> <li>Stable sorting function for arbitrary sized data arrays</li> <li>Automatical translation of with tr['marked strings'] and components</li> <li>A Pascal template language which is \"compiled\" to Pascal (similar to the C preprocessor)</li> <li>...</li> <li>Read the docs: bbutils documentation</li> </ul> </li> <li> <p>Big Decimal math: Big Decimal Math This unit provides an arbitrary precision BCD float number type. The usecase is performing a few arithmetic operations with the maximal possible accuracy and precision, e.g. calculating the sum of numbers from a text files, where the conversion from decimal input to binary floats would take more time than the calculation. It can be used like any numeric type and supports:</p> <ul> <li>At least numbers between 10^-2147483647 to 10^2147483647 with 2147483647 decimal digit precision</li> <li>All standard arithmetic and comparison operators</li> <li>Rounding functions (floor, ceil, to-even, ..)</li> <li>Some more advanced operations, e.g. power and sqrt</li> <li>Accurate and precise binary float (single/double/extended) to BCD float and string conversion</li> <li>..</li> <li>Read the docs: bigdecimalmath documentation</li> <li></li> </ul> </li> </ul>"},{"location":"docs/resources/videos/","title":"Videos","text":"<p>Note</p> <p>Info and links on this page compiled from Free Pascal &amp; Lazarus sites (official sites, wikis, Discord), Udemy, and Youtube.</p>"},{"location":"docs/resources/videos/#udemy","title":"Udemy","text":"<ul> <li>Learn Pascal Programming from Scratch by Stone River eLearning. Last updated 02/2017.</li> <li>Learn To Program with Delphi and Object Pascal by Huw Collingbourne. Last updated 02/2023.</li> <li>Learn Algorithms with Object Pascal/Delphi 2022 by Muminjon Abduraimov. Last updated 01/2023.</li> </ul>"},{"location":"docs/resources/videos/#swinbourne-university-of-technology","title":"Swinbourne University of Technology","text":""},{"location":"docs/resources/videos/#introduction-to-programming-in-free-pascal","title":"Introduction to programming in Free Pascal","text":"<p>Published 2015. Last updated 2021.</p> <ul> <li>0.1 Introduction to programming in FPC</li> <li>0.2 Installing FPC in Linux</li> <li>0.3 Installing FPC in macOS</li> <li>0.4 Installing FPC in Windows</li> <li>1.1 Programs and sequence</li> <li>1.2 Programs and Procedures</li> <li>2.1 Variables</li> <li>2.2 Procedures with parameters</li> <li>2.3 Functions</li> <li>2.4 Hand execution</li> <li>3.1 Control flow</li> <li>3.2 If statements</li> <li>3.3 Looping</li> <li>3.4 Case statements</li> <li>3.5 Modules</li> <li>3.6 File I/O</li> <li>4.1 Records</li> <li>4.2 Enumerations</li> <li>4.3 Pointers</li> <li>4.4 Function Pointers</li> <li>5.1 Arrays</li> <li>5.2 Dynamic arrays</li> <li>6.1 Abstraction</li> </ul>"},{"location":"docs/resources/videos/#tim-coates","title":"Tim Coates","text":"<p>WordPress: https://timcoatesinsights.wordpress.com</p>"},{"location":"docs/resources/videos/#the-silver-coder","title":"The Silver Coder","text":"<p>Last updated 2024.</p> <p>This Youtube channel has tips for Delphi and Lazarus IDE.</p> <ul> <li>The \"Joys\" of User Interfaces? - Decisions That Make or Break Your App</li> <li>Journey to the dark side: experimenting with Lazarus and Indy (Ep 2) </li> <li>Coding Session with The Silver Coder</li> <li>Delphi App Internationalization: Formatting Dates, Currencies &amp; More </li> <li>Coding Challenge: LeetCode Question in (Object) Pascal </li> <li>My first look at Lazarus and Free Pascal</li> <li>Don't freak out! It's just a bug: Debugging with Delphi </li> <li>Building a Shopping List FMX  - Version 0.11 </li> <li>Building a Shopping List FMX  - Version 0.1 </li> <li>Building a Shopping List - Ideas</li> <li>Cool features of Object Pascal and Delphi </li> <li>Starting an Adventure with Delphi</li> </ul>"},{"location":"docs/resources/videos/#hello-world-computing","title":"Hello World Computing","text":""},{"location":"docs/resources/videos/#pascal-tutorials","title":"Pascal: Tutorials","text":"<p>Last updated on 30 May 2014.</p> <ul> <li>Part 1 - Getting to know Pascal</li> <li>Part 2 - Hello, World!</li> <li>Part 3 - Input / Output</li> <li>Part 4 - Variables and their roles</li> <li>Part 5 - Simple Mathematics</li> <li>Part 6 - Simple Calculator</li> </ul>"},{"location":"docs/resources/videos/#schoolfreeware","title":"SchoolFreeware","text":""},{"location":"docs/resources/videos/#free-pascal-tutorial","title":"Free Pascal Tutorial","text":"<p>Last updated on 2 Jul 2014. </p> <ul> <li>1 - Getting Started - Lazarus Download Link</li> <li>2 - Math Examples</li> <li>3 - Variables and Data Types</li> <li>4 - User Input</li> <li>5 - If Statements</li> <li>6 - Case Statement</li> <li>7 - While Loop</li> <li>8 - Repeat Until Loop</li> <li>9 - For Loop</li> <li>10 - Input Validation</li> <li>11 - Preventing Crashes With Val</li> <li>12 - Menus For User Friendly Programs</li> <li>13 - Random Numbers Code Example</li> <li>14 - Guess My Number Game</li> <li>15 - Procedures</li> <li>16 - Passing Values To Procedures</li> <li>17 - Function Examples</li> <li>18 - Arrays</li> <li>19 - Gotoxy Screen Location</li> <li>20 - Parallel Arrays</li> <li>21 - 2 Dimensional Arrays - Matrix</li> <li>22 - Finding The Highest And Lowest Array Element</li> <li>23 - Preventing Duplicate Data In Arrays</li> <li>24 - String Manipulation</li> <li>25 - Palindrome Strings</li> <li>26 - Separating Strings With ASCII Codes</li> <li>27 - Separating Strings With Ranges</li> <li>28 - Running External Programs - IE Batch MS Paint</li> <li>29 - On The Record</li> <li>30 - Array Of Record</li> <li>31 - Making And Writing To Text Files</li> <li>32 - Reading Text Files</li> </ul>"},{"location":"docs/resources/videos/#free-pascal-app-tutorial","title":"Free Pascal App Tutorial","text":"<ul> <li>App Tutorial 1 - Getting Started And Free Download Link</li> <li>App Tutorial 2 - Shrinking The Application File Size</li> <li>App Tutorial 3 - Events Example Code</li> <li>App Tutorial 4 - The Meaning Of Life Explained</li> <li>App Tutorial 5 - Simple Calculator Part 1 - Form Setup</li> <li>App Tutorial 6 - Simple Calculator Part 2 - String Conversion</li> <li>App Tutorial 7 - Simple Calculator Part 3 - Radio Buttons</li> <li>App Tutorial 8 - Simple Calculator Part 4 - Try Except Error Handling</li> <li>App Tutorial 9 - Simple Calculator Part 5 - Tabs - Finished Application</li> <li>App Tutorial 10 - Playing Wav Sound Files On Windows computers</li> <li>App Tutorial 11 - Playing Wav Sound Files On Mac computers</li> <li>App Tutorial 12 - System Timer Bouncing Ball Animation - Shapes</li> <li>App Tutorial 13 - Bouncing Balls Animation - Parallel Arrays</li> <li>App Tutorial 14 - OnPaint Drawing</li> </ul>"},{"location":"docs/resources/videos/#prepared-mindfulness","title":"Prepared Mindfulness","text":""},{"location":"docs/resources/videos/#lazarus-rad-pascal","title":"Lazarus - RAD Pascal","text":"<p>Last updated on 3 Jun 2014.</p> <ul> <li>Learning to program 1 - Pascal Lazarus - Install a free IDE</li> <li>Learning to program 2 - Pascal Lazarus - Hello World - Making the window</li> <li>Learning to program 3 - Pascal Lazarus - Variables</li> </ul>"},{"location":"docs/resources/videos/#marcus-fernstrom","title":"Marcus Fernstr\u00f6m","text":"<p>Github: https://github.com/MFernstrom Medium: https://medium.com/@marcusfernstrm</p>"},{"location":"docs/resources/videos/#tech-swords","title":"Tech &amp; Swords","text":"<p>Last updated 2022.</p> <ul> <li>Install FreePascal, Lazarus, Packages, Cross Compilers, and OPM the EASY way</li> <li>Lazarus build modes, cross compiling, and testing the app in a Linux virtual machine</li> <li>Create REST APIs in FreePascal &amp; Lazarus</li> <li>Generate JSON Data in FreePascal / Lazarus</li> <li>Create REST APIs in FreePascal &amp; Lazarus (with zoom)</li> <li>Learn how to consume JSON data in FreePascal</li> <li>MySQL and FreePascal</li> </ul>"}]}